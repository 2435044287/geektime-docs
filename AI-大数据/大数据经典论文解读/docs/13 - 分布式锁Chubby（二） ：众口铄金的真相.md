你好，我是徐文浩。

上一讲里，我为你解析了两阶段提交和三阶段提交是怎么回事儿。相信你和我一样，对这两种解决方案都不太满意。虽然它们可以帮助我们实现一个分布式的事务，但同时也有着很明显的缺陷：这两个都是一个“单点”特别明显的系统，一旦作为单点的“协调者”出现网络问题或者硬件故障，整个系统就没法运行了。另一方面，如果你为了一致性，选择了两阶段提交，那么整个系统就是“同步阻塞”的，意味着整个系统的性能也会受到很大的影响。

单点故障和同步阻塞，使得所谓的“分布式”系统的优势完全没有发挥出来。所以，我们需要一个对单点没有依赖，并且不是同步阻塞的解决方案。而这个方案呢，就是我今天要给你解读的**Paxos算法**。并且在这节课里，我还会带你深入来看一下我们一般在数据库领域所说的“事务性”到底是怎么回事儿、所谓的ACID又是什么意思。特别是当我们处于一个分布式的环境下，又会面临什么样的挑战。

在学完这节课之后，我相信你会和我一样，搞清楚这三件事情：

- 数据库领域的ACID具体是指什么，里面的隔离性具体分成哪几种隔离等级？
- 分布式系统场景下，事务怎么来保障系统的“隔离性”？
- Paxos算法，究竟是怎么一回事儿？

而在搞清楚这三件事情之后，你也就掌握了足够的分布式事务和分布式一致性的基础知识，这也就意味着，你能够读懂Chubby的论文了。
<div><strong>精选留言（16）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/15/66/8f/02be926d.jpg" width="30px"><span>在路上</span> 👍（21） 💬（0）<div>徐老师好，分布式事务的一致性（Consistency），要从数据库事务ACID的特性之一，一致性去理解，指的是不同数据不会产生矛盾。分布式共识（Consensus），分布式系统的各个部分就按何种顺序处理数据达成一致意见的过程。也就是说一致性是结果，共识是达成一致的过程。可串行化（Serializable）是数据库事务中的概念，指的是事务被顺序处理，可线性化（Linearizability）是分布式中的概念，读操作可以读到最新写入的数据。以两次读取操作为例，可以看到Serializable和Linearizability的区别，在Serializable的要求下，两次读取操作需要顺序执行，在Linearizability的要求下，则可以并发执行。

至于为什么翻译之后为什么会很接近，这是由不同的文化差异造成的，有些词换一门语言找不到对应的表达方式。比如汉语会区分父亲和母亲两边的亲戚，有叔叔、伯伯、舅舅多种称呼，而英语中只有Uncle。阿拉伯人对骆驼的命名，爱斯基摩人对雪的命名，很多都是中文不能翻译的，而大家掌握的方言也是如此，有些词没法准确的翻译成普通话。</div>2021-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/2c/56/ff7a9730.jpg" width="30px"><span>许灵</span> 👍（9） 💬（2）<div>这个隔离级别的介绍好像有问题：串行化是为了解决幻读，幻读是在一个事务中，原来没有的记录，在执行事务的过程中增加了，导致的。可这里在可重复读中描述的问题就是不可重复读，可重复读级别，会把相关的数据加锁，所以在事务完成前，应该是刷不了卡的。</div>2021-11-15</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKLdSIS5xTGV5lBh9HTia1dFgI3UTHfF6nPcAl85JOWEslfa79DHevGbKm5rnzhsFgmIadecfVVBhw/132" width="30px"><span>张建闯</span> 👍（5） 💬（0）<div>从数据库事务到状态机复制这个地方绕了好大一圈，本来没有这个疑惑，但是讲完这个完全给讲蒙圈了，看了两三遍才看明白，这两个是讲两个事情，为什么非要讲一下数据库事务呢？？

是我还是没有明白这两个的关联，还是，这个地方本来就没有什么关系呢</div>2021-10-25</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132" width="30px"><span>Helios</span> 👍（4） 💬（0）<div>感觉没必要介绍数据库的隔离级别，和分布式共识其实没啥关系，就是名字长得像吧。</div>2021-12-30</li><br/><li><img src="" width="30px"><span>Geek_789fcf</span> 👍（2） 💬（2）<div>针对图有几处不明白：
1、既然S1，S2，S3代表服务器，那图里的备注“S3，server 1，即ID为1的服务器”，是不是应该写成&quot;S3，server 3，即ID为3的服务器”
2、既然S1，S2，S3都是提案者，又是接受者，那为什么S1发起的提案，图中S3没有画出来
3、提案4.2：代表第4轮，服务器2发出的提案，为什么在图中是S3发起的提案，但提案号是4.5？</div>2021-10-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/7e/5a/da39f489.jpg" width="30px"><span>Ethan New</span> 👍（2） 💬（1）<div>一个事务里会多次读取我们的银行卡余额。如果在这个过程中，我们在其他地方刷卡消费了，那么两次读到的余额会不同。这个隔离级别一般也不太会使用，因为这样一个事务中两个完全相同的读操作，会读到完全不同的数据，也就是会出现“幻读”。------这个问题不是幻读，是不可重复读。RR隔离级别是解决不可重复读的，mysql innodb存储引擎也能同时解决有些情况下的幻读。可序列化才能解决幻读。</div>2021-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg" width="30px"><span>Eternal</span> 👍（1） 💬（0）<div>1、分布式共识是一种协议，一种方法论，按照这个协议流程多个参与者可以针对某一个决议达成一直的结论；
2、分布式事务，是行为描述，是描述我多个参与者做一个决议，这个决议的内容可能相同，可能不同角色内容是不同的，但是要求做的这个动作是满足ACID的；
3、可以用raft共识协议达成分布式事务的一致，可以用paxos共识协议达成分布式事务的一致，可以用；两阶段，三阶段协议达成分布式事务的一致，可以直接用一把锁达成分布式事务的一致，关键是这个事务行为的一致的要求是是什么？是什么隔离级别？性能？容错等？


可串行化和可线性化的理解：
可串行化：理解成一个操作的互斥程度，还是单机的例子，一个文件命A和B同时来修改，不管谁先谁后，都是一个操作完成后，另外一个才开始；迁移到分布式事务的场景来看，也就是事务之间也是要支持这种串行执行的效果，因为本身可以随意改的，但是要支持这种效果
可线性化：是在操作数据的这个角色视角来看的，我写入了马上能查到，操作者不关系底层是分布式的还是单机的
</div>2023-03-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/54/b7/abb7bfe3.jpg" width="30px"><span>Elon</span> 👍（1） 💬（1）<div>可线性化（Linearizability）和可串行化（Serializability）在英文环境中看着还挺像的，通过中文翻译了一次之后反而觉得还好。

串行化指在竞态条件（至少一个写操作）出现时，一次一个的执行操作。

线性化指写请求完成后，读请求能读到刚刚写入的值，使得多台机器组成的集群看起来只有一个数据副本一样。</div>2021-10-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/3a/65/d1/fa416e5d.jpg" width="30px"><span>zzzx</span> 👍（0） 💬（0）<div>读已提交 和 可重复读 在读的时候加锁就 可以解决一房两卖的问题</div>2024-03-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/44/3c/8bb9e8b4.jpg" width="30px"><span>Mr.Tree</span> 👍（0） 💬（0）<div>串行化就是事务是一个一个执行的，对相同的数据执行并发的读&#47;写，写&#47;写只能一个一个的执行，这应该也是共识算法所达成的效果，既这一轮只能有一个提案者的提案被接受执行，对于同一数据只要通过共识就算成功；可线性化是同一个客户端发起操作成功之后，对于分布式下所有副本的读&#47;写都是基于前一个操作下的</div>2024-01-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" width="30px"><span>Linuxer</span> 👍（0） 💬（0）<div>还以卖房子为例，B 向 A 卖房子，事务执行到第 5 步，但是事务还没有提交。这个时候 C 再向 B 买同一套房子，在第 2 步检查房产证数据的时候，会觉得 A 已经有这套房子了。后面的A应该是B吧</div>2023-01-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/15/8e/ae3304c2.jpg" width="30px"><span>demo</span> 👍（0） 💬（0）<div>Paxos分为Prepare和Accept阶段 超过半数Accept了自己的提案,那么提案通过
1,Prepare阶段没有发现接受更小的提案,Accept没有发现更大的Prepare提案号码(Accept阶段是过半数就认为没有发现) 那么本次提案成功
2,Prepare阶段发现 接受 了比自己的更小的提案内容,就会把自己的提案内容改为 接受 的X加速提案通过
3,Prepare阶段比较顺利,Accept阶段发现自己的Prepare被撬墙角,(被撬墙角过半),无奈放弃本次Accept,重新Prepare等待下次Accept过半</div>2022-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg" width="30px"><span>沉淀的梦想</span> 👍（0） 💬（0）<div>个人认为分布式共识&#47;一致性模型是比事务更弱的一个保证。
分布式共识只需要解决多个节点同样数据的复制问题，也不需要保证多条操作的原子性，利用这个特点可以做一些额外的优化，所有产生了共识算法。
分布式事务算法虽然也可以用来做共识，但是事务的功能本质上更加强大，甚至支持在多个节点写入不同的值，用在这个要求更弱的场景，会导致单点问题和更弱的性能。</div>2022-11-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg" width="30px"><span>吴小智</span> 👍（0） 💬（0）<div>个人理解，在分布式的语境下谈一致性，指的是数据一致性和事务一致性两个方面；可串行化说的是数据一致性，写后要能读到；可线性化说的是事务一致性，数据库系统要保证事务执行后的结果与一个个执行事务是一致的。</div>2021-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg" width="30px"><span>webmin</span> 👍（0） 💬（0）<div>可串行化是指事物的隔离性，每个事物是串行执行，可串行化事物并不意味着在分布式多副本情况下每个事物按发生时间在副本上执行，只保证每次执行一个。
可线性化是说操作所有副本的行为与操作只有一个副本是一样的，且每个操作都是原子的，即对于任何两个操作，总是可以指出哪个操作在先。</div>2021-10-23</li><br/><li><img src="" width="30px"><span>Geek_88604f</span> 👍（0） 💬（0）<div>在分布式系统中，分布式共识是分布式事务一致性的基础。还是以转账为例，首先通过分布式共识算法将谁给谁转账这个事实记录为日志，然后在遇到故障时通过这个日志进行重做或撤销，从而实现一致性。</div>2021-10-21</li><br/>
</ul>