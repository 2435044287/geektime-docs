你好，我是陈东。

在基础篇中，我们学习了许多和检索相关的数据结构和技术。但是在大规模的数据环境下，这些技术的应用往往会遇到一些问题，比如说，无法将数据全部加载进内存。再比如说，无法支持索引的高效实时更新。而且，对于复杂的系统和业务场景，我们往往需要对基础的检索技术进行组合和升级。这就需要我们对实际的业务问题和解决方案十分了解。

所以，从这一讲开始，我会和你一起探讨实际工作中的系统和业务问题，分享给你一些工业界中常见的解决方案，帮助你积累对应的行业经验，让你能够解决工作中的检索难题。

在工业界中，我们经常会遇到的一个问题，许多系统要处理的数据量非常庞大，数据无法全部存储在内存中，需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如MySQL和Oracle，就是这样的典型系统。

数据库中支持多种索引方式，比如，哈希索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型。因此，今天我们就一起来聊一聊磁盘上的数据检索有什么特点，以及为什么B+树能对磁盘上的大规模数据进行高效索引。

## 磁盘和内存中数据的读写效率有什么不同？

首先，我们来探讨一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" width="30px"><span>每天晒白牙</span> 👍（28） 💬（1）<div>1.磁盘和内存中数据读写效率的对比
内存是半导体元件，访问速度快，可以直接根据地址读取数据

磁盘是机械器件，在读取数据时需要移动磁盘进行寻址，这个过程比较慢。所以在随机读写方面，磁盘远远慢于内存。但磁盘也有它的特点，磁盘最小读写单位是扇区，而操作系统的最小读写单位是块(块往往是多个扇区的组合)，正是因为这种特性，使得磁盘的顺序读写性能远高于随机读写。

所以，要想在磁盘中实现高效检索的重要原则是:对磁盘的访问次数尽可能少

2.有效减少磁盘访问次数的思路是将索引和数据分离
因为高效检索的原则是减少对磁盘的访问，对于数据量比较小的情况，可以直接把磁盘中的数据加载到内存中，可以利用内存的局部性原理加快检索。但现实往往是数据量非常大，所以我们还是需要借助磁盘来存储数据。访问磁盘必不可少，但可以通过将索引和数据分离的办法来减少对磁盘的访问。

将索引和数据分离的初衷是把索引存到内存中，数据存到磁盘中。索引可以有三种方案:
①线性索引，比如用数组存放。但数组在数据频繁变更的场景下不适合，因为数组更新涉及到大量数据的移动
②哈希索引，缺乏范围检索能力，适用场景有限
③树形索引，比如用二叉检索树，既支持范围检索，又能保证数据频繁更新的情况下数据移动数量少，所以具有普适性。

即使二叉检索树实现所以有诸多好处，但也避免不了数据量太大的情况不能完全加载到内存中的这种情况，所以只能将索引数据也存到磁盘中。

3.b+树的设计
b+树是一棵完全平衡的 m 阶多叉树。m 阶表示每个节点最多有 m 个子节点，并且每个节点存的是一个可以容纳 m 个元素的紧凑数组。所以一般 b+ 树比较矮，2-4层的 b+ 树就能存储非常大的数据量了。
b+树有几个设计思想:
①让一个节点的大小等于一个块的大小，节点内存储可以装下多个元素的有序数组。这样就可以充分利用操作系统按块读取的特性，使得读取效率最大化。
②将节点区分为内部节点和叶子节点。他们结构相同，但存储的内容不同。
内部节点存储 key 和维持树形结构的指针
叶子节点存储 key 和数据
这么做可以使得内部节点存储更多的索引数据。
③所有节点通过双向链表串联
可以方便范围查询，这样的做法也有点跳表的意思。

b+树如何检索？
先从磁盘加载根节点所在的块，然后通过二分查找要检索的数据在数组中哪两个相邻元素中间，然后不断读取块，直到读到叶子节点，有了叶子节点就可以在叶子节点的数组中通过二分查找要检索的数据对应的指针。然后通过指针读取磁盘获取数据。
【如果内存空间比较充足，可以把内部节点全部加载到内存中，以减少读取磁盘的次数】

b+树如何动态调整？
再添加数据和删除数据时，b+ 树为了保证平衡可能会进行页分裂和页合并【正是由于存在页分裂和页合并，所以叶子节点在磁盘上并不是连续存储的】

4.思考题
B+ 树有一个很大的优势，就是适合做范围查询。如果我们要检索值在 x 到 y 之间的所有元素，你会怎么操作呢？
先查找 x 元素对应的叶子节点，然后往后遍历直到大于 y 元素停止

5.疑惑
我记得 MySQL b+树索引的叶子节点存储的是数据，老师在专栏中介绍存储的是元素的位置信息，这里有些疑惑，还请老师指点一下。

6.问题请教
这个问题也和检索相关，但可能和今天的主题没啥关系
我们 DSP 这边需要对 ADX 请求过来的数据解析判断，现在 ipv6 的数据多了，我们想在调用内部 ip 定位服务前对这些数据进行缓存，key 对应 ipv6 地址，value 是 ip 对应的内部 localId，还要有过期时间。这里可以考虑放 redis 中，但我们想有没有其他好的方案。我同事做了一个对 ipv4 不错的缓存方案，因为 ipv4 都是数字，我们内部认为前三位相同就对应同一个 localId，他采用 long 类型的三维数组来存储，三位数组的下标对应 ipv4 的前三个数字，数组对应的值是 localId || cacheTime &lt;&lt; 32 的值，即用一个 long 型的高 32 位存缓存时间，低32位存 localId，这个方案性能很好。但 ipv6 不止数字，这个方案套不进去，调研了一些，有说使用 Trie 树来做，但我看 Trie 树的应用场景是判断字符串是否存在，我们这个场景好像用不上或我没想到用的办法，还请老师指点一下，用什么样的检索方法实现 ipv6 达到类似 ipv4 那样的功能。
</div>2020-04-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（25） 💬（3）<div>先通过二分查找找到 x 元素， 然后往后遍历叶子节点的链表（链表是有序的） 直至大于 y 停止，得到范围。 这里不能使用两次二分查找的原因是，叶子节点数据结构是链表，内存不是连续的，即使使用了2次二分查找找到了 x 和 y 还是要遍历链表得到这个范围的所有值的。 对于有序数组是可以的，因为内存是连续的</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/0f/70/cdef7a3d.jpg" width="30px"><span>Joe Black</span> 👍（16） 💬（2）<div>之前看过别的文章说，大量插入数据时，最好索引字段是有序的，尽量别是UUID这样完全随机的值。看了这篇课程，感觉是不是因为如果索引值太随机，会导致B+树很频繁的分裂节点呢？如果插入的时候有序，是不是性能更好？</div>2020-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg" width="30px"><span>青鸟飞鱼</span> 👍（14） 💬（1）<div>老师你好，b树、b+树都可以应用于关系数据库，而MongoDB作为非关系数据库，用的就是b树，而非LSM树，这几种树有什么应用场景吗？</div>2020-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg" width="30px"><span>夜空中最亮的星</span> 👍（10） 💬（1）<div>今天的课需要听2遍</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" width="30px"><span>峰</span> 👍（6） 💬（2）<div>看到大家都倾向于说一次查找，然后条件遍历，出于的考虑是遍历是不可避免的。遍历虽然不可避免，但遍历每条数据的判断是可以避免的，所以这里取舍的点在于对每条数据判断和多一次查找，后者可能带来更大的io开销，而且tp场景数据量也不多，不会遍历太多块，最后就是传统tp数据库查询瓶颈在io延时而不是吞吐更不是cpu多几次条件判断上。</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg" width="30px"><span>wangkx</span> 👍（6） 💬（2）<div>感谢陈东哥，从计算机的组成原理到B+树，娓娓而谈，自己受益良多。
我一个非计算专业的都可以听得很明白。

其实，各种高级的算法和数据结构，都是在不同的应用场景下，对最基础的数据结构和算法进行的组合。所以说，基本功很重要！

对于最后的思考题：
先通过内部节点找到x，继而找到叶子节点对应的元素，顺序读写对于硬盘来讲效率并不低，所以顺序遍历叶子节点找到y结束检索。

之所以硬盘顺序读写效率不低，是因为数据从硬盘读取到内存的时候是按块读取的，在内存中检索的时候可以复用读取的块内容。

我之前读资料看到，cpu缓存的局部性原理，【对于硬盘的按块读取，这个算不算局部性原理呀？】
</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg" width="30px"><span>时隐时现</span> 👍（4） 💬（1）<div>&quot;节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组&quot;
如果元素频繁更新，采用有序数组不是个好主意，至少mysql用的是单向链表 + page directory。
单向链表是为了遍历查询。
page dirctory则是一个数组，记录第N*M个元素的page offset，当执行kv查询时，借助page directory对节点页内的单向链表实现二分查找。</div>2020-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg" width="30px"><span>牛牛</span> 👍（4） 💬（3）<div>B+树 
1. 只有叶子节点存储数据 
2. 一个节点上存储的是一组数据, 数组存储
3. 同一层的节点之间用双向链表串在一起
这样的话、我觉得范围查询时、可以先找到 min 所在的叶子节点位置、再找到max所在的叶子节点位置、min和max的查询效率很高、再利用同一层间的双向链表应该可以很快的找到所有元素 ?

----------
我也不知道对不对, 若有不对的地方、希望老师指正、别误导看到的同学~~~</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg" width="30px"><span>牛牛</span> 👍（3） 💬（1）<div>又读了一遍, 有个疑问: 既然内部节点存储的只是key和维持树形结构的指针, 那么是怎么知道下一个block的位置的呢 ? 
另外, 在读问答区的时候, 有个回复里说, 联合索引内部节点存储的是多列数组, 这里是每个数组存储一列吗 ?(PS: 假如A、B、C组成联合索引, 内部节点数组会是[[A], [B], [C]]还是 [A, B, C]) ？ 为什么呢 ? 猜想: 因为联合索引可以使用最左前缀, 应该是[[A],[B],[C]]保持多维度(A-&gt;B-&gt;C)有序 ?</div>2020-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg" width="30px"><span>阿斯蒂芬</span> 👍（3） 💬（2）<div>看到B+树，倍感“亲切”，想起当时因为看数据库原理看到索引的实现，B+树一直搞不太明白，于是重新学习数据结构，看完数据结构又发现索引还跟“数据页”“磁盘IO”等相关，又去补操作系统，虽然现在对B+还是不精通，但比起起初好太多。老师这篇专栏，也是很全面剖析了B+树相关联的许多知识点，受益颇深。
我也来提几个疑惑：

 内部节点（除根节点&#47;叶子节点）外，元素个数 count_e 与指针数 count_p 的关系，是 count_p= count_e ，还是count_p = count_e + 1 ?
比如说某个节点有元素 3,5，那么下面两个哪个才是正确？
指针方案一：p1&lt;3, 3&lt;=p2&lt;5， 5&lt;=p3
指针方案二：3&lt;=p1&lt;5, 5&lt;=p2
提出这个问题是因为看了许多讲解B+树的，大家画的图都集中在这两个类型，是有点迷。

维护B+树过程中，节点元素过多，导致B+树变成“违规”状态，因此需要分裂，从叶子节点递归向树根分裂，在根节点已满的时候，如何处理根节点? wiki上说会“新建一个根节点”，那是否会改变树的阶数？

维护B+树过程中，节点元素过少，会导致B+树变成“违规”状态，因此需要转移或合并，如果合并，删除节点后，应该也要递归向树根检查？是否也会如上一个问题到达根节点，而产生新的根节点？

上述讲述维护B+树过程中，都有一个判断元素数量是否“半满”的条件，这个半满是否就是m阶B+树的 m&#47;2, 那么这个值是如何推导出来的，或者说，如何证明半满是对m阶B+树最好的实现?</div>2020-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg" width="30px"><span>pedro</span> 👍（2） 💬（1）<div>问题: 先找到 x 然后遍历找到 y，原因大概是涉及磁盘操作，顺序 io 的速度远大于随机 io，因此如果找 y 也使用二分搜索的话，io 成本高，消耗的时间大于顺利遍历。</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg" width="30px"><span>无形</span> 👍（2） 💬（2）<div>先找到x所在叶子节点，叶子节点数据二分查找找到x，然后向右遍历直到不在x和y区间内
感谢老师的分享，又学到了好多👏，我之前写的就只是有序数组二分查找，是时候好好改造了😃</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg" width="30px"><span>苏暮沉觞</span> 👍（1） 💬（2）<div>老师，我对b+树在检索的时候，读取磁盘的次数有疑问：正如文中说的，一个4层的B+树，前三层也就是160000个节点都可以保存到内存中，如果我们把160000个节点都保存到内存中，磁盘访问次数大概是多少吗？</div>2020-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg" width="30px"><span>青鸟飞鱼</span> 👍（1） 💬（2）<div>1.先通过二分法查找到x，将整个块数据加载到内存中，因为块里数据是有序数组，需要通过二分法（其他方法）查找是否存在y。存在则停止查找；不存在的话继续磁盘，重复上面的动作，这种就是二分法查找。
2.通过二分法查找到x后，直接链表遍历下一块的第一个数据与y数据比较大小，来找到范围。
不知这两种哪种是对的，还是都不对，看评论区都是遍历链表，感觉这种遍历链表只有一个数据。希望东哥可以解开我的疑惑？</div>2020-04-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg" width="30px"><span>花晨少年</span> 👍（1） 💬（4）<div>请问内部节点和叶子节点的value有什么区别，一个是pointer，一个是pos，不管是叶子节点还是内部节点都有可能在硬盘中，那么这个时候内部节点的pointer是不是也表示为文件中的偏移量呢，也就是说内部节点的value可能是内存中的地址，也可能是文件中的偏移吗</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" width="30px"><span>范闲</span> 👍（1） 💬（1）<div>为什么要有B+ tree
1.数据容量过大的时候，内存无法一次性加载
2.内存的读写速度比磁盘有数量级上的优势，所以不能将数据全部放入磁盘（速度慢），也不能全部放入内存（资源昂贵）
B+:索引和数据分离，三层数结构。索引存入内存提高速度，数据存入磁盘提高存储容量。
数据架构:树+双向链表（树提供了二分查找的能力，双向链表提供了范围检锁的能力）

课后题:
1.先利用二分查找确定start的位置
2.然后向右测走step(y-x)步（如果每组叶子节点还记录了这组长度，实际更容易理解），至此确定了x-y的范围，可以读取对应的block，获得最终数据。</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/97/69/791d0f5e.jpg" width="30px"><span>null</span> 👍（0） 💬（3）<div>老师您好，搜索或者广告召回场景，倒排存储和lsm适合结合嘛，正排倒排，文件持久化更行，可否使用rocksdb这样的引擎持久化，有什么思路和优劣。自行研发一套海量广告召回系统，如何组织比较合适，百度级别的数据量？</div>2021-02-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/df/e5/65e37812.jpg" width="30px"><span>快跑</span> 👍（0） 💬（1）<div>有个疑问，假如自己实现一个索引与数据分离的线性索引。实现代码过程中怎么显式将一个对象保存到磁盘上？索引上的position存的又是什么样子的数据</div>2021-02-20</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Ryl35QN5UMAtDW4akGRyMzXEOzjXzTaXD9Tvf0M8mEvf7Kds5u8b9RvFul8oItBib8icrhyOy1xWXVDqDbicWu3nQ/132" width="30px"><span>Geek_d142f6</span> 👍（0） 💬（1）<div>根节点的值就是表的第一行数据的值吗？</div>2021-01-24</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132" width="30px"><span>大头爸爸</span> 👍（0） 💬（1）<div>如果采用SSD作为存储介质，是不是B+树的优势就没那么大了？</div>2020-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" width="30px"><span>aoe</span> 👍（0） 💬（1）<div>这篇文章让我对B+树有了新了认识：
1. 一般来说，如果是随机读写，会有 10 万到 100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。

2. B+ 树的一个关键设计，就是让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。

3. 一个很重要的设计思想：将索引和数据分离。通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在许多大规模系统中，都是使用这个设计思想来精简索引的。B+ 树的内部节点和叶子节点的区分，是索引和数据分离的一次实践。

读完很开心！</div>2020-04-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/50/c2/3470edf9.jpg" width="30px"><span>Lock</span> 👍（0） 💬（2）<div>记得mysql如果是联合索引，非叶子节点其实也存储了部分数据列信息，所以写sql的时候只select需要的列效率会更高一点，select *的话，如果当前用的是二级索引，会有一次回表操作再定位到一级索引上，一级索引的叶子节点在拿到完整数据 ，不知道有没有理解错</div>2020-04-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg" width="30px"><span>yang</span> 👍（0） 💬（1）<div>东哥讲的很好，评论区的同学也很认真，期待您更多这样的文章！</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（0） 💬（3）<div>对于 B+树的插入和删除，第一步是不是应该是 先通过二分查找找到需要插入或删除的位置，然后在进行对应的操作</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg" width="30px"><span>Mq</span> 👍（0） 💬（2）<div>先找大于等于x的元素，然后遍历元素判断是否大于y如果大于就终止</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/24/53/e9965fe1.jpg" width="30px"><span>丶诸葛</span> 👍（0） 💬（0）<div>个人认为，翻译为随意访问&#47;任意访问比随机访问更贴合Random Access Memory的含义，因为随机在中文语境中更多作为一个统计学概念出现，蕴含着不确定性；而RAM想表达的：给定一个（确定的）内存地址时，可以快速取出数据，这是一种“任意”的数据访问。</div>2024-02-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（0）<div>B+ 树最大的优点在于，它提供了将索引数据存在磁盘中，以及高效检索的方案。--记下来</div>2023-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/bc/cd0761ff.jpg" width="30px"><span>Richeir</span> 👍（0） 💬（0）<div>m 阶的b+树每个节点最多应该是 m-1 个元素吧</div>2023-03-23</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLHGYFKjvRiaia82t68OGkqvtIFvibZCmA3OKA1kj9vWaqQhYgKIqa94nKcmq1pbf6Efx4sO4yUHXEDA/132" width="30px"><span>zhaozheng</span> 👍（0） 💬（0）<div>感谢老师的分享，有一个疑问，这里提到叶子节点里面存的是磁盘地址，“磁盘地址”是个比较抽线的概念，请问具体的数据结构是什么呢，是 file 指针么？</div>2023-03-09</li><br/>
</ul>