你好，我是陈东。欢迎来到检索专栏的第二次加餐时间。

在上一篇加餐中，我们讲了工业界中，倒排索引是怎么利用基础的数据结构来加速“求交集”过程的。现在，相信你已经对跳表、哈希表和位图的实际使用，有了更深刻的理解和认识了。然而，在日常的检索中，我们往往会面临更复杂的联合查询需求。这个时候，又该如何加速呢？

我们先来看一个例子：在一个系统的倒排索引中，有4个不同的key，分别记录着“北京”“上海”“安卓”“学生”，这些标签分别对应着4种人群列表。如果想分析用户的特点，我们需要根据不同的标签来选择不同的人群。这个时候，我们可能会有以下的联合查询方式：

1. 在“北京”或在“上海”，并且使用“安卓”的用户集合。抽象成联合查询表达式就是，（“北京”∪“上海”）∩“安卓”；
2. 在“北京”使用“安卓”，并且是“学生”的用户集合。抽象成联合查询表达式就是，“北京”∩“安卓”∩“学生”。

这只是2个比较有代表性的联合查询方式，实际上，联合查询的组合表达可以更长、更复杂。对于联合查询，在工业界中有许多加速检索的研究和方法，比如，调整次序法、快速多路归并法、预先组合法和缓存法。今天，我们就来聊一聊这四种加速方法。

## 方法一：调整次序法
<div><strong>精选留言（9）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg" width="30px"><span>wangkx</span> 👍（20） 💬（7）<div>陈老师您好，文章中提到的第四个算法LRU算法，在使用哈希表和链表的实现中，链表的数据结构有必要使用双向链表吗？既然有哈希表的映射关系了，是不是一个简单的链表就可以啦。

或许我哪里思考的不全面，需要向您请教~~~
</div>2020-04-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" width="30px"><span>峰</span> 👍（12） 💬（2）<div>1. 调整次序： 在数据库的最常见的就是join-order这个老大难问题，堪称数据库一朵大乌云。。。
2. 快速多路归并法： 多路归并可谓是数据库解决数据排序，尤其是不能内排的条件下的一大基础利器，当然像大数据组件里的mr，spark等等，做shuffle时，同样要考虑多个排序数组如何归并的问题。
3.预先组合： 最熟悉的代表就是kylin了， 经典的cube预计算理论，
4. 缓存法：这个就太多了，核心还是局部性原理，所以必须清楚自己的业务场景是否是有那种比较热点的查询，如果每种查询概率都一样，那缓存法也是浪费，所以mysql在某个版本之后把sql到结果的缓存给关闭了。
</div>2020-04-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/df/0e/4e2b06d5.jpg" width="30px"><span>流浪在寂寞古城</span> 👍（2） 💬（1）<div>前两种方法：调整批次法和快速多路归并法是实时召回的方法
后两种方法：预先组合、缓存法实际上就跟我们设计系统时redis作为缓存一个道理，防止打穿来提高效率。

但是后两种方法在用的时候应该还要注意实时更新问题，比如搜索引擎中，更新了数据，如果使用缓存那么只能召回已经“计算”好的数据，即使是热点。就搜索引擎的应用，缓存的key应该还要保存一个时间进行重召回替换，比如1分钟这样。一般搜索引擎应该使用双buffer机制来更新。</div>2020-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" width="30px"><span>aoe</span> 👍（2） 💬（1）<div>“快速多路归并法”的图解非常好，一看就明白了。如果只看文字描述，是很难理解的。
老师的图解非常重要，让难以理解的算法变的简单明了。
阅读本专栏全程“轻松愉快”，原来是因为能读懂。很多令人望而生畏的算法，都让图解化解了！
专栏可以有一个别名：检索算法图解。让更多基础不好，又想学习的同学轻松学习。

另外分享一个LRU算法的练习，更好的理解实现原理：https:&#47;&#47;leetcode-cn.com&#47;problems&#47;lru-cache&#47;</div>2020-04-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" width="30px"><span>每天晒白牙</span> 👍（2） 💬（1）<div>思考题：
1.调整次序法
调整次序法是有前提的，就是集合大小要有诧异且调整后优于调整前，所以依赖预判机制

2.快速多路归并法
多路归并法充分利用跳表加快速度，老师说在 ES 中采用了这个方法，在下面我要看看加深理解

3.预先组合法
预先组合法适合用在数据报表分析的场景上，比如我们部门的报表系统就原始数据存放在 hive 上，然后通过 druid 和 kylin 对一些常用的组合做提前预聚合，这样可以加快查询速度。但我们在使用的时候，druid 和 kylin 对组合数和对应的数据也会有限制的，不能滥用，毕竟会浪费内存

4.缓存加速联合查询
缓存和预先组合法挺像，都是提前把数据准备好。但是它俩又有不同，预先组合的数据一般是稳定的，而缓存的数据是热点数据，如果非热点数据放到缓存中，会白白浪费内存，所以存储空间是需要考虑的。再者就是缓存命中率的问题，可以引入 LRU 缓存替换机制，把常用的缓存放到前面能够快速访问。通过双向链表 + 哈希表实现</div>2020-04-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg" width="30px"><span>yang</span> 👍（1） 💬（2）<div>老师，我想问个问题 (jdk_1.8)：
LinkedHashMap 的 accessOrder = true ，它表示遍历的时候按 访问的顺序输出。

我现在 linkedHashMap map; &#47;&#47; accessOrder = true 
map put(1，1);  &#47;&#47; a
map put(2，2); &#47;&#47; b
map put(3，3); &#47;&#47; c

A处： 此时若遍历，打印的顺序是 1 2 3

map. get(2); &#47;&#47; d
B处：此时若遍历，打印的顺序是 1 3 2

我知道accessOrder = true时，每访问过一个元素，都要改变它的位置链到双链表的末尾去。

我的问题是：
既然accessOrder = true 
那它的遍历打印，不应该是最后（最后是时间上的顺序，那也就是最近）访问过的元素先被打印出来吗？

即B处的遍历打印应该是 2 3 1 才对啊 ？

还是应该理解成： 
在B处：1的唯一一次访问是在注释为a的地方访问的； 3的唯一一次访问是在注释为c的地方访问的；2的第一次访问是 在注释为 b的地方访问的，最后一次访问是在注释为 d的地方访问的，访问被更新，因此加到末尾； 由此推出 ==&gt;
1的访问时间最早 1先输出
3的访问时间早于最后一次2的访问时间， 所以接着3输出
2的访问时间由于是最后一次访问更新了访问时间，所以放到链表末尾，表示最后一个访问的。

因此，遍历输出应该是==&gt; 1, 3, 2 而不是 2 开头。

即，访问时间遍历（accessOrder = true）的意思是，最早访问过的先被遍历，最晚访问过的元素，最后被遍历，是这个意思吗？ 我没评论之前还没想明白，评论完了，好像终于想清楚了。还是想找老师确认一下。
恳请老师回答，谢谢老师！</div>2020-04-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/22/09/7bde99f0.jpg" width="30px"><span>许大勇</span> 👍（0） 💬（1）<div>老师，对于快速多路归并法，我有一些疑惑。在多路归并的时候，因为集合可能是链表，那么如果我们是在求交集的时候才对多个数据集合建立跳表这样的数据结构，时间复杂度该如何考虑呢？还是我们应该在求交集前就已经把各个数据集的跳表索引建立好呢？如果数据集都非常大，并且是静态(不会再改变)的，会损失一些跳表本该具有优势的特性吗，比如快速插入和删除？</div>2020-12-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cc/c4/5ac16f31.jpg" width="30px"><span>汤尼房</span> 👍（0） 💬（0）<div>说下对于LRU实现的基本思考：
假设一个容量为3的缓存cache = []，此时添加缓存A，cache = [A]；添加缓存B，cache = [B, A]；添加缓存C，cache = [C, B, A];
访问缓存A后，cache变为[A, C, B]；若此时再要加入缓存D，则因为缓存容量只有3，因此需要淘汰掉最久没被使用的缓存B才可以，因此cache变为
[D, A, C]；从中可以发现缓存的实现有最本质的三个特点，一是各个缓存之间是有顺序的，比如D在A之前，A在C之前（A相比C在最近的时间内被使用过）；
二是要能快速的判断出一个缓存是否在缓存中，比如A是否在cache中；三是从缓存中删除一个元素的操作也要是便捷的（O(1)），所以结合这三点来看，
单单的数组与Dict都是无法满足最优条件的。拿数组来说，其能够满足顺序这个特性，但判断一个缓存元素是否在其中，需要遍历整个数组，
且当删除一个缓存元素时，还伴有数组内元素移动的操作，因此整个的性能开销很大；再来看Dict，Dict能够满足O(1)的缓存元素的快速判断，
且删除元素的操作也为O(1)，但Dict中的元素没有顺序，比如因为缓存容量满了需要淘汰最久没有被使用的元素（按顺序来看，处于最末尾的元素），
此时在Dict中是没有办法识别处于末尾的元素的。所以最好的方式是对基本的数据结构进行组合使用，依然是三个特点：有序，O(1)查找，O(1)删除；
Dict + 数组：数组用于实际存储缓存元素，Dict用于快速判断缓存是否存在，但是数组的淘汰删除策略不是最优的，因此不能满足条件；
Dict + 双向链表：双向链表用于实际存储缓存元素，Dict依然是用于快速判断缓存元素是否存在，双向链表本身有序，且删除一个特定节点操作的时间
复杂度是O(1)，因此LRUCache最终的实现方式是采用Dict + 双向链表
字典dict+双向链表实现
    1. dict存储真正的被封装成双向链表节点的key、value对，即key -&gt; Node(key, value)
    2. 双向链表和上述使用到的数组一样，用于记录元素的位置</div>2023-05-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（0）<div>Nice，very good👍🏻</div>2023-04-07</li><br/>
</ul>