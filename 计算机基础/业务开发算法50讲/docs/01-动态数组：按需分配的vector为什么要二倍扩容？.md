你好，我是微扰君。今天我们进入第一章基础数据结构的学习。

计算机程序一直以来最根本的作用就是处理数据。即使在早期的计算机中，计算就已经不仅仅是几个数字之间的加减乘除那么简单了，经常需要处理大量线性存储的数据，一个很好的例子就是向量乘法。显然，我们需要找到一种合适的方式在计算机中存储这些信息，并能让我们可以快速地进行向量运算。

再举一个更工程化的例子。假设有个需求，我们希望只借助内存实现一个简易的银行账户管理系统，每个账号里包括两个基本信息：账户ID及余额。用户首次开户的时候，会被分配一个账户ID；系统要支持用户通过ID快速查询余额，也可以存款/取款改变自己的余额。

你可能会觉得这有什么难的？用数组就可以解决。建立一个整型动态数组，每来一个用户就给存到数组的某个位置，用该位置的数组下标来当用户的ID就行。查询起来更快，数组大小是动态的，也不用考虑用户数量超过容量上限的问题。

但是，**基于下标随机访问数组元素为什么这么高效？动态数组是怎么做到看起来可以有无限容量？扩容机制的时间复杂度是多少，是不是会带来额外的内存浪费呢**？不知道你有没有思考过这些问题。

今天，我们就带着这些问题一起学习第一种序列式容器vector，也就是动态数组。相信你学完之后，对这些问题的理解就深刻啦。
<div><strong>精选留言（17）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg" width="30px"><span>qinsi</span> 👍（56） 💬（10）<div>两倍扩容的问题在于无法利用已释放的空间，因为假设第n次扩容分配了2^n的空间（省略常数C），那么之前释放掉的空间总和为：

1 + 2 + 2^2 + ... + 2^(n-1) = 2^n - 1

正好放不下2^n的空间。这样导致的结果就是需要操作系统不断分配新的内存页，并且数组的首地址也在不断变大，造成缓存缺失。

假设扩容倍率为x，首次分配的空间为1（同样省略常数C），则第一次扩容分配的空间为x，第二次扩容分配的空间为x^2。如果希望第二次扩容正好能用上之前申请过的空间，则有：

1 + x = x^2

解得x=(1+sqrt(5))&#47;2，约1.618

当然这是简化的分析，因为第二次扩容时要需要把第一次扩容的空间中的数据拷贝出来，所以至少要等到第三次扩容才行，也就是：

1 + x = x^3

更一般的：

1 + x + ... + x^(n - 2) = x^n

当n-&gt;∞时，x-&gt;1.618。所以实际会用比1.618小的值，否则n太大就没意义了。比如Java的ArrayList用的是1.5，那么第5次扩容时就可以利用旧的空间了。

当然这些也只是理论上的分析，实际情况要根据内存分配器的实现具体分析。</div>2021-12-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a6/b6/27412d76.jpg" width="30px"><span>sc</span> 👍（15） 💬（1）<div>在 Java 的 ArrayList 中，没有自动缩容，但是提供了一个  trimToSize() 的方法可以让使用者手动缩容；如果要设计自动缩容的话，可以简单设计成 size 减少到到 capacity&#47;4 的时候，将容量缩减成原来的一半</div>2021-12-12</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（6） 💬（1）<div>如果在存储空间占比低于一半的时候就缩容，会导致反复插入删除回到单步操作O(n)的复杂度，以前见过的实现是存储的空间占总空间的1&#47;4的时候开始缩容一半，可以做到单步均摊复杂度O(1)。数组看似简单，实则精妙，平均浪费一半空间的时候，才能取得较好的性能，也算一种空间换时间的方法。</div>2021-12-13</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLke9yyicW4DA2iaudyom8jD6DZvdRKiaXmeERj5s1mdPu0CcmoVuVqseB3VwMUf0QfRZ1oQlcAt6YQg/132" width="30px"><span>木汀</span> 👍（3） 💬（1）<div>类似 golang 中的 slice，但是在 golang 中，当 slice 的大小&lt;1024时，是2的指数幂次增加长度，但是在&gt; 1024之后就是1.25倍，并做内存对齐操作。</div>2022-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg" width="30px"><span>Aliliin</span> 👍（2） 💬（3）<div>go 语言中提供的 slice 是不是就是动态数组呢，定义的时候，长度并不固定，可以向切片中追加元素，它会在容量不足时自动扩容。也提供了 len 和 cap 函数来获取长度和容量。
当然 go 中的 slice 扩容的方案，不是倍增的方式，而是他自己的算法，小于 1024 才会将容量翻倍，大于 1024 每次只是增加 25% 的容量。但 go 的 slice 扩容之后，会新申请一段内存，拷贝过去，你即便删除了扩容的部分，内容大小也不会变。这时候，因为你是新申请了一段内存，原来的数组用到的内容，一旦没地方引用，就自动释放了。。至于如何再通过缩小原有的内存空间，就不知道怎么搞了。😂，不过比起先导篇中，跟上数学课，笔掉地上再捡起来后就听不懂了的情况来说，这节课至少没分心。</div>2021-12-13</li><br/><li><img src="" width="30px"><span>Space</span> 👍（1） 💬（1）<div>均摊下来是O(1)?? 怎么算出来的的？(2^(x+1) - 1 ) &#47; x == O(1)???? 别逗我</div>2022-03-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/c6/e5/daad1f09.jpg" width="30px"><span>奋青。</span> 👍（1） 💬（3）<div>所以如果我们要插入 n 个元素，需要进行的拷贝次数：1+2+3+…+n=n2复杂度为 O(n^2)，均摊下来每次操作时间复杂度就是 O(n)。 这句话里面的 o(n^2) 是怎么计算得到的呀.</div>2021-12-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/78/dc/bcdb3287.jpg" width="30px"><span>丶</span> 👍（0） 💬（1）<div>二倍扩容后，插入数据的均摊时间复杂度不应该是log（n）吗？？？整体均摊扩容也应该是log（n）吧？？计算如下：插入n个数据，需要需要log（n）次扩容，每次扩容需要转移元素时间复杂度为O（n）。这样插入数据总的时间复杂度就是 n + nlog（n），然后均摊到每一次就是 1 + log（n），最后时间复杂度不应该是log（n）吗？？？类似的插入元素时间复杂度为O（logn）。上面是我的理解，如果有错误，希望指正</div>2021-12-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg" width="30px"><span>友</span> 👍（0） 💬（1）<div>自己总结一下：按照1扩容 那么 1+2+3+4 &gt; 8 其实越往后拷贝的越来越多 每次扩容要拷贝的越来越多，但是之前我疑惑我把数值调大不就行了吗，第一浪费空间不说，可以继续算一下从1-&gt;4 那么每次就是 1+5+9+13+17+21+25 扩容到25需要6次,如果是按1扩容那么就是24次  那么就是减少了C倍而已 当数值越来越大 在 扩容到17的时候应该复杂度就上去了 如果是翻倍扩容  那么 公式就是 1 + 2 + 4 ... +n &lt; 2*n 均摊下来扩容就是O（1）了 
以上是自己的一些小总结 有错误希望各位矫正</div>2021-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg" width="30px"><span>kimoti</span> 👍（0） 💬（1）<div>看完这节感觉可以不至于从入门到放弃</div>2021-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e4/b2/88e62c90.jpg" width="30px"><span>DaveZ</span> 👍（0） 💬（1）<div>扩展C那里，平均应该是O(n)而不是O(1)</div>2021-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/87/98/1de31a08.jpg" width="30px"><span>Dreamer</span> 👍（0） 💬（1）<div>自动代表不可控，线上很多时候，cpu资源和内存资源，更关注cpu资源多一些，其次缩容的阈值不好定。</div>2021-12-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg" width="30px"><span>雷霹雳的爸爸</span> 👍（0） 💬（1）<div>缩容这个我个人感觉是，可以有，但是不要搞什么自动缩…因为删除这个操作和增加这个还真不一样，增加时候满了你不扩就玩儿不转了，因此自动扩容属于必须要实现的能力吧，要不我自己直接用数组不就完事了，但是删除不自动缩更合理，参考本文讲解的每次扩容就加一那个脑补一下就很容易理解了，至于那是不是低到一定水位就可以执行自动缩？这个应该也不能这么玩儿，一个是缩了之后留多少空位的问题，更重要的还是这个执行时机很难选，因为也不知道接下来使用者（甚至还有可能是攻击者？）马上又要作什么妖，所以综上所述，我觉得就不要想在类似标准库里搞什么自动缩容这种事，假设使用者真有这个需要，自己考虑重新再初始化一个…</div>2021-12-13</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132" width="30px"><span>Geek_as</span> 👍（0） 💬（1）<div>java的arraylist的扩容策论是增加原有容量的一半，即容量为10，扩容就为5，arraylist在做删除的时候我记得是调用了jdk提供的api将删除节点的后面往前面移动。假如让我来实现，我可能考虑的是这个数组是否需要保证插入顺序，假如不用的话，可能用数组最后的数来替换删除数</div>2021-12-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg" width="30px"><span>qinsi</span> 👍（0） 💬（3）<div>真实世界的算法，远不是时间复杂度这么简单。考虑到最大化利用已释放的内存，最优的扩容比率是1.618</div>2021-12-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg" width="30px"><span>拓山</span> 👍（0） 💬（0）<div>java的arrayList扩容逻辑是1.5倍</div>2023-08-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/37/a0/032d0828.jpg" width="30px"><span>上杉夏香</span> 👍（0） 💬（0）<div>我觉得这里是不是有点问题：『每次扩展 C 的容量』的公式，应该是：C+2C+3C+...+n，而不是加到n&#47;c？只不过项数是n&#47;c。综合起来等比数列前n&#47;c项和，总数还是n^2。得到平均扩充的时间复杂度是O(1)。</div>2022-08-17</li><br/>
</ul>