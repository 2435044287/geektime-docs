你好，我是微扰君。今天，我们一起来学习一种新的解决最短路问题的思路——Bellman-Ford算法，以及基于它发展出来的距离矢量算法。

动态路由问题相信你已经理解了，上两讲我们也一起学习了解决这个问题的一种经典选路算法——基于Dijkstra算法思想的链路状态算法，核心就是每个节点，通过通信收集全部的网络路由信息，再各自计算。

如果说链路状态算法的思想是全局的、中心化的，**我们今天要学习的距离矢量算法就是本地的、非中心化的，交换信息的数据量会比链路状态少很多**。因为在基于距离矢量算法下的选路协议下，节点之间只用交换到网络中每个其他节点的距离信息，不用关心具体链路，也就是我们所说的距离矢量，而不是泛洪地转发整个网络中每条边的信息。

具体是如何做到的呢？这背后计算最短路的核心思想就是Bellman-Ford算法。

## Bellman-Ford算法

我们就先来学习Bellman-Ford算法，它同样是一种反复执行“松弛”操作去计算源点S到网络中其他节点距离最短路径的算法，所以学过Dijkstra算法的思想，我们再理解BellmanFord算法是比较简单的。

不过，和Dijkstra用到的贪心思想不同，Bellman-Ford算法采用的是动态规划（dynamic programming）的思想。
<div><strong>精选留言（3）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/eb/19/0d990b03.jpg" width="30px"><span>ZeroIce</span> 👍（1） 💬（1）<div>第二个图，最短路径dijkstra是acbed?距离为1?</div>2022-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg" width="30px"><span>kimoti</span> 👍（2） 💬（0）<div>如果发现某个节点断网了,那么所有依赖于这个节点的路径都必须重新计算</div>2022-01-22</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（0） 💬（0）<div>距离矢量算法只存储距离信息没有拓扑信息，当节点断开之后，距离变得无限大，需要多次计算才能确认。解决方案应该是增加部分拓扑信息，来应对节点断开后的情况。我觉得可以增加路径的节点信息，文中的例子，B到D是通过C，增加C到成本一行。A到D的最短距离是通过B，可以增加B到成本这一行。这样一旦C到D断开了，距离变得无穷大，询问B的时候，B马上意识到C无妨访问到D，自己这条成本为2的路径也作废了，距离也变成了不穷大，然后询问A，A也意识到自己这条成本为3的路径也作废了，这样D断开的信息会在网络中迅速扩散。
</div>2022-01-22</li><br/>
</ul>