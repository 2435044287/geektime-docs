你好，我是微扰君。

在上一讲实现的一个简易银行账户管理系统中，每个账号都对应了一个余额，系统支持用户的开通、存/取款和查询余额。我们使用动态数组容器满足了频繁随机访问查询的需求。

但是如果要在系统里支持删除的功能，就会有一个问题：我们为了不进行整体的数组移动操作，通常就只能保留这个用户在数组里占用的内存，用将元素标记为特殊值的方式来模拟“删除”；而因为数组是连续存储的，不能单独释放掉数组中间某些区域的内存，所以这段内存空间我们实际上就是浪费的。

如果还有个需求，比如现在某个不讲道理的领导来到这个银行，要求自己在数组中排在最前面；那么我们不得不将所有人的账户信息往后挪动一位来满足他奇怪的自尊心，这也会带来高昂的时间复杂度。

那么有没有办法让我们不再需要连续的存储空间去存储一个序列，同时又可以在序列中快速进行插入/删除操作而不用波及之后的所有元素呢？

这就需要另一种常见的序列式数据结构——链表登场了，这同样是几乎所有高级语言都会原生支持的数据结构。

## 链表

链表这个数据结构的发明也是很久之前的事了，最早在1955年，它就是IPL这一古老语言的内置数据结构，用于开发当时的人工智能程序。

类似数组，链表同样是一种序列式的数据结构，但存储元素时并不需要使用连续的内存空间，而是采用一系列通过指针相连的节点来存储，**因为有了指针来关联节点的地址，就不需要连续存储了**。
<div><strong>精选留言（6）</strong></div><ul>
<li><img src="" width="30px"><span>Paul Shan</span> 👍（7） 💬（1）<div>链表放弃了数组规整连续的布局，只存储下一个或者上一个节点指针，带来了插入和删除的高效，也充分利用了内存的碎片，但是牺牲了全局查询的效率。
</div>2021-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg" width="30px"><span>webmin</span> 👍（2） 💬（3）<div>数组是一种特殊形式的链表，把链接任意跳转压缩为游标定位。</div>2021-12-14</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/j24oyxHcpB5AMR9pMO6fITqnOFVOncnk2T1vdu1rYLfq1cN6Sj7xVrBVbCvHXUad2MpfyBcE4neBguxmjIxyiaQ/132" width="30px"><span>vcjmhg</span> 👍（0） 💬（1）<div>最容易想到的方法就是从起点调用迭代器进行遍历，遍历过程中比较节点值与3是否相同，如果相同则返回该位置迭代器，否则继续向后遍历；时间复杂度为O(n)，如果链表本身有序，可考虑进行优化，比如用红黑树，时间复杂度可降低至O(logn)。</div>2021-12-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg" width="30px"><span>友</span> 👍（0） 💬（2）<div>是O(n)，但如果一个链表要保证有序 那么我可以在find之后保存一下上次find的指针位置 然后下次find决定往前或者往后 不过这是一个简单的思考 怎么折腾都是O(N)</div>2021-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg" width="30px"><span>那时刻</span> 👍（0） 💬（1）<div>begin() 则会指向虚拟节点的下一个节点，这完美符合迭代器前开后闭的语义。 这里貌似应该是前闭后开？</div>2021-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg" width="30px"><span>新世界</span> 👍（2） 💬（0）<div>第一处代码位置，前驱节点和后继节点注释写反了</div>2022-02-11</li><br/>
</ul>