你好，我是微扰君。

上一讲我们一起学习了布隆过滤器，它可以帮助我们用更低的存储成本、更高效地判断某个元素是否在一个集合中出现，当然代价是一定的误判率。总的来说，布隆过滤器特别适合用来解决Redis中缓存穿透的问题。

今天，我们同样来讨论一个在Redis中发挥巨大作用的数据结构：跳表。如果你有一定的Redis使用经验，常用的ZSET底层实现就是基于跳表的。

跳表这个数据结构，其实在之前介绍红黑树的时候我们简单提到过，和红黑树一样，它可以非常高效地维护有序键值对，插入、查询和删除的平均时间复杂度都是O(logN)，所以被Redis用来存储有序集合。但在时空复杂度差不多的情况下，跳表比红黑树实现起来要简洁优雅得多。

我个人认为，跳表几乎在每个方面都比红黑树更好，当然红黑树由于发明更早，得到了更广泛的应用，所以很多TreeMap之类的语言原生的数据结构还是常常采用红黑树。但是跳表作为一种非常高效的有序集合的实现，背后的原理很值得我们学习。

那跳表是如何设计、实现的呢，我们开始今天的学习之旅。

## 跳表为什么诞生

故事的开头，还是要从链表说起。

之前讲红黑树（点[这里](https://time.geekbang.org/column/article/471434)复习）我们也提到，如果要实现一个字典这样的数据结构，其实可以直接用一个线性数据结构，来存储所有的元素，至于每次插入元素前如何判断元素是否存在，也很简单，遍历一遍就可以了。
<div><strong>精选留言（3）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/2b/09/2171f9a3.jpg" width="30px"><span>小白哥哥</span> 👍（2） 💬（1）<div>跳表和红黑树比唯一的劣势可能就是整体内存占的多一些了</div>2022-03-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/f2/9e/eb0324db.jpg" width="30px"><span>音目</span> 👍（1） 💬（1）<div>深入浅出，非常易懂。大佬太棒了</div>2022-05-02</li><br/><li><img src="" width="30px"><span>Geek_8941b4</span> 👍（1） 💬（0）<div>使用 while 循环回溯，用 new Node(right, down, val) 新建每一层的节点。所以跳表的层数本质上是有多少层就有多少个相同的节点向上叠加。这个代码真的优雅</div>2022-07-14</li><br/>
</ul>