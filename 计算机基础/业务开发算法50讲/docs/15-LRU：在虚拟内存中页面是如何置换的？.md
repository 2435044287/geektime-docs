你好，我是微扰君。

今天我们继续讲解操作系统中另一个常用的算法， LRU算法（Least recently used），也就是最近最少使用页面置换算法。这是操作系统中常用的内存置换策略之一，在内存有限的情况下，需要有一种策略帮助我们把此刻要用到的外存中的数据置换到内存里。该算法也同样适用于许多类似的缓存淘汰场景，比如数据库缓存页置换、Redis缓存置换等。

在开始讲解LRU算法本身之前，我们先来了解一下这个算法在操作系统中到底解决了什么问题。

## 操作系统的缓存淘汰

我们知道，计算机是建立在物理世界上的，底层的存储计算需要依赖许多复杂的硬件：比如内存、磁盘、纷繁的逻辑电路等。所以**操作系统的一大作用就是，通过虚拟和抽象为应用开发者提供了一套操作硬件的统一接口**，而分页机制的发明，就是为了不需要让用户过度操心物理内存的管理和容量。

通过虚拟内存和分页机制，用户可以在一个大而连续的逻辑地址和非连续的物理地址之间，建立起映射。其中，物理地址既可以真的指向物理内存，也可以指向硬盘或者其他可以被寻址的外部存储介质。

用户的程序可以使用比物理内存容量大得多的连续地址空间；而计算机在运行程序的时候，也不再需要把进程所有信息都加载到内存里，只加载几个当前需要的页就可以了。
<div><strong>精选留言（4）</strong></div><ul>
<li><img src="" width="30px"><span>Paul Shan</span> 👍（3） 💬（1）<div>LRU需要把中间的节点移动到头部，并且要删除尾部节点，单链表对这两个操作都需要O(n),双链表可以用O(1)完成。LRU组合了哈希表和双向链表各自的强项，因而提供了快速的查询和灵活的资源管理两项功能。</div>2022-01-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/ab/5b/eb3983f0.jpg" width="30px"><span>liuchao90h</span> 👍（1） 💬（1）<div>其实严格来讲，因为用到了双向链表，所以最差时间复杂度应该是O(n)才对吧？虽然示例代码用了语言自带的包装，但不能忽视本身内部的损耗吧？再有就是作者无无语界确实博才，但对读者却走着更高的理解要求，虽然能猜出各语言大概含义，但阅读起来还是吃力些</div>2022-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg" width="30px"><span>拓山</span> 👍（0） 💬（0）<div>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

   1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</div>2023-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg" width="30px"><span>西门吹牛</span> 👍（0） 💬（0）<div>双向链表，插入删除更灵活，单向链表需要在遍历的过程中记录当前节点的前驱节点，然后前驱节点指直接next后继节点执行删除，双向链表直接找到删除的节点 node，直接 node.pre.next = node.next，node.next.pre = node.pre</div>2022-01-22</li><br/>
</ul>