我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。

其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，**复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半**。

复杂度分析实在太重要了，因此我准备用两节内容来讲。希望你学完这个内容之后，无论在任何场景下，面对任何代码的复杂度分析，你都能做到“庖丁解牛”般游刃有余。

## 为什么需要复杂度分析？

你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？

首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫**事后统计法**。但是，这种统计方法有非常大的局限性。

**1. 测试结果非常依赖测试环境**

测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用Intel Core i9处理器和Intel Core i3处理器来运行，不用说，i9处理器要比i3处理器执行的速度快很多。还有，比如原本在这台机器上a代码执行的速度比b代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/78/f5/915d5442.jpg" width="30px"><span>xr</span> 👍（2372） 💬（43）<div>我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。

当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。

综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" width="30px"><span>姜威</span> 👍（1364） 💬（39）<div>总结
一、什么是复杂度分析？
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
二、为什么要进行复杂度分析？
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
三、如何进行复杂度分析？
1.大O表示法
1）来源
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
2）特点
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
2.复杂度分析法则
1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
四、常用的复杂度级别？
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)（指数阶）、O(n!)（阶乘阶）
五、如何掌握好复杂度分析方法？
复杂度分析关键在于多练，所谓孰能生巧。</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0d/1e/7f2d5872.jpg" width="30px"><span>吕宁</span> 👍（392） 💬（28）<div>老师好，我们上算法课，老师讲到存储一个二进制数，输入规模（空间复杂度）是O(logn) bit。请问如何理解？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ea/0f/9a7004e5.jpg" width="30px"><span>realEago</span> 👍（173） 💬（9）<div>看不懂别慌，也别忙着总结，先读五遍文章先，无他，唯手熟尔~</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/02/5b/ce326cfc.jpg" width="30px"><span>二三子也</span> 👍（105） 💬（1）<div>老师，代码片段把行号也写上吧。</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c8/d3/16b45d58.jpg" width="30px"><span>起名好难</span> 👍（87） 💬（3）<div>文章里也说了，性能测试这种是受环境所影响的。作为程序员，我们能做的就是尽可能的降低复杂度，才能让代码在不同的环境下以最快的效率执行。至于是不是浪费时间，我觉得其实是个伪命题。首先按刚刚分析过程来看，通过熟悉练习，简单的代码是可以直接看出来复杂度的也就是不费时间；而比较复杂的代码就容易“一不小心”太“复杂”了，这个时候，为了代码质量考虑分析复杂度的时间也并不浪费。再有甚者，我们学习这个分析法，我觉得更多的是要明白这个理念，在写代码的时候就能关注一下这方面的问题，毕竟复杂的代码在写的过程往往是先分析整体逻辑结构的，并且写的过程也需要不断思考，了解这个理念后才能在写的过程中也思考关注这个点。不然，复杂的一段代码一旦写成，日后因为性能问题重构，更费时间。

以上是对课后题的思考，欢迎批评指正☺。
另: 感觉加法法则那个图，maxf(n)+g(n) 换成max(f(n)+g(n))会不会更好些？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/dc/29/33d0d7ff.jpg" width="30px"><span>scarlett</span> 👍（84） 💬（12）<div>回答 thinkings 的问题
i=1; 
while (i &lt;= n) {
i = i * 2
}
假设n= 20，i每次的取值是2  4  8  16 执行4次，时间复杂度是O(log2n)
i=1; 
while (i &lt;= n) {
i = i + 2
}
假设 n=20 i每次取值：3，5，7，9，11，13，15，17，19 ，执行9次，时间复杂度是O(n&#47;2),根据老师讲的 公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略，所以是O（n）</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/12/19/32bd8b9a.jpg" width="30px"><span>有一天</span> 👍（67） 💬（16）<div>一直有一个很纠结的问题，烦请解答一下：O具体是哪一个英文字母的缩写？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/78/f7/766f23c7.jpg" width="30px"><span>Geek_242743</span> 👍（52） 💬（7）<div>没有看懂，所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。   这里的x不就是代码里的n吗，时间复杂度不是O(n)吗？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f4/0a/02ecee7a.jpg" width="30px"><span>女干部</span> 👍（47） 💬（8）<div>第二个例子中，第6.7行为什么是2n平方遍而不是n平方遍呢？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" width="30px"><span>Monday</span> 👍（42） 💬（5）<div>本节通读两遍，通俗易懂，对复杂度的概念有了新的认识。
复杂度就是用来分析算法执行效率与数据规模之间增长关系。
思考题，性能测试与复杂度分析不冲突，原因如下：
1、性能测试是依附于具体的环境，如SIT、UAT机器配置及实例数量不一致结果也有差别。
2、复杂度分析是独立于环境的，可以大致估算出程序所执行的效率。
3、将复杂度熟记于心，能够写出更高效率、更好性能的代码。若某接口通过性能测试，达不到预期，还可以用复杂度分析接口代码，找出最影响性能的代码，进行优化。

每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？
这个问题分两种情况讨论
1、开发过程中，码代码的过程中就能得出其复杂度，这并不会太多的浪费时间，同时只有分析了每段代码的复杂度，才能估算出它们的执行效率。
2、优化代码时，只有在分析每段代码的复杂度后，才能定位问题代码，才能做相应优化

另外提出两个问题：
1、评论太多，也无法进行关键字搜索，一般没有时间爬楼全部看完，导致不同学友提出一样的问题
2、评论太多，可能有些评论不正确，需要官方确认正确与否，以免误导学友。


</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/db/a7/eab461f0.jpg" width="30px"><span>huangjh</span> 👍（33） 💬（1）<div>有必要，性能测试更多的是一种实验结果。而复杂度分析，可以帮助我们分析内因。</div>2018-09-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f0/41/f6153c7a.jpg" width="30px"><span>Dwyane</span> 👍（25） 💬（1）<div>03 
大家好，这是我的总结：

公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略
1. 只关注循环执行次数最多的一段代码
2.加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们集作O(1)
不同数据规模，无法评估 m 和 n 的量级大，所以不能利用加法法则，去掉某一个，而是 O(m+n)

空间复杂度：表示算法的存储空间与数据规模之间的增加关系

额外说一下：log3n 就等于 log32 * log2n 其实是利用换底公示推导，有疑问的搜一下。</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg" width="30px"><span>南山</span> 👍（24） 💬（1）<div>       有必要，基准测试是事后，也是理论验证，有时候O(n)未必一定比O(1)效率低。
       复杂度分析是理论，整体趋势上反应了一个算法的时间或者空间利用率与数据规模的渐进关系，并且像程序员之间使用设计模式来讨论代码设计一样，说出名字就大致知道代码是如何组织的，大O也是一样。
        随着自己使用大O分析代码复杂度的熟练程度增加，判断一段代码的复杂度可能分分钟的事情，甚至更快。
</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ed/6c/dac226ff.jpg" width="30px"><span>ChaoYrAx</span> 👍（23） 💬（1）<div>老师  空间复杂度 和时间复杂度的 具体区别是什么，我怎么看上去像一样的</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/71/45/abb7bfe3.jpg" width="30px"><span>Andy</span> 👍（23） 💬（2）<div>分析复杂度，倒是可以掌握一个分析算法大致流程，不至于无从下手，或者学完就忘。从软件开发角度来讲，提供了吐槽别人代码性能差的有效量化工具</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/eb/b1/d5ceb9c7.jpg" width="30px"><span>陆上行舟</span> 👍（16） 💬（1）<div>说一下个人的一点理解:

事后统计法: 定量分析

1. 需要具体的执行代码，需要具体的软硬件运行环境；
2. 需要具体的测试数据，数据规模大小会影响测试结果；

3. 得到的是这一次在具体的运行环境，具体的测试数据运行所需的时间，得到的是一个具体的时间。(点)


时间复杂度分析: 定性分析

1. 不需要具体执行代码，与运行环境无关；
2. 不需要具体测试数据；
3. 得到的不是程序具体运行时间，而是反映时间随数据规模增加变化的趋势。(线)

从评估结果来看，事后统计法得到的是一个具体的点，而时间复杂度分析得到的是一条线。

两种评估方法是相辅相成的，不是冲突的。

假如，假如说解决某一个具体的问题有两种算法 A 和 B，相应的代码是【代码A】和【代码B】，假如我们对两种算法代码进行时间复杂度分析得到结果:

代码A: O(8n+100)，那就可以说代码A的时间复杂度为 O(n) 

代码B: O(n2+n+5)，那么可以说代码B的时间复杂度为 O(n2)


从时间复杂度角度分析，我们可以定性的得出结论说算法 A 优于算法 B。

但是如果使用事后统计法，假设在同样的运行环境，执行两段代码，由于需要具体的测试数据，相当于知道了具体 n 的值，假如是 n 的值是2，则算法A粗略估算需要 116 个单位时间，算法B需要 11 个单位时间(当然单位时间可能都是不同的)。

我们很有可能得出这一次测试结果是算法B所用时间是少于算法A，只是这一次，只是得出了一个定量的结果。

所以事后统计法有时候我们并不能知道算法 A 和 算法 B 那个性能更优，而通过时间复杂度分析我们可以得出定性结论算法A优于算法B。(当随着数据规模增大的时候算法A运行增加的时间要比算法B少的多。)

如果数据规模是确定的那使用算法A和算法B，随便那个选择熟悉的就行，如果数据规模不确定那在写程序的时候就需要尽可能的考虑时间复杂度选择更优的算法来解决。






</div>2018-09-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d6/59/cb4e7ed8.jpg" width="30px"><span>小帅b</span> 👍（14） 💬（1）<div>--------总结一下--------

事后统计的局限性：

1.不同的环境测试结果差异大
2.数据本身规模会影响结果（如数据规模小，结果无法真实反应出算法的性能问题）

所以：需要复杂度分析


时间复杂度：

表示法：T(n) = O(n)； T(n) = O(n2)。  
T(n) 代表代码执行时间
(n)代表每行代码的执行次数总和

也就是每行代码的执行次数总和越大，那么代码执行就需要更多的时间。


时间复杂度分析方法：
1.只关注执行次数最多的那段代码。
2.加法法则：总复杂度取量级最大的那段代码。
3.乘法法则：代码之间复杂度有嵌套情况，将各个复杂度相乘得到总复杂度。

复杂度常见案例：

非多项式量级：
O（2^n）
O(n!)
n越大，算法执行时间急剧增加，相对低效

多项式量级：
O(1) : 不存在n的影响因素
O（logn）、O（nlogn）：对阶时间复杂度，最难分析之一。
O（m+n）、O（m*n） ：当数据规模无法评估哪个较大时，加法法则失效，可以使用 O（m+n）的方式。

空间复杂度分析
类比于时间复杂度就是：存储空间与数据规模的增长关系。


-----------课后思考--------------

不认为是浪费时间，性能的基准测试可能会受到环境，数据规模本身的影响，对时间复杂度、空间复杂度进行分析至少对一些复杂度能够做出判断，写出相对效率高的代码，此外，还能提升自己分析复杂度的思维和效率的认知。</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d9/44/180944ee.jpg" width="30px"><span>Shira</span> 👍（11） 💬（1）<div>【所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比】
这句高亮的话不对吧。根据后文的意思，似乎应该是：T(n) 与每行代码的执行时间 unit_time 成正比。
两个例子的时间复杂度分别是： T(n) = (2n+2)* unit_time;  T(n) = (2n^2+2n+3)*unit_time
我是数学系学渣初学数据结构与算法，感觉如果T(n)与n成正比，岂不是一定有形如 T(n)=a*n, a为某常量，这种关系了。
                   </div>2018-09-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/6a/72/a9f595a7.jpg" width="30px"><span>广州小拳拳</span> 👍（9） 💬（1）<div>O(m+n^2) 是否可以简化为 O(n^2) ？</div>2018-10-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/06/69/b362d00b.jpg" width="30px"><span>karenaaa</span> 👍（8） 💬（1）<div>最后一个图，O(nlogn)的变化曲线，n小于1时，对应的T(n)应该是小于0的</div>2018-09-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d7/22/a05987e7.jpg" width="30px"><span>jackeymm</span> 👍（7） 💬（1）<div>先进行性能测试，可以帮助我们找到瓶颈点，也就是时间复杂度最高的点，按照时间复杂度渐进的过程，复杂度最高的点，几乎可以等同于整个程序的复杂度，所以性能测试可以帮助我们减少分析类似o(1)这类复杂度低的程序的时间;
如果是作为练习，分析每段代码的复杂度，并不算浪费时间，如果是为了优化程序，我们就应该找到复杂度最高的部分进行分析，然后优化，但是这有一个前提是你能一眼分辨出绝大多数复杂度地的程序</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d9/eb/223c6c80.jpg" width="30px"><span>秋凯</span> 👍（5） 💬（1）<div>看了下上面的总结，我想补充一下

学习复杂度的主要目的就一个：方便后续定性比较算法性能，比如归并是nlogn，插入是n²，所以归并快，而且快不少。

下一期是不是讲最坏情况和最好情况？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8f/c9/833d5060.jpg" width="30px"><span>玉皇大亮</span> 👍（5） 💬（1）<div>老师提出的问题，文章中已经回答了，通过打印代码执行时间进行性能测试统计属于事后统计方法，这种方法很直观，但是有局限性。1.测试结果依赖于测试环境，不同的机器由于配置不同可能会有不同的测试结果。2.测试的结果受数据规模的影响，同样一套算法，n和n^3数量级规模的直观结果肯定是不一样的，但是当数据的规模小时，算法的效率又不容易得到提现。通过提前分析代码的时间复杂度和空间复杂度，不仅做到对自己的代码心中有数，而且如果出了性能瓶颈，也比较好想到解决问题的方向。但是我觉得不是每部分代码都需要分析时间和空间复杂度的，只有核心算法部分需要重点关注，像一些业务调用接口，只需要注意下就可以了</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/df/2c/d2e97b6a.jpg" width="30px"><span>Jock</span> 👍（4） 💬（1）<div>学习落后了好几天了。发现光听根本跟不上，果断选择了看文档。看的时候卡在了对数换底公式，花了20分钟Google换底公式的推导证明，然后自己才能推导出来文中那部分。
总之:复杂度分析根本是为了从理论上找到更优选择，提高代码运行速度，节约存储空间，写出更加简洁高效的代码！能够在写代码时，时刻牢记效率问题！作为一个编程小白，感觉概率在代码的执行效率上有时也有很大影响！比如学习成绩的正太分布规律。</div>2018-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f4/38/4439bea9.jpg" width="30px"><span>A_foreign 이호연 wuli 혜리</span> 👍（4） 💬（3）<div>老师 我不太明白为什么++i在这里而不是i++
您的书写习惯还是？
</div>2018-09-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ed/47/f8aba277.jpg" width="30px"><span>Hubery_Jun</span> 👍（4） 💬（1）<div>这是Java？</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ec/0d/43d46889.jpg" width="30px"><span>alic</span> 👍（4） 💬（1）<div>难道没有O(n*3)这种复杂度吗</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/9c/8c14d4bd.jpg" width="30px"><span>by</span> 👍（4） 💬（1）<div>实际工作中有种情况就是集合里面装对象，这个对象里面有一个字段是集合，我要拿这个对象里的集合里的值判断做处理，那不用2层for，怎么做，明知道时间复杂度是n的2次方，这不是很纠结了</div>2018-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e9/b2/7ab31105.jpg" width="30px"><span>单行线的旋律</span> 👍（3） 💬（1）<div>我也立个Flag
1.弄明白:是什么？为什么？怎么做？  
               优点？ 缺点？ 有没有更好？
2.练习，实践，总结
3.坚持，坚持，再坚持!</div>2018-09-26</li><br/>
</ul>