微服务是最近几年才兴起的概念。简单点讲，就是把复杂的大应用，解耦拆分成几个小的应用。这样做的好处有很多。比如，这样有利于团队组织架构的拆分，毕竟团队越大协作的难度越大；再比如，每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响。不用像原来那样，一个小功能上线，整个大应用都要重新发布。

不过，有利就有弊。大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、debug问题的难度都高了好几个数量级。所以，为了解决这些问题，服务治理便成了微服务的一个技术重点。

所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。今天，我就拿其中的鉴权和限流这两个功能，来带你看看，它们的实现过程中都要用到哪些数据结构和算法。

## 鉴权背景介绍

以防你之前可能对微服务没有太多了解，所以我对鉴权的背景做了简化。

假设我们有一个微服务叫用户服务（User Service）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，也并不是每个有访问权限的应用，都可以访问用户服务的所有接口。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="" width="30px"><span>suke</span> 👍（57） 💬（15）<div>老师能对限流相关的算法和数据结构多讲一讲么</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" width="30px"><span>Monday</span> 👍（13） 💬（1）<div>鉴权的精确匹配用散列表的时间复杂度是O(1)，比顺序匹配O(n)和二分查找的效率都高啊。为什么不选用呢？</div>2019-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg" width="30px"><span>青铜5 周群力</span> 👍（11） 💬（1）<div>请教老师一个问题哈，为啥鉴权算法里，每个应用的规则要放到有序数组呢，放hash set会更好吧?
比如一个应用有两个规则:&#47;user&#47;a和&#47;user&#47;b，把这俩规则放hash set岂不是时间复杂度更低、更好呢</div>2019-02-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg" width="30px"><span>懒猫</span> 👍（6） 💬（1）<div>请教老师，鉴权那一部分如何用有序数组做二分查找呢，数组里存放的都是uri中的单词吗？在数组中怎么排序？字典序？这里的二分比较时怎么比较大小呢</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg" width="30px"><span>金龟</span> 👍（6） 💬（2）<div>老师，文章里你说了这一句话&#39;只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。&#39;这里更加细粒度代表什么意思，我觉得已经解决了，最初时间窗口的问题呀。比如如果我限流5qps，那循环队列（元素内存时间）只留tail指针，只是要增加每次tail前进之前用当前时间和后一个元素时间进行一个差指，大于1秒前进，小于一秒拒绝请求。</div>2019-02-01</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132" width="30px"><span>wjh_all_in</span> 👍（3） 💬（1）<div>请问一下，滑动窗口限流策略，清除过期数据的时机是新请求到达，这个是基于单位ms内不会有很大的并发的考虑吗？如果像淘宝这样的大流量电商，是不是需要更低精度的时间，不然清除数据的耗时，可能会使接口性能变差</div>2019-05-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg" width="30px"><span>Tattoo</span> 👍（1） 💬（1）<div>“不同的应用对应不同的规则集合。我们可以采用散列表来存储这种对。。。”，这里如果匹配规则很多的话，不会发生很多的冲突的吗？

</div>2019-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/45/62/abb7bfe3.jpg" width="30px"><span>xyf</span> 👍（1） 💬（1）<div>想问下如何对接口做数据域权限检验。比如调用方有权限调用查询项目接口，但是对于请求参数，如项目ID，鉴权系统能够判断调用者是否有权限访问这个项目。</div>2019-04-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg" width="30px"><span>Joker</span> 👍（1） 💬（1）<div>期待老师的题目，最近也在刷LeetCode，结合的效果肯定好！！！</div>2019-02-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg" width="30px"><span>Flash</span> 👍（45） 💬（6）<div>思考题1：可以用优先级队列（根据请求时间构建小顶堆），最早的请求时间的放在堆顶。然后每次进来一个请求，就判断这个时间跟堆顶的时间差是否小于1S，并且堆的大小小于请求限制的次数，如果是就插入队列，如果不是，就限制。</div>2019-04-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/51/f0/d1142758.jpg" width="30px"><span>Billylin</span> 👍（39） 💬（1）<div>春节还想着加福利，这是一种什么精神。</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/791d0f5e.jpg" width="30px"><span>忍者无敌1995</span> 👍（28） 💬（2）<div>1. 还可以采用双向链表，每次请求往链表尾插入一个时间，插入之前先从链表头删除一秒之前的节点，之后看下链表的size是否大于等于N，大于等于N则拒绝本次访问，否则允许本次访问并插入链表尾；占用的空间比循环链表要大
2. 假设有n个规则，每个规则的单词个数平均为m，则时间复杂度为O(m*logn), 空间复杂度O(n*m)
时间复杂度分析下：平均搜索m层，每一层最多有n个单词，由于是采用有序数组存储，查找时间复杂度为O(logn),所以总的时间复杂度为O(m*logn)
</div>2019-04-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/87/57/e28ba87b.jpg" width="30px"><span>Williamzhang</span> 👍（26） 💬（1）<div>感觉限流的思想中可以参考一下tcp的拥塞控制算法</div>2019-02-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e7/e0/33521e13.jpg" width="30px"><span>DigDeeply</span> 👍（12） 💬（0）<div>思考题1
还可以使用一个固定大小的小顶堆，以时间戳作为排序依据。
每次有请求时相当于要在小顶堆内插入数据，如果堆顶数据的时间跟本次时间差距小于1s，且堆已满的情况下，不允许继续插入。每次插入数据的时候，删除1s外的数据，重新排序，确定新的堆顶。
不过感觉跟循环队列比，都是劣势；插入数据，删除数据，时间复杂度都要更高。而且每次删除数据后还要重新排序一遍确定新的堆顶。</div>2019-03-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c8/58/35b4090d.jpg" width="30px"><span>Ray</span> 👍（10） 💬（0）<div>读您的文章就是一种享受!!!</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c7/53/a8b9ac81.jpg" width="30px"><span>何欢</span> 👍（3） 💬（0）<div>给老师点个赞，敬业精神值得学习，春节期间也是给自己充电的好时期，加油。</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg" width="30px"><span>注定非凡</span> 👍（2） 💬（0）<div>所谓服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法鉴权背景介绍

要实现接口鉴权功能，需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，就可以拿应用的请求 URL，在规则中进行匹配。根据匹配成功与否，判断是否响应访问。

如何实现快速鉴权？该用什么数据结构来存储规则？用户请求 URL 在规则中快速匹配，又该用什么样的算法呢？

1. 如何实现精确匹配规则？
只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理

	* 不同的应用对应不同的规则集合。可以采用散列表来存储这种对应关系

		* 可以将每个应用对应的权限规则，存储在一个字符串数组中。拿用户的请求 URL，在这个数组中逐一匹配
		* 规则不会经常变动，所以按照字符串的大小给规则排序加快匹配速度，把它组织成有序数组这种数据结构。当要查找某个 URL 能否匹配时，采用二分查找算法，在有序数组中进行匹配。

2. 如何实现前缀匹配规则？
只要某条规则可以匹配请求 URL 的前缀，就认为这条规则能够跟这个请求 URL 匹配

	* 不同的应用对应不同的规则集合。采用散列表来存储这种对应关系

		* Trie 树非常适合用来做前缀匹配。所以将每个用户的规则集合组织成 Trie 树
		* Trie 树中的每个节点存储接口被“&#47;”分割之后的子目录
		* 因为规则并不会经常变动，所以把每个节点的子节点们，组织成有序数组，利用二分查找算法匹配，决定从一个节点应该跳到哪一个子节点


3. 如何实现模糊匹配规则？
如果规则中包含通配符，只要用户请求 URL 可以跟某条规则模糊匹配，就判定这条规则适用于这个请求

不同的应用对应不同的规则集合。还是采用散列表来存储这种对应关系
	* 采用回溯算法，拿请求 URL 跟每条规则逐一进行模糊匹配，但在回溯算法复杂度较高
	* 实际上并不是每条规则都包含通配符，包含通配符的只是少数，可以把不包含通配符的规则和包含通配符的规则分开处理

		* 把不包含通配符的规则，组织成有序数组或者 Trie 树，这一部分匹配就会非常高效
		* 少数包含通配符的规则，只要把它们简单存储在一个数组中。但是这种规则比较少，所以匹配起来会比较慢也是可以接受的

	* 当接收到一个请求，可以先在不包含通配符的有序数组或者 Trie 树中查找。

限流背景介绍
	* 所谓限流，就是对接口调用的频率进行限制，限流已成为保证系统平稳运行的一种标配的技术解决方案
	* 按照不同的限流粒度，限流可以分为很多种类型。如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。

如何实现精准限流？
最简单的限流算法：固定时间窗口限流算法
	* 首先选定一个时间起点，之后每当有接口请求到来，就将计数器加一
	* 如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，就拒绝后续的访问请求。
	* 当进入下一个时间窗口之后，计数器就清零重新计数。
	* 缺点：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量

滑动时间窗口限流算法可以限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）
假设限流的规则是在任意 1s 内，接口的请求次数都不能大于 K 次
	* 维护一个大小为 K+1 的循环队列记录 1s 内到来的请求。因为循环队列存储数据时会浪费一个存储单元，循环队列的大小等于限流次数加一
	* 当有新的请求到来时，将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。
	* 然后检查循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；如果没有就拒绝服务
	* 即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题
	* 基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。
</div>2020-02-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/de/6a/4db4a75e.jpg" width="30px"><span>水果刀</span> 👍（2） 💬（0）<div>立个flag，正月初一到正月初七每天都做老师的题……</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9c/aa/6f780187.jpg" width="30px"><span>言希</span> 👍（2） 💬（0）<div>老师用心了</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d0/88/d9a55425.jpg" width="30px"><span>向羽</span> 👍（2） 💬（0）<div>太棒了，给老师点赞👍</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg" width="30px"><span>失火的夏天</span> 👍（2） 💬（1）<div>思考题1用链表应该也可以吧(是否循环感觉都无所谓，只要有头尾指针就行了)，不过感觉是换汤不换药，核心思想和队列基本一模一样。</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg" width="30px"><span>南山</span> 👍（2） 💬（0）<div>给老师点赞</div>2019-02-01</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOc0n02eNKflX5ey4TYl1NBfb0kicc20AgayEAGDYylalqHnLTeqMnaJ2iaZsLVmqEo0T0YViadU9Ig/132" width="30px"><span>lianlian</span> 👍（2） 💬（0）<div>哇，老师优秀又热心(✪▽✪)，期待老师的题目(๑˙ー˙๑)</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg" width="30px"><span>简单猫</span> 👍（1） 💬（0）<div>问题1 
链表 size小于k 直接add到链表尾部
链表已经满了 就判第一个节点 和 当前数据的时间是否超过1秒 超过就删除 头节点指向下一个节点
如果小于1 直接丢弃请求

问题2 trie树 
节点为路径 时间复杂度o(n)


&lt;令牌桶&gt; 其实就和连接池类似
只不过这里的连接池 的连接只能使用一次
然后比如1秒1处理100个连接
我每10毫秒生成一个放到连接池里
就能平滑的限流 
缺点应该是看运气 先来的也不一定拿到令牌

&lt;漏桶法&gt;
类似桶 只要桶里有空间 就一直放进去
另外一边桶底出水 按服务器处理速度来放水 只要漏桶没满 就可以一直注入水

感觉这个和我想的第一种解决方法类似</div>2022-02-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg" width="30px"><span>thinker</span> 👍（1） 💬（0）<div>漏桶限制的是速率，限制速度
令牌桶限制的时间段内的数量，限制总量</div>2020-03-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg" width="30px"><span>失火的夏天</span> 👍（1） 💬（0）<div>重新来留个言，循环队列也可以用跳表或者红黑树来实现，跳表有前后指针，以long类型的时间作为索引，找到比当前k少一秒的元素（索引查找或者直接便利都可以），然后之前的元素也能删掉了。是否加入跳表就看size是否达到了k，有就加入，没有就拒绝。

红黑树同样以long类型的时间作为索引key，找到比新元素少一秒的key，红黑树天生就有一个可以找到floorkey(也就是小于等于查找元素的key)，然后依次找到其前驱节点，依次删除。查找前驱节点会比跳表的直接遍历要慢一点。

不过红黑树和跳表天生的有序性，也是实现这样一个限流容器的思路。</div>2020-01-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg" width="30px"><span>Knight²º¹⁸</span> 👍（1） 💬（3）<div>前些去面试，其中架构篇就让我实现一个企业级的分布式限流框架。</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg" width="30px"><span>halo</span> 👍（1） 💬（0）<div>一直跟着走，回头再看几遍，真心赞</div>2019-02-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/09/49/8bc5e315.jpg" width="30px"><span>牧民牛仔</span> 👍（1） 💬（0）<div>春节加餐，每天一份习题大礼包</div>2019-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/0f/8c/7784cd81.jpg" width="30px"><span>Geek_2jpclt</span> 👍（0） 💬（0）<div>阻塞队列</div>2022-11-19</li><br/>
</ul>