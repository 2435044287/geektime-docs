基础篇的时候，我们学习了图的两种搜索算法，深度优先搜索和广度优先搜索。这两种算法主要是针对无权图的搜索算法。针对有权图，也就是图中的每条边都有一个权重，我们该如何计算两点之间的最短路径（经过的边的权重和最小）呢？今天，我就从地图软件的路线规划问题讲起，带你看看常用的**最短路径算法**（Shortest Path Algorithm）。

像Google地图、百度地图、高德地图这样的地图软件，我想你应该经常使用吧？如果想从家开车到公司，你只需要输入起始、结束地址，地图就会给你规划一条最优出行路线。这里的最优，有很多种定义，比如最短路线、最少用时路线、最少红绿灯路线等等。**作为一名软件开发工程师，你是否思考过，地图软件的最优路线是如何计算出来的吗？底层依赖了什么算法呢？**

## 算法解析

我们刚提到的最优问题包含三个：最短路线、最少用时和最少红绿灯。我们先解决最简单的，最短路线。

解决软件开发中的实际问题，最重要的一点就是**建模**，也就是将复杂的场景抽象成具体的数据结构。针对这个问题，我们该如何抽象成数据结构呢？

我们之前也提到过，图这种数据结构的表达能力很强，显然，把地图抽象成图最合适不过了。我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" width="30px"><span>Liam</span> 👍（29） 💬（8）<div>有2个疑问：

1 Dijkstra就是贪心算法吧？
2 它的解可能不是最优解</div>2019-01-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/83/ef/2453b1e9.jpg" width="30px"><span>Geek_vi4asb</span> 👍（9） 💬（1）<div>王老师，我输入代码运行后，实际出队列的顺序跟图中的不一样，实际（15，0）出队列 在（13，3）出队列前面。我看了代码，应该是修改（25，1）为 （13，3）的时候，小顶堆不会自动更新顺序。需要对22行进行如下修改，更新已经在队列中，又改了dist的Vertex的优先级：
                   if (inQueue[nextVertex.id] == false){
                        queue.add(nextVertex);
                        inQueue[nextVertex.id] = true;
                    }
                    else { &#47;&#47; 更新已经在队列中，又改了dist的Vertex的优先级
                        queue.remove(nextVertex);
                        queue.add(nextVertex);
                    }</div>2019-01-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ed/4b/0ddfa9ad.jpg" width="30px"><span>小刚z</span> 👍（2） 💬（1）<div>a0b0c0扩展后可以得到之后会得到三个组合,a1b0c0,a0b1c0,a0,b0,c1，请问一下这三个组合是怎么推导出来的</div>2019-05-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/a2/c30ac459.jpg" width="30px"><span>hughieyu</span> 👍（2） 💬（1）<div>更新vertex后是否要更新一下对象在优先级队列中的位置，否则会预期更晚弹出优先级队列，会影响查找的速度，除此之外还没有可能出现其他的问题</div>2019-01-07</li><br/><li><img src="" width="30px"><span>Geek_dddebb</span> 👍（1） 💬（2）<div>亲测更新vertex后对象在队列中的位置不变</div>2019-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg" width="30px"><span>魏全运</span> 👍（1） 💬（1）<div>vertex compareTo有问题吧，怎么没有相等的分支呀？</div>2019-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg" width="30px"><span>张三</span> 👍（0） 💬（4）<div>在图的搜索算法那一节只是提到一句广度优先搜索算法的结果是最短路径，并没有说原因😂</div>2019-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fc/e2/3d2c57aa.jpg" width="30px"><span>i 星星</span> 👍（0） 💬（2）<div>老师，如果这个要是取权重最大该怎么设计呢？</div>2019-08-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/3e/46/0b888d5a.jpg" width="30px"><span>mike</span> 👍（0） 💬（1）<div>如果构造的图中有环，是否存在inqueue标记已入队的顶点需要update dist时，其实该顶点已经被弹出过队列了？此时不就没法重新update了吗，而只能重新入队？</div>2019-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/c7/79/657c05e7.jpg" width="30px"><span>jm3640</span> 👍（0） 💬（1）<div>独立事件概率想不明白.假如样本总数是2，一个同时包含A和B 另一个不包含A和B 那直接算样本同时包含A和B的概率是1&#47;2。独立概率相乘就是1&#47;2 * 1&#47;2 = 1&#47;4。请问我哪里理解错了</div>2019-07-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e6/50/656a0012.jpg" width="30px"><span>王楚然</span> 👍（0） 💬（1）<div>总感觉最短路径好像很符合动态规划的问题模型呢？跟djkstra算法有什么联系吗？</div>2019-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg" width="30px"><span>djfhchdh</span> 👍（0） 💬（2）<div>“inqueue 数组是为了避免将一个顶点多次添加到优先级队列”，如果将一个顶点多次添加到优先级队列中，对最后的结果也应该没有吧？</div>2019-05-30</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJqrJ5oUKagOjUG2JsfuX8lSI9pEOgMrXNa06xppsIO7aFNgic8ia7ET5I7GXSIqCW5R0sXLOzFYRYg/132" width="30px"><span>Geek_xk61fo</span> 👍（0） 💬（1）<div>学习算法有什么技巧吗？</div>2019-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f8/00/3ab82a1d.jpg" width="30px"><span>waycon</span> 👍（0） 💬（2）<div>老师，请问优先级队列中的代码第6行为什么nodes数组大小要v+1个</div>2019-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/64/14/c696ff63.jpg" width="30px"><span>李建轰</span> 👍（0） 💬（2）<div> 老师～请教一下，用小顶堆是因为贪心吗？
</div>2019-01-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg" width="30px"><span>Alexis何春光</span> 👍（0） 💬（1）<div>Dijkstra算一种动态规划算法吗</div>2019-01-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e9/52/f07e9001.jpg" width="30px"><span>想当上帝的司机</span> 👍（0） 💬（1）<div>if (inqueue[nextVertex.id]==false)&#47;&#47;加了这个判断的话，就不会走2了，因为在走1的时候2已经进入inqueue了，我在本地试的是去掉这个条件结果是对的，不知道是不是语言的原因，我是用gonlang写的，优先级队列是网上找的一个插件，老师你本地跑是成功的吗</div>2019-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8c/54/deb19880.jpg" width="30px"><span>slvher</span> 👍（0） 💬（1）<div>机器翻译的例子，用于解码的启发式剪枝是 beam search 算法吧？在 NLP 领域序列解码场合有广泛应用，不保证最优解，但通过调整 beam width 参数能得到工程上可接受的结果</div>2019-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg" width="30px"><span>五岳寻仙</span> 👍（166） 💬（7）<div>课后思考题，自己能想到的。

1.获取通过某条路的时间：通过某条路的时间与①路长度②路况(是否平坦等)③拥堵情况④红绿灯个数等因素相关。获取这些因素后就可以建立一个回归模型(比如线性回归)来估算时间。其中①②④因素比较固定，容易获得。③是动态的，但也可以通过a.与交通部门合作获得路段拥堵情况；b.联合其他导航软件获得在该路段的在线人数；c.通过现在时间段正好在次路段的其他用户的真实情况等方式估算。

2.混合公交、地铁和步行时：地铁时刻表是固定的，容易估算。公交虽然没那么准时，大致时间是可以估计的，步行时间受路拥堵状况小，基本与道路长度成正比，也容易估算。总之，感觉公交、地铁、步行，时间估算会比开车更容易，也更准确些。</div>2019-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/dc/67/5149a60b.jpg" width="30px"><span>李东勇</span> 👍（36） 💬（2）<div>有兴趣的可以看下LeetCode 上这道题： https:&#47;&#47;leetcode.com&#47;problems&#47;network-delay-time&#47;
用到的就是Dijkstra 算法</div>2019-01-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg" width="30px"><span>徐凯</span> 👍（31） 💬（1）<div>@五岳寻仙的答案太棒了 👏 我感觉每条道路应该还有限速，这个因素也要考察。</div>2019-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg" width="30px"><span>book尾汁</span> 👍（22） 💬（2）<div>感觉这个算法最不容易让人理解的地方就是优先级队列里的某个顶点B pop出去以后，会不会以后会有某个还没有入队列的节点C 使经过节点C到B到源点的距离更近，实际这是不会的，因为优先级队列每次都是pop出当前离源点距离最近的点，假如节点C经过B使B到源点的距离更近，那么C点在优先级队列一定会比B先pop出去，然后更新B到源点的距离，想明白这一点，这个算法就很好理解了。</div>2020-01-03</li><br/><li><img src="" width="30px"><span>林大涛</span> 👍（19） 💬（0）<div>用小顶堆，就是为了确保每个阶段，堆顶的节点都是目前阶段的最短路径的节点。</div>2019-02-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/de/1e/4e3d207f.jpg" width="30px"><span>Shaohong</span> 👍（13） 💬（0）<div>geeksforgeeks上面对Dijkstra算法介绍很好懂。https:&#47;&#47;www.geeksforgeeks.org&#47;dijkstras-shortest-path-algorithm-greedy-algo-7
根据这个算法，老师没有必要用inqueue数组。可以一开始就把所有Vertex都加入到PriorityQueue中，之后就只做取顶操作和更新操作。</div>2020-01-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg" width="30px"><span>mrlay</span> 👍（11） 💬（3）<div>这是一个动态规划的问题，我最开始也以为是个贪心算法，会有这样的想法是每次都会去选择dist最小的那个顶点，殊不知这个顶点是在算完每个邻接顶点后（有可能是间接相邻的）选择最小的那个。
vertex 临时数组的作用就是为了临时记录从起点到该顶点dist, 用来更新最小优先队列。</div>2019-07-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cf/40/8d02f5ef.jpg" width="30px"><span>王策</span> 👍（8） 💬（1）<div>文章翻译系统的例子与Leetcode上这一题类似：https:&#47;&#47;leetcode-cn.com&#47;problems&#47;find-k-pairs-with-smallest-sums&#47;</div>2020-03-13</li><br/><li><img src="" width="30px"><span>Geek_94adb8</span> 👍（7） 💬（3）<div>使用内部类，代码的可读性很差！</div>2020-02-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg" width="30px"><span>社会你强哥</span> 👍（6） 💬（0）<div>不能只有代码，解释代码就完事了，能够从原理的角度来描述dijkstra是怎么做的么？</div>2020-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/791d0f5e.jpg" width="30px"><span>忍者无敌1995</span> 👍（6） 💬（1）<div>构建优先队列的update函数时，时间复杂度应该是O(n)，因为小顶堆查找的时间复杂度是O(n)，虽然查找之后向上堆化的时间复杂度时O（logn）</div>2019-03-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg" width="30px"><span>book尾汁</span> 👍（5） 💬（0）<div>第十三天：
地图软件是如何计算出最短路径的
我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边，这样就构成了一幅有向有权图。这个问题就转化为求一个有向有权图中，两个顶点最短路径的问题。
上述问题可以使用dijkstra算法
原理：将每个顶点到起始顶点的距离初始为无穷，然后从起始点开始，将其加入一个优先级队列中，从优先级队列中取出到源点距离最小的顶点，然后比较其周围顶点离源点的距离是否大于其到源点的距离+其到周围顶点的距离，如果大于的话，更新周围顶点到源点的距离为较小的值以及其前序节点，并将其加入优先级队列中（如果已经加入过，就不需加入了），再取出优先级队列中的距离最小值，循环往复，直到取出终止顶点t，或者优先级队列为空。此时倒序输出终止顶点t的前序节点，前序节点的前序节点。。。，直到前序节点的前序节点为s,此时路径即为最短路径。
计算最少红绿灯依然可以采用上述的思路，构造一个有向无权图。
对于地点跨度范围比较大，可以分阶段来计算，找出哪些点是必经的点，然后拆分阶段。具体到每个区域，可以找个合适的区域将源点与中点覆盖进去，来减少顶点的数量。</div>2020-01-02</li><br/>
</ul>