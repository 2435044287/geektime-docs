今天我们来聊聊“链表（Linked list）”这个数据结构。学习链表有什么用呢？为了回答这个问题，我们先来讨论一个经典的链表应用场景，那就是LRU缓存淘汰算法。

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。

这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？

好了，回到正题，我们今天的开篇问题就是：**如何用链表来实现LRU缓存淘汰策略呢？** 带着这个问题，我们开始今天的内容吧！

## 五花八门的链表结构

相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常会放到一块儿来比较。所以我们先来看，这两者有什么区别。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/b2/80/e9223398.jpg" width="30px"><span>glbfor.gtw</span> 👍（142） 💬（11）<div>1 快慢指针定位中间节点（这里要区分奇偶情况）
1.1 奇数情况，中点位置不需要矫正
1.2 偶数情况，使用偶数定位中点策略，要确定是返回上中位数或下中位数
1.2.1 如果是返回上中位数，后半部分串头取next
1.2.2 如果是返回下中位数，后半部分串头既是当前节点位置，但前半部分串尾要删除掉当前节点
2 从中间节点对后半部分逆序，或者将前半部分逆序
3 一次循环比较，判断是否为回文
4 恢复现场

题外话，这种操作有点BT啊？实际运用场景中，也真的直接改变引用值吗？至少在多线程情况，要加N多锁（Read Write都要加锁），这个时间成本就不能简单用时间复杂度来衡量了。如果是用copy 机制，不论是倒置前半段还是后半段，至少有一段是需要n&#47;2个节点副本的空间消耗的，那么空间复杂度就是O（n）？？啦~跑题了，跑题了~~

老师，你给我评价被~ 我比较容易钻牛角尖。。
</div>2018-10-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg" width="30px"><span>sky</span> 👍（91） 💬（3）<div>用快慢指针先找到中点，然后把后半段链表reversed，然后一个指针在头部，一个指针再中点，开始逐个比较，时间复杂度是O（n)</div>2018-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg" width="30px"><span>Rain</span> 👍（1637） 💬（73）<div>Re Ydyhm:

“数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。” 这里的CPU缓存机制指的是什么？为什么就数组更好了？

----

我没有百度也没有Google。之前开发时遇到过，我斗胆说下。
CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。

大牛请指正哈！</div>2018-10-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8b/73/5d4dca26.jpg" width="30px"><span>andavid</span> 👍（447） 💬（32）<div>思考题：

使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。

时间复杂度：O(n)
空间复杂度：O(1)

https:&#47;&#47;github.com&#47;andavid&#47;leetcode-java&#47;blob&#47;master&#47;note&#47;234&#47;README.md</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" width="30px"><span>Liam</span> 👍（245） 💬（7）<div>1 快慢指针定位中间节点
2 从中间节点对后半部分逆序
3 前后半部分比较，判断是否为回文
4 后半部分逆序复原

时间复杂度On, 空间复杂度O1
把LRU和回文都实现了一遍~~

如果是双向链表，时间效率更高，看了下LinkedList，底层也是用双向链表实现</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" width="30px"><span>姜威</span> 👍（381） 💬（22）<div>五、应用
1.如何分别用链表和数组实现LRU缓冲淘汰策略？
1）什么是缓存？
缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。
2）为什么使用缓存？即缓存的特点
缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。
3）什么是缓存淘汰策略？
指的是当缓存被用满时清理数据的优先顺序。
4）有哪些缓存淘汰策略？
常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。
5）链表实现LRU缓存淘汰策略
当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。
6）数组实现LRU缓存淘汰策略
方式一：首位置保存最新访问数据，末尾位置优先清理
当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。
方式二：首位置优先清理，末尾位置保存最新访问数据
当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）
2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）
1）前提：字符串以单个字符的形式存储在单链表中。
2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。
3）将链表中的字符倒序存储一份在另一个链表中。
4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。
六、设计思想
时空替换思想：“用空间换时间” 与 “用时间换空间”
当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" width="30px"><span>姜威</span> 👍（154） 💬（7）<div>总结
一、什么是链表？
1.和数组一样，链表也是一种线性表。
2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。
二、为什么使用链表？即链表的特点
1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。
三、常用链表：单链表、循环链表和双向链表
1.单链表
1）每个节点只包含一个指针，即后继指针。
2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。
2.循环链表
1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。
2）适用于存储有循环特点的数据，比如约瑟夫问题。
3.双向链表
1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。
3）性能特点：
和单链表相比，存储相同的数据，需要消耗更多的存储空间。
插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。
对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
4.双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。
四、选择数组还是链表？
1.插入、删除和随机访问的时间复杂度
数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。
2.数组缺点
1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
3.链表缺点
1）内存空间消耗更大，因为需要额外的空间存储指针信息。
2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。
4.如何选择？
数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
如果代码对内存的使用非常苛刻，那数组就更适合。
</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f0/21/7168f973.jpg" width="30px"><span>JStFs</span> 👍（58） 💬（3）<div>LRU：活在当下。比如在公司中，一个新员工做出新业绩，马上会得到重用。

LFU：以史为镜。还是比如在公司中，新员工必须做出比那些功勋卓著的老员工更多更好的业绩才可以受到老板重视，这样的方式比较尊重“前辈”。</div>2018-10-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg" width="30px"><span>岁月如歌</span> 👍（27） 💬（2）<div>设计lru算法的思路，不管用什么数据结构，都要考虑的几个问题。
1、如何表示最近访问的数据和最早访问的数据
2、如何查找是否缓存了
3、数据有缓存，如何处理
4、数据没有缓存，如何处理
      1.缓存未满
      2.缓存已满</div>2018-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/14/f9/5e08a350.jpg" width="30px"><span>5ispy</span> 👍（21） 💬（3）<div>老师好，关于这节的内容有个疑问不太确定。
因为我看有人用java实现了链表有人也可以用c来实现。是不是数组属于编程语言“自带”的，而链表是 人 用编程语言 “实现”的。
比如对于java来说，如果项目中用到了链表，我们可以说是用到了某个类，而这个类就是 链表（实现了链表的功能）。
恳请老师指正！</div>2018-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg" width="30px"><span>阳仔</span> 👍（15） 💬（1）<div>学习反馈：
链表也是一种基础的线性表结构。由于它的很多特点跟数组是相反的，因此可以与数组一起对比着学习。
数组的存储空间是连续，而链表不是；数组可以通过寻址公式计算通过下标来访问，而链表访问元素需要遍历。
常见的链表有：
单链表、双向链表、循环链表、双向循环链表。
链表擅长插入、删除操作，时间复杂度为O(1)；查询的效率不高，时间复杂度为O(n)。
数组擅长通过下标随机访问元素，时间复杂度为O(1)；插入、删除的效率不高，时间复杂度为O(n)。
在实际项目开发中，选择数组或者链表不能只关注时间复杂度，还需要考虑具体业务，综合考虑选择数组还是链表。
了解了链表的数据结构，那么实现一个机遇链表数据结构的LRU算法就比较简单了：
从链表中查询此缓存数据是否存在：
1、如果存在，则删除该缓存数据节点，并把数据插入到链表头部的位置；
1、如果不存在，则也考虑两种情况：
    1、如果缓存充足，则把数据插入到链表头部的位置；
    2、如果缓存不足，则把链表中的末尾节点删除，再把缓存数据插入到头部。
思考题：
如果是只使用单链表的话，假设存储回文的链表是L1，再用一个链表L2来存储逆文；
我的思路是这样：
1、循环这个回文链表L1，在遍历到一半之前把逆文存在一个L2中；
例如L1 为A-&gt;B-&gt;C-&gt;B-&gt;A，那么遍历到一半时，L2为：B-&gt;A；
偶数和奇数的区别在与中间的节点要不要放在L2中。
2、继续遍历比较L1,L2两个链表各个元素是否相等，如果不相等则立即返回；如果比较到最后遍历结束，则说明是回文；
因此通过一次遍历就知道这个链表是否为回文。时间复杂度为O(n)。
</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/dd/03/77a80775.jpg" width="30px"><span>CH_CB</span> 👍（15） 💬（2）<div>越靠近链表尾部的结点是越早之前访问的

这里不懂 😳老师可以解答一下吗，谢谢</div>2018-10-03</li><br/><li><img src="" width="30px"><span>拔剑四顾心惘然</span> 👍（13） 💬（3）<div>单向链表回文判断代码： https:&#47;&#47;github.com&#47;guyuqi&#47;yuqi-repo&#47;blob&#47;master&#47;palindrome&#47;palindrome.c</div>2018-10-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg" width="30px"><span>我瑟瑟的方法</span> 👍（6） 💬（3）<div>什么是回文串</div>2018-10-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/bc/a20dc219.jpg" width="30px"><span>A漩</span> 👍（6） 💬（4）<div>最近最少使用策略 LRU（Least Recently Used）
老师此处的例子是着重体现了”最近“的场景吧！
如果想体现”最少“是不是还得为LinkedList加个”访问次数“的属性？</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/dd/e9/40a98e2f.jpg" width="30px"><span>卓修武</span> 👍（5） 💬（2）<div>&quot;因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个节点的指针，所以内存消耗会翻倍&quot;，这句话似乎有点不太严谨，存储的只是指针，内存消耗会翻倍是跟什么比较的？</div>2019-06-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d6/59/cb4e7ed8.jpg" width="30px"><span>小帅b</span> 👍（5） 💬（1）<div>--------总结一下--------


常见的链表结构
1.单链表：
每个节点除了存储数据之外，还有记录下一个节点的地址，这样才能串联起来，记录下一个节点地址的指针就是「后续指针next」。
其中有两个特殊的节点为「头结点」和「尾节点」，头结点记录链表的基地址，尾节点记录下一个节点地址是NULL，代表链表的最后一个节点。

链表增删效率高
对于链表（存储数据无需连续性）的增删，只需要考虑指针的改变，复杂度为O（1）。

链表访问慢
由于不像数组那样可以根据首选地址和下标计算出内存地址，只能通过遍历节点获取地址。时间复杂度为0（n）。

2.循环链表
是特殊的单链表，尾节点指针指向链表的头结点。

3.双向链表
支持双向，除了「后续指针next」还有「前驱指针prev」

相比单链表和双链表，增删查效率高，内存消耗高。

空间换时间，时间换空间
对于执行慢的程序--&gt;空间换时间
对于消耗内存多的程序--&gt;时间换空间

链表和数组的区别

底层存储结构：
数组需要一块连续的内存空间存储
链表通过“指针”将一组零散的内存块串联起来使用

性能：
1.链表和数组的（增删查）时间复杂度正好相反。

2.数组使用连续的内存空间，可以借助缓存机制提高效率。
链表不连续，所以无法借助缓存机制。

3.数组大小固定，当要申请更大的空间，需要拷贝数据，很耗时。
链表则支持动态扩容。

4.相对来说链表比较耗内存，因为需要记录节点指针，内存消耗翻倍。</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/26/88/e8098480.jpg" width="30px"><span>James Scott</span> 👍（5） 💬（2）<div>回复一下CaiBird的提问：应该是写错了，应该是越靠近链表头部的节点是越早被访问的。</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f6/88/ee32fde9.jpg" width="30px"><span>章光辉</span> 👍（4） 💬（2）<div>判断访问的数据是否存在于缓存里的时候，无论是链表还是数组，时间复杂度都是O(n)对吧？那么在此基础上做的增删改，最高的复杂度也只是O(n)。根据加法法则，总的复杂度都是O(n)。不知道我理解得对不对？</div>2018-10-05</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaIgoPa8abNTaUm7o6oa6mvL9iagRTdD1vhovWPyfiaS82f409Sz3kMFzYLNa4ibnHagA7M33l8XnIQ/132" width="30px"><span>Bufan</span> 👍（3） 💬（2）<div>我有一个疑问，javascript数组的每一个元素大小不是一样的，那查找的时间复杂度还是O（1）吗？</div>2019-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg" width="30px"><span>猫头鹰爱拿铁</span> 👍（3） 💬（1）<div>判断字符串是否为回文字符串？遍历单链表同时放到一个栈里面，然后再遍历一遍单链表，遍历的同时和栈pop出的数据对比，全都一致则说明为回文字符串。</div>2018-10-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/43/98/d1f6c524.jpg" width="30px"><span>(≧ω≦)罗敏</span> 👍（2） 💬（2）<div>单链表判断是否是回文串:
把原先的单链表倒序复制一遍，然后比较两个链表是否值相同</div>2018-10-11</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoH9Mlw0kLK0p39vhQpdvkbQP5TX96DB9HMJ1POaTVDpMZg4rjlO3WCAqiaWWMc77ffS3vTo8qWdXA/132" width="30px"><span>xdargs</span> 👍（2） 💬（1）<div>讲得很容易理解，不多的篇幅讲知识点和应用，润物无声</div>2018-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg" width="30px"><span>小喵喵</span> 👍（2） 💬（1）<div>如果此数据之前已经被缓存在链表中了,我们遍历得到这个数据对应的结点,并将其从原来的位置删除，然后再插入到链表的头部。
1。LRU算法这点不太理解，为什么都在cache中，还有删除掉重新插入呢？
2.  这个LRU算法，cache过期了，如何更新呢？请老师指点一下。





</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/1b/85/c743120c.jpg" width="30px"><span>🍀  Rice</span> 👍（2） 💬（2）<div>为什么单链表插入删除的时间复杂度是O(1)呢？如果插入一个数在下标是K的位置，不是要先遍历获取到a(k-1)吗?</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c9/1d/c7586cfc.jpg" width="30px"><span>Snail</span> 👍（1） 💬（1）<div>请问Windows 和类 Unix 两大操作系统阵营的设计思路是不是也类似链表和数据的特点，Windows 开机启动后不会占据太多的内存，而像 Linux 以及 macOS 这些，开机启动应用后会首先“霸占”很多内存，不管用没用到，就像数组一样预先申请了较多的内存。再对比实际的应用程序，相同启动规模的应用程序在 Windows 内存占用好像就回比 Linux 下多一些。不知道这样类比是否合理。</div>2019-10-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/44/a8/0ce75c8c.jpg" width="30px"><span>Skrpy</span> 👍（1） 💬（1）<div>可以问一下老师，文章里美妙的插图都是怎么做的吗</div>2019-09-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/a7/60/f175d953.jpg" width="30px"><span>与雨日肇事的爱</span> 👍（1） 💬（2）<div>老师，关于Lru算法的实现思路我有一点疑问：
 1. 如果此数据之前已经被缓存在链表中了， 我们遍历得到这个数据对应的结点，并将其从原来的位置删 
 除，然后再插入到链表的头部。这里为什么要将原来的数据删除呢？我记得之前学操作系统概论的时候讲的lru页面置换算法中，如果队列中存在该数据的话没有做任何操作，没有删除。

希望老师可以帮忙解答，谢谢！
</div>2019-03-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg" width="30px"><span>👽</span> 👍（1） 💬（1）<div>判断是否是回文
回文：level noon这样，对称的字符串
手机回复，所以不写代码了，就写一下思路。
1.创建一个双向链表存储该字符串
2.循环找到中间节点 长度\2 再+1（长度为10，就访问第6个，长度为7就访问4）
4.定义两节点，两种情况 
      1.如果长度是奇数，两个节点都指向已找到的中间节点。
     2.如果长度是偶数，那么分别指向之前找到的节点的前一个节点。
5.两变量分别取上一个节点和下一个节点对比并复制给自己。直到上一个节点为空时。代表链表遍历结束。
6.中间任意一次数值不相等则返回false，到最后都相等则返回ture。
时间复杂度应该是O（n），这样处理对吗？</div>2018-10-29</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibr1EW9cGq5zRX7V0Arn21wXldy9cPWpL7lUzyrqLeuLQgCC0icvZziaIOJ8nxWibOmuawhxevcfUNg/132" width="30px"><span>王</span> 👍（1） 💬（1）<div>数组如果不通过下标查询 而是通过遍历来查询的话是否代表着除了因为CPU缓存而比链表快在未排序的情况下 时间复杂度都是O(n) ，目前一般真实开发中更多的是通过遍历未排序的数组来查询数组里数据进行判断，那给我的感觉真实开发中数组和链表查询性能没有想象中差距那么大</div>2018-10-25</li><br/>
</ul>