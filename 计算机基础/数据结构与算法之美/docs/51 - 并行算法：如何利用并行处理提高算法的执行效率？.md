时间复杂度是衡量算法执行效率的一种标准。但是，时间复杂度并不能跟性能划等号。在真实的软件开发中，即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率。毕竟，对于实际的软件开发来说，即便是像10%、20%这样微小的性能提升，也是非常可观的。

算法的目的就是为了提高代码执行的效率。那**当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢**？我们今天就讲一种非常简单但又非常好用的优化方法，那就是并行计算。今天，我就通过几个例子，给你展示一下，**如何借助并行计算的处理思想对算法进行改造？**

## 并行排序

假设我们要给大小为8GB的数据进行排序，并且，我们机器的内存可以一次性容纳这么多数据。对于排序来说，最常用的就是时间复杂度为O(nlogn)的三种排序算法，归并排序、快速排序、堆排序。从理论上讲，这个排序问题，已经很难再从算法层面优化了。而利用并行的处理思想，我们可以很轻松地将这个给8GB数据排序问题的执行效率提高很多倍。具体的实现思路有下面两种。

**第一种是对归并排序并行化处理**。我们可以将这8GB的数据划分成16个小的数据集合，每个集合包含500MB的数据。我们用16个线程，并行地对这16个500MB的数据集合进行排序。这16个小集合分别排序完成之后，我们再将这16个有序集合合并。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyP4WVaRJVV3OQ6icPfjicf2JqHjNGw0PhhOMnibicoMzLC3xzibHuibd9s2c3uWa1Y9Gg721L4cO2MUQ/132" width="30px"><span>Geek_46cdcd</span> 👍（11） 💬（3）<div>请问老师，广度优先搜索中用两个队列是为了解决多线程的并发问题吗？</div>2019-05-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" width="30px"><span>Smallfly</span> 👍（8） 💬（1）<div>并行搜索只用一个队列不可以么？</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg" width="30px"><span>纯洁的憎恶</span> 👍（8） 💬（1）<div>并行与分治的区别是什么？前者偏工程，后者偏算法么？还是前者在并发环境中，后者在单核串行环境中？</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/ec/8f/8299495a.jpg" width="30px"><span>少盐</span> 👍（1） 💬（1）<div>计算机不一定都是n核的，怎么实现性能提升n倍呢</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg" width="30px"><span>走马</span> 👍（0） 💬（1）<div>是不是就类似于spark中rdd 的宽窄依赖了</div>2019-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg" width="30px"><span>朱东旭</span> 👍（0） 💬（1）<div>老师，并行搜索在你的描述中是先操作队列A,再操作队列B,这是有先后顺序，这意味着是串行的不是并行呀。</div>2019-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg" width="30px"><span>失火的夏天</span> 👍（222） 💬（7）<div>思考题用一个有向图来存储任务之间的依赖关系，然后用拓扑排序的思想来执行任务，每次都找到入度为0的，放在队列里，启动线程池开始执行，队列里的任务并行执行完毕，再次调用拓扑排序找到入度为0的人，放入队列，直到所以任务跑完</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg" width="30px"><span>Jerry银银</span> 👍（52） 💬（3）<div>一看到依赖，就想到了拓扑。

这种感觉好是还是不好呢？</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg" width="30px"><span>DFighting</span> 👍（48） 💬（2）<div>现在才明白，其实最底层的数据结构是&lt;addr,value&gt;，按照存储介质是否连续、是否显示制定key又可以分为数组、链表和hash，其中数组可以认为是一种&lt;index,arr[index]&gt;，链表是&lt;p,*p&gt;，然后在这基础之上衍生出了一维的线性表、栈、队列，散列表，二维的树(平衡二叉树、红黑树、跳表)，三维的图，还有就是各种数据结构灵活组合的数据结构，这里的跳表可以算是组合类型的，但是它的使用范围很多，所以划到了二维中。这些是存储
然后是算法：排序、分治、贪心、回溯、动态规划
第一次真正感觉到了数据结构和算法的关联，好神奇的感觉。至少现在觉得那些难记的算法、数据结构没那么困难了，多思考、实践总会能够像写代码般应用到实际中。</div>2019-08-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg" width="30px"><span>hua168</span> 👍（16） 💬（9）<div>老师，我就问一个题外问题：
大专学历，想直接自学考本科或研究生，自考学历IT类公司承认的吗？
很多都要求全日制本科~~</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg" width="30px"><span>🐱您的好友William🐱</span> 👍（13） 💬（1）<div>使用拓扑关系来构建图安排计算顺序，这个spark，tensorflow都是这么安排的，效率比最开始的MapReduce还要高很多。</div>2019-02-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg" width="30px"><span>茴香根</span> 👍（13） 💬（1）<div>思考题讲的够直白了，n个任务有互相依赖。那么并行处理的方法就要采用流水线的思想了。创建n个线程，每个线程完成一个任务。每个线程在它的上游线程结束输出结果后启动，完成之后把结果传递给下游任务线程继续流程。整个工作场景像工厂里面的流水线一样，每一个线程都努力地重复着某一阶段的任务，提高整体资源利用率。</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/791d0f5e.jpg" width="30px"><span>忍者无敌1995</span> 👍（9） 💬（1）<div>想到的第一个思路就是前面所讲的拓扑排序，任务之间的关系用有向图表示，如果是采用khan遍历，则每次找到入度为0的，同时多线程执行，等他们执行完（java可以通过CountDownLatch来模拟实现），然后同理找到入度为0的任务，继续同理执行，直到全部执行完</div>2019-04-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg" width="30px"><span>注定非凡</span> 👍（5） 💬（1）<div>算法的目的就是为了提高代码执行的效率。当算法无法再继续优化的情况下，需要借助并行计算的处理思想对算法进行改造

并行排序
假设要给大小为 8GB 的数据进行排序，最常用的是三种排序算法，归并排序、快速排序、堆排序，时间复杂度为 O(nlogn) 。从理论上讲，已经很难再从算法层面优化了。而利用并行的处理思想可以将执行效率提高很多倍。

第一种是对归并排序并行化处理
	* 将这8GB 的数据划分成 16 个小的数据集合，每个集合包含 500MB 的数据。
	* 用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序。
	* 16 个小集合分别排序完成之后，再将这 16 个有序集合合并。

第二种是对快速排序并行化处理
	* 将数据扫描一遍，找到数据所处的范围区间，在按从小到大划分成 16 个小区间。
	* 将 8GB 的数据划分到对应的16 个小区间中，启动 16 个线程，并行地进行排序。
	* 等到 16 个线程都执行结束后，得到的数据就是有序数据了。

对比这两种处理思路
	* 共同点：它们利用的都是分治的思想，对数据进行分片，然后并行处理。
	* 不同点：
        （1）第一种处理思路是，先随意地对数据分片，排序之后再合并。
        （2）第二种处理思路是，先对数据按照大小划分区间后再排序，排完序就不需要再处理了。
	* 这个跟归并和快排的区别如出一辙。

并行查找
      散列表是一种非常适合快速查找的数据结构。
弊端：
	* 如果给动态数据构建索引，数据不断加入会使散列表的装载因子越来越大
	* 为了保证散列表性能不下降，就需要对散列表进行动态扩容
	* 对巨大的散列表进行动态扩容，不仅比较耗时，还比较消耗内存
优化：
	* 实际上可以将数据随机分割成 k 份（比如 16 份），每份中的数据只有原来的 1&#47;k
	* 然后针对这 k 个小数据集合分别构建散列表。这样，散列表的维护成本就变低了
	* 当某个小散列表的装载因子过大的时，可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容。
	* 当要查找数据时，通过 16 个线程并行地在这16 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。
	* 当往散列表中添加数据时，可以将新数据放入装载因子最小的散列表中，这样也有助于减少散列冲突。


假设有 2GB 的数据，放到 16 个散列表中，每个散列表中的数据大约是 150MB。当某个散列表需要扩容的时候，我们只需要额外增加 150*0.5=75MB 的内存（假设还是扩容到原来的 1.5 倍）。不管从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效

并行字符串匹配
在文本中查找某个关键词可以通过字符串匹配算法来实现，字符串匹配算法有 KMP、BM、RK、BF 等

如果处理的是超级大的文本，可以把大的文本，分割成 k 个小文本。假设 k 是 16，就启动 16 个线程，并行地在这 16 个小文本中查找关键词，这样整个查找的性能就提高了 16 倍

并行搜索
搜索算法有：广度优先搜索、深度优先搜索、Dijkstra 最短路径算法、A* 启发式搜索算法。对于广度优先搜索算法，也可以将其改造成并行算法。
	* 广度优先搜索是一种逐层搜索的搜索策略
	* 基于当前这一层顶点，我们可以启动多个线程，并行地搜索下一层的顶点
	* 在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点
	* 经过改造之后的并行广度优先搜索算法，需要利用两个队列来完成扩展顶点的工作

</div>2020-02-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e9/49/29072f9e.jpg" width="30px"><span>刺猬</span> 👍（4） 💬（4）<div>王铮老师，你好，学习了这么久一直有一个疑问，之前讲的那个100G订单排序的问题，一大份数据分成多份小数据然后进行排序，原理其实很简单，但是分的时候可以用到什么算法，分完组合的时候用到什么算法，因为100G订单不是之前就分好的，要一次性分，那也需要扫描这100G订单，另外如果分的时候不是采用先对数据按照大小划分区间，然后再排序的话，那么在每一段内是有序的，但是不能保证组合以后也有序，所以组合的时候还有进行排序，这种情况有什么好的解决思路。</div>2019-11-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg" width="30px"><span>mrlay</span> 👍（4） 💬（0）<div>我觉得能够并行执行多少个任务，是取决于这些任务之间的依赖关系；采用拓扑只是为了确认任务的先后执行。 最坏的情况下还是会变成串行的。</div>2019-07-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/11/7b/3426351c.jpg" width="30px"><span>一念_风生</span> 👍（1） 💬（0）<div>一言以蔽之：单线程不够 多线程来凑 需要考虑的就是如何将算法与多线程结合起来 其实就是要巧妙的利用分治思想 不知道我这样理解是否正确</div>2020-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/2b/ce/15a82b5c.jpg" width="30px"><span>高学义</span> 👍（1） 💬（0）<div>课后思考：先利用拓扑排序找到各个任务之间的依赖关系，然后对拓扑关系中处于同一层级的任务采用并行处理。</div>2020-03-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/6d/c1/a1aae7af.jpg" width="30px"><span>Jarvi</span> 👍（1） 💬（1）<div>硬盘里1t的数据咋处理，有人有想法么</div>2020-03-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg" width="30px"><span>djfhchdh</span> 👍（1） 💬（0）<div>利用两个队列A和B，多线程并行处理A队列中的顶点（入度为0），并将入度为0的扩展顶点（扩展顶点的入度减1）入队B，A队列中顶点都处理完，队列A清空，再并行处理B队列中顶点，并将入度为0的扩展顶点（扩展顶点的入度减1）入队A，如此两个队列循环使用</div>2019-06-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/09/49/8bc5e315.jpg" width="30px"><span>牧民牛仔</span> 👍（1） 💬（0）<div>既然有依赖关系，我条件反射想到拓扑排序算法，根据依赖关系把任务分组，各组任务按照依赖关系排序。没有依赖关系的任务组可以并行执行，有依赖关系的任务组内则按依赖关系有序的执行。</div>2019-01-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/1c/46/a141c7e6.jpg" width="30px"><span>子嘉</span> 👍（1） 💬（0）<div>思考题是：拓扑排序么。。</div>2019-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg" width="30px"><span>feifei</span> 👍（1） 💬（0）<div>我想到了图，讲依赖关系抽象成边，使用图排序就可以找出依赖关系，然后将每一层的任务放入线程池执行，当一层完成后，继续下一层处理</div>2019-01-23</li><br/><li><img src="" width="30px"><span>Geek_8e9c8d</span> 👍（0） 💬（0）<div>我觉得不一定需要两个队列吧 直接统计每次的size不就好了
</div>2022-08-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg" width="30px"><span>H.H</span> 👍（0） 💬（0）<div>思考题就想到了C++的源文件编译，先找出没依赖关系，再找出下一级仅依赖这些没依赖的，同级之间就可以并行了。看到评论，才发现，原来是拓扑呀....</div>2022-07-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg" width="30px"><span>苏成</span> 👍（0） 💬（0）<div>说一下自己的看法：
并行本质上是分治，将我们的问题分成几个小块，然后多线程执行，最后将结果合并
思考题：
我们在拓扑排序Kanh算法之时（其实这个就是BFS）也使用两个队列方法和本节课之中BFS并行搜索一致。A存储当前层的节点，多线程遍历结果存放在B之中，然后遍历B存放在A，循环使用两个队列</div>2022-05-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/d3/09/d6e7fc83.jpg" width="30px"><span>有头脑的饕餮</span> 👍（0） 💬（0）<div>有关并行计算的入门书籍推荐吗？</div>2022-01-18</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132" width="30px"><span>吴钩</span> 👍（0） 💬（0）<div>广度优先并行的理解：之所以用两个队列，是因为多线程下先扩展的节点可能后返回，导致按层遍历出现错误。而两个队列轮流扩展相当于按层做了同步，必须处理完一层才能处理下一层。</div>2021-09-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/10/67/49dfb810.jpg" width="30px"><span>豆瓣酱</span> 👍（0） 💬（0）<div>并行算法需要设计复杂的调度系统</div>2021-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg" width="30px"><span>罗耀龙@坐忘</span> 👍（0） 💬（0）<div>茶艺师学编程

思考题
········在并行之前再套用拓扑结构吗？</div>2021-03-01</li><br/>
</ul>