你好，我是LMOS。

前面我们一起探讨了RISC-V芯片，设计和实现了一个迷你CPU。之后还深入研究了CPU上面运行的语言和指令系统，它们是构成程序的重要要素。依托于芯片和语言、指令，我们就可以编写和执行程序了。

不过我们开发应用的时候，还有个打交道最频繁的模块——内存。很多工程问题你不懂内存，就会举步维艰。你也许觉得内存知识太难了，不但关联知识又多又散乱，而且深挖下去感觉没有尽头。但计算机的硬核基础，内存是必修关卡，只要你跟住我的节奏坚持下来，一定可以把内存的本质、内存系统的来龙去脉都弄明白，一起加油。

这节课，让我们迈出认识内存的第一步，我们先搞清楚CPU怎么访问内存，然后再来分析内存地址从何而来，最终让你建立对内存地址空间的理解。这节课的配套代码，你可以从[这里](https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson23)下载。

### CPU如何访问内存

CPU怎么访问内存？我们回想一下，之前讲过的高级语言和低级语言转化过程。

我们先思考一下，C语言把我们写出来的变量和函数都转换成了什么呢？如果记不太清了，可以回顾[第十五节课](https://time.geekbang.org/column/article/558338)。没错，C语言把变量名和函数名都转换成了汇编语言里的标号，而汇编语言的标号，就是机器更好理解的符号。符号具体包括符号类型、符号名称和符号地址这几个属性。其中，符号地址是由一个叫链接器的东西生成的。
<div><strong>精选留言（10）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg" width="30px"><span>苏流郁宓</span> 👍（7） 💬（1）<div>操作系统安装会给定一个最低内存条存储要求，实际上只要过了这个要求，内存条容量大小操作系统不怎么关心，反正MMU完事
通过原子锁等功能，来维护数据一致性，监控进程&#47;线程。至于软件需求，那好办，通过时间轮换原则，每个线程跑一会就换另一个的！
这也导致一个问题，如果线程过多，那么排队等待时间就会变长！像大型游戏厂商对cpu性能及内存条和显存容量都有要求，也就是帮cpu减负（可以通过显卡芯片完成的就尽量少用cpu，还有驻存在内存条上的数据交换时间总好过内存条与硬盘交换数据）
在大型游戏运行时，显卡驱动也在运行（加载在内存条上，帮助cpu完成部分数据分流给显卡芯片），这也是软硬件方式优化MMU效率的一个案例！</div>2022-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg" width="30px"><span>TableBear</span> 👍（5） 💬（2）<div>连接器使用的地址是虚拟内存地址。物理内存地址要在发起访存操作之后通过MMU单元进行转换才能得到（这个过程设计页表和TLB等机制）。如果虚拟内存地址还未跟物理内存地址绑定，此时还会发生缺页异常陷入内核进行物理内存分配。</div>2022-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg" width="30px"><span>功夫熊猫</span> 👍（3） 💬（1）<div>只能是虚拟内存，如果用的物理内层就很麻烦，没有可扩展性和可移植性了，而且如果直接操作物理内存，那对应程序员的要求就不是CRUD了。虚拟内存就是那句经典的计算机的话：“计算机什么问题都可以靠增加一层中间层来解决的”</div>2022-10-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg" width="30px"><span>苏流郁宓</span> 👍（1） 💬（1）<div>链接器用的是虚拟内存地址（就不用关心是不是和物理设备地址覆盖）使用时通过操作系统内核加载到物理地址上，操作系统通过进程&#47;线程进行管理！
MMU地址转换功能，在保护模式下运行（尽可能避免因虚拟地址相同而导致的数据覆盖）
32位内存应为0到0xefffffff
那么问题来了，对普通程序而言，有虚拟地址方便！但对操作系统开发者而言，恐怕还是得清楚设备地址吧？这个设备地址应该有个标准吧？这样操作系统本身数据才能不与物理设备地址冲突！
如果设备地址的标准不一，预估cpu应该按照设备地址寻址优先原则（允许覆盖），这也估计是为啥操作系统保护模式内核在高位的一个原因吧？（这样，即使不知新的设备地址（假如设备开发商不通知操作系统开发商）只要内核在高位，大不了重新引导程序加载在空的内存空间上的）</div>2022-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/ae/c3/d930693b.jpg" width="30px"><span>LockedX</span> 👍（1） 💬（1）<div>链接器使用的是虚拟地址，如果使用物理地址那么链接的过程将及其复杂并且物理地址用完了就不能再编译，这显然是不行的。</div>2022-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg" width="30px"><span>peter</span> 👍（1） 💬（3）<div>请教老师几个问题啊：
Q1：“设备寄存器”有哪些？只知道CPU有寄存器，难道CPU之外的设备也有寄存器？
Q2：“sw_ins((unsigned int)&amp;word, 0);”，调用sw_ins的时候传入了参数，但sw_ins函数的定义中并没有参数啊。
Q3：代码中动态分配的内存是怎么确定地址的？此时程序已经运行，链接器无法参与了。</div>2022-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg" width="30px"><span>温雅小公子</span> 👍（0） 💬（1）<div>手动分配和动态分配的地址也是虚拟地址吗？</div>2022-11-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg" width="30px"><span>苏流郁宓</span> 👍（0） 💬（1）<div>cpu给定低16位（64kb内的）可做为端口，物理设备开发商可以通过端口方式直接与cpu沟通（可绕过操作系统，不需要操作系统分配地址，但估计会引发中断方式来被操作系统知悉？）也可以通过设备软件加载在内存上通过进程&#47;线程，来与cpu沟通（需要操作系统分配地址）</div>2022-09-17</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/zxrG3SKctHcdRcCw5Z3W5Ur0Opaziaj6r6otPpmzZrdIFf5Ref5dyEZQALa7DXn3ViaeWiaTiaeghQA4R5ib8x74JYg/132" width="30px"><span>lji</span> 👍（0） 💬（0）<div>当然了，除了这种方式，你可以在程序代码中直接给出一个地址，代码如下：int main(){ &#47;&#47;把整数0x20000强制转换为int类型的指针 int *p = (int*)0x20000; *p = 0; &#47;&#47;动态分配一个int类型大小的内存空间，其首地址返回给addr指针 void* addr = malloc(sizeof(int)); return 0;}这段代码就是让 p 直接指向 0x20000 地址，然后向这个地址上写入 0。不过这个操作极其危险，除非你确切地知道自己在干什么，因为 0x20000 可能是其它重要数据，也可能不是真正的内存单元，而是设备寄存器，更可能什么也没有，即这个地址没有连接任何有效设备。

请教一下，关于上述的文章内容，代码编译后运行在常见的操作系统下，不是必须通过虚拟内存来映射到主存，这段内容可否理解成：我强行让  MMU  把一个虚拟地址转成物理地址，转换后的地址不可控制，然后覆盖新的变量后可能发生异常。</div>2023-06-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/43/61/eeefa369.jpg" width="30px"><span>tony</span> 👍（0） 💬（0）<div>老师，您好，请教一个问题；malloc 分配一个内存地址A以后，然后free A，此时访问A程序一定会崩溃。这个崩溃是谁触发的呢？cpu？还是libc的ptmalloc，还是操作系统？
调用malloc时，ptmalloc会从系统中已经申请的地址空间中，分配一段虚拟地址，然后把首地址返回。free时，应该是标记了以该地址为首的区域没有人使用了。此时再来访问这个地址时，cpu mmu模块会转换为物理地址（如果没有找到该物理地址，应该会产生缺页终端，加载页并与虚拟地址绑定在一起）；按照这个逻辑，访问这个地址应该不会崩溃呢？谢谢。</div>2022-12-15</li><br/>
</ul>