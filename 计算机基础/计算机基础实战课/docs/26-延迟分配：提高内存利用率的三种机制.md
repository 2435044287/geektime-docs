你好，我是LMOS。

通过前面的学习，我相信你已经感觉到了物理内存资源的宝贵。为了尽可能有效利用它，操作系统在内存管理上花了很多心思，之前学过的虚拟内存、虚实结合的故事也佐证了这一点。

为了提高内存利用率，还有一些巧妙的机制等待我们探索。今天我就跟你聊聊其中的三种“玩法”，分别是写时复制、请求调页和mmap系统调用。这节课的代码，你可以从这里下载。

## 写时复制

什么是写时复制呢？用极为通俗的语言可以这样概括：写时复制是一种计算机编程领域中的优化技术（Copy-on-write，简称COW）。

其核心原理是，如果有多个应用同时请求相同资源，会共同获取相同的指针，指向相同的资源。这个资源或许是内存中的数据，又或许是硬盘中的文件，直到某个应用真正需要修改资源的内容时，操作系统才会真正复制一份该资源的专用副本给该应用，而其他应用所见的最初资源仍然保持不变，操作系统使得该过程对其他应用都是透明的。

COW的优点是，如果应用没有修改该资源，就不会产生副本，因此多个应用只是在读取操作时可以共享同一份资源，从而节省内存空间。

关于COW的原理，我们先说到这里。接下来，我们研究一下实际的Linux系统是如何应用COW的。
<div><strong>精选留言（6）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/2c/b9/32/c6177eb3.jpg" width="30px"><span>一个要强的男人</span> 👍（3） 💬（1）<div>对于mmap而言，如果我对某个2G的文件进行顺序读，那么也应该到最后是把整个2G的文件加载到内存了吧。会出现因为内存不足导致之前读取过的数据已经被释放的情况吗？</div>2022-12-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg" width="30px"><span>功夫熊猫</span> 👍（3） 💬（1）<div>感觉像redis之类的数据库也可以使用mmap来增加性能</div>2022-10-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg" width="30px"><span>一个工匠</span> 👍（2） 💬（1）<div>老师写的很棒。</div>2022-09-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg" width="30px"><span>TableBear</span> 👍（2） 💬（2）<div>有个小疑问请问一下老师：
COW的写入只读内存页的时候触发的缺页异常，还有mmap的的两次缺页异常，中断处理程序是怎么跟普通的缺页异常区分开的。它们调用的都是同一个中断处理程序吗？是通过特殊的状态位吗？</div>2022-09-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg" width="30px"><span>苏流郁宓</span> 👍（2） 💬（1）<div>写时复制的目的是减少不必要的调页，更好的利用内存空间，调页要引发中断，缺页异常，操作系统分配新的页？
由于程序的局部性原理，总有一部分数据会被重复利用！利用写时复制，在cpu层面，减少维护数据一致性浪费的时间，提高cpu的效率（包括寻页址浪费的时间（cpu要扫盘））
但在应用上具体问题具体分析，内核区cow肯定大大方便了！但如果是多核呢？在非内核区的应用层，多核加内存条容量大。二八定律的反面（长尾理论），看似在单核上的节俭到多核未必节俭的啊！（其它核晒太阳？）
这也是哈佛结构在局部应用领域优于冯诺依曼结构，如果进程过多，时间轮片（每个进程执行一会）会越来越吃力！
在分支预测层面，0.99的预测率多乘几次会发现，高不到哪里去！这就体现多核的优势，复杂问题简单化，每个核运行不同线程，减少分支预测次数！
在内存管理上，写时复制混序用得过于频繁（中途假如需要反复换数据），在庞大的线程排队面前，还不如多开几个页面，更好的利用写时复制（不同类型不同页面）的优点，又减少了线程排队的时间！
最后吐槽的新笔记本的x64cpu，不知是win操作系统还是cpu问题，不直接支持32位程序运行了！说明大名鼎鼎x86的cpu也不是固有印象，也在寻求变化！
但说实话，并发等还处在增长阶段，操作系统和cpu估计还会相亲相爱共同进化下去，大胆假设，小心求证！俺不怕说错出丑！</div>2022-09-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg" width="30px"><span>peter</span> 👍（0） 💬（1）<div>请教老师几个问题：
Q1：A应用和B应用返回的pid为什么是一样的？
文中提到“应用 A 调用 fork 返回的 pid 与应用 B 调用 getpid 返回的 pid，是完全一样的”，但A返回的是61618，B返回的是61819，是不同的，为什么说是相同的呢。
Q2：fork后，B应用的页表设置为只读，那A应用的页表也是只读吗？
Q3：fork后，B应用有写入采摘后会分配物理内存，同时还把A应用的内容拷贝到B应用，
这个拷贝有什么意义？B应用是另外一个程序，有自己的数据，为什么需要A应用的数据？</div>2022-09-23</li><br/>
</ul>