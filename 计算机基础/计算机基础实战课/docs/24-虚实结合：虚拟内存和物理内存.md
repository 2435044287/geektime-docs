你好，我是LMOS。

上一课中学习了内存地址空间，我们搞清楚了内存地址与地址空间的本质。

今天我们开始学习虚拟内存与物理内存。其实虚拟内存也好，物理内存也罢，我们从储存并索引数据的角度来看，内存的重要组成部分就两个：一个是地址，另一个就是储存字节单元，即能存放8个二进制位的容器。把两者合起来，我们可以将内存理解为能索引到具体储存字节单元的地址集合。

这节课我会带你解决以下三个问题：

1.虚拟内存的本质是什么？  
2.物理内存是什么，它的结构长什么样？  
3.虚拟内存如何与物理内存结合在一起，真正实现储存数据的功能？

课程配套代码你可以从[这里](https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson24)下载。让我们带着上面的问题，正式开始今天的探索之旅吧！

## 虚拟内存

上节课我们了解了内存地址的产生方式，以及应用程序的链接过程，也知道了内存就是能索引到具体储存单元的地址集合。但是程序中的地址能否索引到具体储存单元呢？具体的储存单元，又是如何分配的呢？下面我们用两个问题来说明其中的原理。

### 第一个问题

我的第一个问题来了，应用程序中使用的地址是什么内存地址？是不是感觉情况有很多种，一时很难回答清楚？遇到这种状况不要慌，我们只要动手写一个简单的程序就可以验证。

好，我们立刻动手写一写，代码如下：
<div><strong>精选留言（9）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg" width="30px"><span>苏流郁宓</span> 👍（4） 💬（2）<div>页表索引数据放在内存条的高位处，靠近内核区（不知是不是一定要紧邻）
MMU可理解为用多少物理资源给多少物理资源，但这也导致内存条上分布容易碎片化，为了减少碎片化。估计操作系统得做更多的工作！
由于在保护模式下，cpu指令分级，那么内核区的页表数据用得更频繁（其它应用软件需要调用），所以内核区的页表结构应趋向于稳定（开机一直在），而应用区的页表则用多少给多少（容易碎片化），也可以理解为内存条页表真实关系等于y=f（x）（注：应用区加页表索引区）+c（内核区，接近常数 开机一直在内存条上）</div>2022-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg" width="30px"><span>温雅小公子</span> 👍（2） 💬（1）<div>同学的思考能力好强啊，自觉弗如远甚，成功的聪明人课可太多了，我得为笨蛋争口气。</div>2022-10-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg" width="30px"><span>温雅小公子</span> 👍（2） 💬（1）<div>页表需要给多个进程共享，应该在内核临界区的PCB中，程序去仿存的时候除了最后访问内存中的目标数据，还会访问几次（如果没有应用快表，看是几级页表）内存中内核区的临界资源。
此外为了防止地址越界，一定存在一个页表寄存器存储页表的起始地址和页表长度。</div>2022-10-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg" width="30px"><span>功夫熊猫</span> 👍（2） 💬（1）<div>首先这个地方要能够共享给所有进程(因为这个页表索引肯定是全局唯一的)，还要拥有一定的权限才行（涉及到了更底层的系统调用和数据结构），按照内存分区就只能是内核区了</div>2022-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg" width="30px"><span>温雅小公子</span> 👍（1） 💬（1）<div>除了基本分页存储管理，我还听说过几本分段存储管理，段页式存储管理，以及带快表的分页、分段、段页式存储管理。</div>2022-10-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/11/fa/e0dcc1bf.jpg" width="30px"><span>榕</span> 👍（1） 💬（2）<div>老师，进程的页表结构是不是只要为顶级目录基址分配一个虚拟地址就行（其他部分不需要虚拟地址）。我理解只要对这个基址做好物理地址映射（cr3寄存器需要），虚拟地址转换过程就可以通过物理内存的页表结构找到对应的物理地址。进程对其他部分的页表结构并不关心，因此不需要为它们分配虚拟地址，不知道这个理解对不对，望老师解惑，谢谢。</div>2022-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg" width="30px"><span>TableBear</span> 👍（1） 💬（3）<div>思考题：
由上文可知，虚拟内存地址可以看成是一个进程的可访问内存空间。故页表的数据应该是放置于进程控制块（PCB）中。当进程不处于运行时，PCB会记录页表的存储位置。当进程处于运行状态，页表地址会被加载进页表寄存器PTR中。</div>2022-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg" width="30px"><span>peter</span> 👍（0） 💬（1）<div>请教老师几个问题：
Q1：对于虚拟地址是逐条转换吗？
一个程序通常指令、数据都很多，会对应很多虚拟地址，如果CPU拿到每个虚拟地址都交给MMU来转换，即逐条转换，岂不是很慢？这会降低运行速度吧。
Q2：MMU属于CPU吗？
我一直认为MMU是独立于CPU的，但文中有一句“这个函数用硬件实现出来，就是 CPU 中的 MMU”，这句话意味着MMU是CPU中的一部分。
Q3：应用程序运行之前会加载到物理内存，加载到物理内存的代码段中，存放的还是虚拟地址吗？会不会根据所在物理内存的首地址把程序的虚拟地址都变成物理地址？</div>2022-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/56/ab/ca6b7e69.jpg" width="30px"><span>Present</span> 👍（0） 💬（1）<div>fork创建进程时，会通过pgd_alloc创建一级页表，这里调用了__get_free_page(GFP_PGTABLE_USER)从伙伴系统中分配内存。然后复制父进程页表时也会根据需要依次创建二级、三级等页表。所以页表的数据最终是在物理内存中的。从GFP_PGTABLE_USER标志可以看出分配的内存是在ZONE_NORMAL及其下面的内存区域。

内核一级页表是在swapper_pg_dir里，是在系统启动时建立起来的一级页表，在物理内存1M以上的一块内存区域。
所以页表数据是在物理内存中的。</div>2022-09-20</li><br/>
</ul>