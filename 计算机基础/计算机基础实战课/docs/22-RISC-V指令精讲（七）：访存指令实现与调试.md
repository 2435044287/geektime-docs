你好，我是LMOS。

上节课我们说了RISC-V是加载储存体系结构的典型，只有加载指令和储存指令才有资格访问内存。

计算机运算完成的结果，一开始会放在寄存器中，但最终归宿还是内存，此时就需要存储指令发挥作用了。这节课我们就来看看RISC-V提供的存储指令，一共有三条，分别是储存字节指令、储存双字节指令和储存字指令。

课程的代码你可以从[这里](https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson21~22)下载。话不多说，咱们进入正题。

## 储存字节指令：sb指令

我们先从储存字节指令，即sb指令学起。

这个指令存储的字节单位是一个字节，也就是8位数据。说得再具体一些，这个指令会把一个通用寄存器里的低\[7:0]位，储存到特定地址的内存单元里。而这个特定地址，要由另一个通用寄存器和一个立即数之和来决定。

储存字节指令的汇编代码，书写形式如下所示：

```plain
sb rs2,imm(rs1)
#sb 储存字节指令
#rs2 源寄存器2
#rs1 源寄存器1
#imm 立即数（-2048~2047）
```

**上述代码中rs1和rs2可以是任何通用寄存器。立即数imm为12位二进制数据，其范围是-2048~2047。**因为rs1、rs2以及立即数imm的规定，对后面的sh指令和sw指令同样适用，后面我就不重复说了。

sb指令完成的操作用伪代码描述是这样的：
<div><strong>精选留言（3）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg" width="30px"><span>苏流郁宓</span> 👍（1） 💬（2）<div>好像上一节问过，储存字节指令，双字节指令，字指令。数据符号可以通过指令翻译来实现，没必要在储存环节特意把有符号和无符号数据分开储存的啊</div>2022-09-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/ae/c3/d930693b.jpg" width="30px"><span>LockedX</span> 👍（0） 💬（1）<div>既然加载指令已经解决了符号数的问题，存储就不用管这个问题，就存储二进制数据就可以啦</div>2022-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/db/88/cc6078eb.jpg" width="30px"><span>Bean</span> 👍（0） 💬（0）<div>加载指令，CPU无法预测该怎么补高位，于是需要编译器&#47;程序员通过不同指令来区分。而存储指令，CPU只需要截取不需要的高位，简单粗暴，截多少是编译器&#47;程序员的事情，截错了也是编译器&#47;程序员的锅，不是CPU的执行问题。</div>2023-01-16</li><br/>
</ul>