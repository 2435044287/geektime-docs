你好，我是LMOS。

我们在前面已经设计了我们的OS架构，你也许正在考虑怎么写代码实现它。恕我直言，现在我们还有很多东西没搞清楚。

由于OS内核直接运行在硬件之上，所以我们要对运行我们代码的硬件平台有一定的了解。接下来，我会通过三节课，带你搞懂硬件平台的关键内容。

今天我们先来学习CPU的工作模式，硬件中最重要的就是CPU，它就是执行程序的核心部件。而我们常用的电脑就是x86平台，所以我们要对x86 CPU有一些基本的了解。

按照CPU功能升级迭代的顺序，CPU的工作模式有**实模式**、**保护模式**、**长模式**，这几种工作模式下CPU执行程序的方式截然不同，下面我们一起来探讨这几种工作模式。

## 从一段死循环的代码说起

请思考一下，如果下面这段应用程序代码能够成功运行，会有什么后果？

```
int main()
{
    int* addr = (int*)0;
    cli(); //关中断
    while(1)
    {
        *addr = 0;
        addr++;
    }
    return 0;
}
```

上述代码首先关掉了CPU中断，让CPU停止响应中断信号，然后进入死循环，最后从内存0地址开始写入0。你马上就会想到，这段代码只做了两件事：一是锁住了CPU，二是清空了内存，你也许会觉得如果这样的代码能正常运行，那简直太可怕了。

不过如果是在实模式下，这样的代码确实是能正常运行。因为在很久以前，计算机资源太少，内存太小，都是单道程序执行，程序大多是由专业人员编写调试好了，才能预约到一个时间去上机运行，没有现代操作系统的概念。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132" width="30px"><span>Geek_a5edac</span> 👍（9） 💬（2）<div>之前看过深入理解linux内核，但缺少模型上的分析，从书本从头看到尾反反复复最终似懂非懂，看了该系列整体上清晰多了，有了比较清晰的知识结构。而且因为之前有了解过相关概念，所以看此篇很快，倒没啥压力了哈哈</div>2021-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/11/7c/bf5049b3.jpg" width="30px"><span>Freddy</span> 👍（19） 💬（1）<div>这节CPU三种工作模式，确实信息量比较大；
第一遍扫完后，发现好多细节都没有太懂；
第二遍精读，每句话，每个图，每行代码都一一理解后，再往下进行，龟速，需要很好的耐心，中间偶尔还要停顿信息，放松下大脑。这一边用了2-3个小时；
现在终于有感觉了；

看到长模式下，段描述符中不在有段基地址和段内偏移，就会去想那如何用段描述符定位内存中的数据呢？
这时就想到了操作系统里面的页面。。。
果然下面的文字就提到了MMU和TLB
激活了我多年没有用过的操作系统课知识点
</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f7/36/ccf3b5d1.jpg" width="30px"><span>Vic</span> 👍（233） 💬（16）<div>看了今天的课程和同学们的留言让我百感交集。

人的一生时间有限，无法什么都做到极致。但在摸索的过程是可以什么都去碰一下，才知道自己喜欢什么。我以为我不是那么喜欢计算机。我不是本科，是念电机工程的，已算是很相近的，比起念化学或是文史哲商等。但我仍然用了一堵高墙将自己围住，说自己不是纯正计算机本科的。
二十年前刚开始工作时有机会接触8051控制器，是用8051的汇编代码，花了不少时间把中断、寄存器研究过、因为8051只有8位元，相对简单，但没有操作系统，我开始对操作系统有兴趣，就开始自学x86的操作系统，买书来看，但真的看不懂，当时也没有互联网上这么多讯息，还买了minix的书来看，英文的书有多了一层外文的障碍，因为工作忙，也没实际用到，就这么放下了。

最近看到老师的这专烂，让我想到之前放弃了的操作系统的学习。
老师讲的实在太好了，给100个赞都不够。因为他是亲身实践过，而且表达力极佳。
过去不懂的，开始有一点看得懂了。但是真的是单纯因为老师讲的好我才看得懂吗？
看到底下很多同学的留言，让我想起二十年前的自己。
这过程有点像是小学的数学学不明白，到了中学再回头看，竞然明白了。
其实是自己的理解增加了，我不想用聪明这个字，会误导很多人。
纠结在自己有没有天份。
我很认同老师在底下同学留言的回覆。

&quot;不需要前置的知识&quot;，&quot;多看几遍&quot;，&quot;如果看到一个新东西 ，不要在意它叫什么，它叫什么都可以，而是要在意它是干什么的，它有什么作用。有了整体思路，再去扣细节。&quot;

也不存在着需要什么条件，常常就是这种条件，自己把自己绊住了，
以为自己没有达到，就放弃了。或是就转移目标去完成那个条件，而忘了回来原来的操作系统的学习。
很多时候困难全是自己想出来的。觉得难，这是很正常的。
不必要对自己太严苛。可以稍微休息一下(我说稍微不是二十年)，做一下别的事，再回来。
每个人的情况都不一定，没有一个固定的方法或是习惯，只有问你自己。
因为太难就放弃，那就太可惜了。可以慢一点没关系，不要放弃。
想想自己为什么来上这个课，想要从这个课得到什么？
如果是加薪，升官，学分或是为了下一门课会不会压力很大？
如果只是因为好奇，这看起来还挺有趣，想了解一下，会让你更挺得住这些困难。
因为有这些难点本来就很正常，克服了，弄懂了一个信心就会增加，就会继续前进，
如果一开始不去克服那个难点，选择逃避或是绕路，那永远就是在原地打转。

如果这一篇让你觉得鸡汤或是说教，那不是我的本意。只是将自己过去有感而发写下的。我也还在学习。
谢谢老师带来亲身实践后这么精彩的课程，也谢谢同学们对我的启发，共勉之~</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（161） 💬（4）<div>稍微总结一下：

1、x86 CPU的位数越来越高，从16到32到64，每次进步都尽量的去兼容了之前的CPU架构，所以：
A、16位时寻址能力不足，所以要借助额外的寄存器进行1M空间的寻址；32位时，每个程序都有自己独立的4G寻址空间，操作系统用低位的1G-2G，其余留给用户程序；64位后，暂时就遇不到寻址能力不足的事情了；
B、前一代的寄存器尽量保留，不够用就扩展新的
C、寄存器的长度升级后，其低位可以兼容上一代的寄存器

2、CPU同时在安全性上也要提升，从只有实模式【可以随意执行全部CPU指令，内存可以直接通过物理地址访问，随意访问随意读写】，到了32的保护模式【将指令划分为ring0到ring3，CPU指令不是你想调用就能调用；内存不是你想访问就能访问，首先CPU要允许，而且操作系统允许】，而64的长模式在安全方面与32并没有本至区别；

3、从实模式到保护模式，访问内存时，需要访问的地址变大了，需要控制的内容变多了，于是引入了段描述符，所有的段描述符组成了描述符表，包括唯一的全局描述符GDT和多个局部描述符号LDT。GDT是操作系统特供，要重点关注。CPU寻址的时候，要通过段寄存器+GDTR寄存器定位到的内存中的描述符，判断是否允许访问。然后，再根据段描述符中地址进行访问。

4、同时内存中内存管理有段、页、段页三种常用模式。一般在应用层，程序员感受不太到，操作系统全给咱们做完了。

5、中断，其实是通过硬件或软件方式告诉CPU，来执行一段特殊的代码。比如咱们键盘输入，就是通过硬件中断的方式，告知操作系统的。在实模式下，中断是直接执行的。但到了保护模式和长模式下，就要特权级别校验通过才能执行，所以引入了中断门进行控制。在ring3调用中断一般是要通过操作系统切换到内核态ring0进行的，与内存类似，要通过中断向量表，确认中断门中权限是否允许，然后定位到指定代码执行。

6、BIOS引导后，系统直接进入最简单、特权最大的实模式；而后告知CPU，切换到保护模式，并运行在ring0。后续的用户进程，一般就在ring3，想执行特权指令要通过操作系统来执行。</div>2021-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/e9/f25cce9e.jpg" width="30px"><span>李军</span> 👍（2） 💬（5）<div>汇编看不懂，还有x86平台也不懂，请问可以从哪里入手下？</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/e9/f25cce9e.jpg" width="30px"><span>李军</span> 👍（60） 💬（10）<div>搞java的我，表示没看懂</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg" width="30px"><span>pedro</span> 👍（171） 💬（24）<div>这篇文章信息量很大，但是问题比较简单，我先回答一下问题吧。
实模式下的寻址空间跟地址总线的个数是密切相关的，早期的 x86 物理机，虽然寄存器是 16 位，但是地址总线却有 20 根，根据计算 2^20 = 1M，寻址空间肯定得有 1M 啊，但是寄存器只有 16 位，即 2^16，没有这么大的空间啊，臣妾办不到啊～
那怎么办呢？聪明的 intel 工程师（挖坑师）想到了一个办法，即段寄存器左移 4 位，然后加上另外一个通用寄存器的值就可以组合出这个 20 位了，即 2^16 * 2^4  + 2*16，哦嚯一下子组装出来了。
这样 20 根地址总线都用上了，得到了 1M 的寻址空间，可把工程师给乐坏了。
但是，后面的事情大家都知道了，16 位不够了，32 位也不够了，在 64 位的情况下，完全不用考虑地址空间的大小问题了，变成了内存不够的问题了，而这个时候，保护模式下的虚拟地址映射又完美解决了这个问题（虚拟地址后面有），哟嚯，又把 intel 的这群挖坑师给乐坏了。 </div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/66/11/f7408e3e.jpg" width="30px"><span>云师兄</span> 👍（12） 💬（1）<div>内容硬核，已啃三遍！</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/ee/11/a92b6846.jpg" width="30px"><span>马杰</span> 👍（28） 💬（4）<div>看到后面，回头再看一遍，记点笔记。

实模式，保护模式，长模式，逐渐演进

1、实模式：
(1)代码段地址+左移4位+ IP = 取指
数据段+左移4位+ 通用寄存器值 = 数据地址
栈段SS+左移4位 + SP = 栈地址
(2)实模式中断：
中断号+ IDTR 寄存器(指向中断表的地址和长度)  ---&gt; 根据中断号，找到中断表中的对应条目 ---&gt;  解析出中断函数基地址填充CS、中断函数偏移填充IP ---&gt; 响应中断。

2、保护模式：
(1)保护模式寄存器：通用寄存器，IP，SP 16位-&gt;32位。添加了EFLAGS cpu标志寄存器和几个cpu控制寄存器。 CS DS SS 中改为存放内存段的索引，用于寻找内存中的段描述符。
(2)保护模式下，R0 -- R3的特权级别访问。通过内存中存放64位段描述符实现特权划分，段地址寻址。
 CS | DS | SS （段描述符索引）+ GDTR（指向全局段描述符表基地址）  -- &gt; 找到段描述符 --&gt;  解析代码段还是数据段，地址，访问权限
 其中影子寄存器 :  通过硬件实现，是段描述符的高速缓存, 防止反复读内存，提高效率。
 权限问题：当前执行程序的CS RPL、SS RPL = CPL,  要访问的段描述符中拿到DPL， CPL &gt; DPL 禁止程序访问目标段， CPL &lt;= DPL , 可以访问
(3)保护模式的平坦模型: 段基址为0，段长度为4G的特殊段管理模式，规避历史原因导致的分段模型缺陷。
(4)保护模式中断:中断号+ IDTR 寄存器(指向中断表)  ---&gt; 根据中断号，找到中断表指向的内存中的中断门描述符 ---&gt; 中断门和中断描述符中段选择子的权限检查--&gt; 中断门描述符中目标代码段选择子填充CS， 目标代码段偏移填充EIP ---&gt; 响应中断。
权限问题：当前CPL小于等于中断门DPL，才可进中断门，当前CPL，大于段选择子的DPL，则设置CPL=段选择子DPL。
例：当前运行代码CPL=R3级别，遇R3中断门进门，执行特权级中断程序R0，此时CRL=R0。

(5) 切换保护模式： 准备全局描述附表GDT， 
		GDTR指向GDT， 
		设置CR0开启保护模式，
		执行长跳转,CPU根据8索引值索引GDT中第二条数据，加载CS


3、长模式：
（1）寄存器扩展到64位
（2）长模式段描述符, L=1，D&#47;B=0 时是64 位代码段， L ， D&#47;B, 无效是数据段
（3）长模式中断：中断们描述符比保护模式多了8字节64位，用于存放64位的目标代码段偏移多出来的高32位。 
		其他中断过程同保护模式。
（4）长模式切换：准备长模式全局段描述符表,
		准备长模式下的MMU页表,开启分页模式
		CR3指向页表物理地址
		GDTR指向全局段描述符表
		IA32_EFER寄存器第8位开启长模式，CR0寄存器= 0x31开启保护模式和分页模式
		进行跳转，索引GDT， 加载 CS 段寄存器，刷新其影子寄存器

（5）长模式弱化段模式管理，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 MMU，分页管理。

</div>2021-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/3d/53/9d8a1207.jpg" width="30px"><span>尼欧</span> 👍（26） 💬（4）<div>建議大家讀讀李忠老師的《穿越計算機的迷霧》，學習一點硬件原理，對後續學習會有很大幫助。很薄的小冊子，三兩天就能讀完。</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/1c/37/3b5cffa0.jpg" width="30px"><span>繁雨落❤伤</span> 👍（12） 💬（1）<div>顶不住了🥲</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/40/0c/19b4224a.jpg" width="30px"><span>不写出操作系统不改名</span> 👍（9） 💬（2）<div>之前我一直想不明白，为什么段寄存器里面的值左移4位再加上16位的偏移地址就能访问全部的1M空间了。为什么不直接借用段寄存器里面的高4位或是低4位，或是其他体位的4位来和另一个寄存器的16位凑成20位去访问，因为这样拼凑位的作法很多地方都有，这样也是20位啊。干吗非要左移4位呢？段寄存器左移之后的值表示什么意思呢？回答这些问题可以这样想，段寄存器里面的值相当于是一个索引值，把它左移4位相当于乘以了16。即段寄存器值为0，对应物理地址上是0，段寄存器的值为1，对应物理地址为0x10H。。。。以此类推。也就是说，20位地址总线能访问的1MB空间里，每隔16个字节就是一个段的起始位置。只要使用段模式管理，那么每个段的起始位置就固定死了，地址值是16的倍数的都可以作为一个段的起始地址。然后再配合另一个寄存器的16位偏移，这样的话，在最大64k的段内空间，理论上就会出现和很多个其他的段重叠，应该是有64*1024&#47;16-1个段，当然我们可以贴心的选择让不同的段与段之间避开重叠，这只是做不做的问题，而不是能不能做的问题。如果向左偏移5位，那就是2^5=32，即每隔32个字节就是一个段的起始位置。</div>2021-11-05</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDXstrzRuSBwWkrOBzb7iaGVF7HibUZP2NVnaX2vgiaRYYIfYSqOEbY1f316fZFVj0G5zcV1UkRJ57Q/132" width="30px"><span>Xavierhu</span> 👍（9） 💬（2）<div>实模式下：段基地址左移4位，形成20位基地址。然后加上偏移量16位，最终形成20位物理地址……可寻址1MB</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/80/74/952d11dd.jpg" width="30px"><span>刘恒</span> 👍（8） 💬（3）<div>像天书。。。</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/d6/da/bd7e7780.jpg" width="30px"><span>小灰灰。</span> 👍（6） 💬（1）<div>解决了读其他书留下的不少困惑</div>2021-05-19</li><br/><li><img src="" width="30px"><span>Geek_8f064e</span> 👍（5） 💬（2）<div>这一章就是一本书啊</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0b/39/e05b4f74.jpg" width="30px"><span>LIUYU</span> 👍（4） 💬（2）<div>实模式下能寻址多大内存空间？ 答案是可能是4G，也可能是1M. 为什么呢，老师也讲过段寄存器的影子寄存器，实模式下你要看你的影子寄存器里面的base 和 limit。 目前主流的CPU 开机是实模式，但是他执行的地址是在FFFF FFF0 处,远超实模式下的1M. 这是因为reset的时候CS base 是0xFFFF0000  IP是0xFFF0. limit 是0xFFFF.  所以也可以实验一下，如何在实模式下访问1M以上地址空间。BIOS在intel 平台上都叫UEFI 了。支持64bit都快20年了，而且跳到OS，可以参考boot protocol， 目前主流像linux 直接进入EFI_STUB64 入口了。希望老师普及一下这些知识，以目前intel平台，uefi直接64bit flat跳入到内核，内核也直接工作在64bit了，况且intel 不是也宣布2020年之后不支持legacy bios。</div>2021-05-26</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132" width="30px"><span>LT</span> 👍（4） 💬（1）<div>提一个建议，理工科的东西不自己动手，是无法完全弄懂的。老师能不能部署一些上机的题，有兴趣的同学可以做一下，然后分享，老师来评点和提改进议见。对于其它人也是一次学习的机会。</div>2021-05-22</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132" width="30px"><span>LT</span> 👍（4） 💬（1）<div>这三个模式讲得好，讲清了问题的根源。对于以前没有研究这个东西的同学来讲，这讲的确难。

“最后做权限检查，如果 CPL 小于等于中断门的 DPL 并且 CPL 大于等于中断门中的段选择子，就指向段描述符的 DPL。”
如果CPL=3， 中断门的 DPL=3， 中断门中的段选择子的RPL为0，相当于从用户态到内核进行了一次调用；
但如果CPL=0， 中断门的 DPL=0， 中断门中的段选择子的RPL为3，这应该是非法的，系统会panic。有办法在内核态访问用户态的数据或者执行用户态的代码吗？如果有，其原理是如何的？</div>2021-05-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/32/5b/d0c7e813.jpg" width="30px"><span>luo</span> 👍（3） 💬（1）<div>虽然已经看过《趣谈linux操作系统》，里面的每一篇也是很硬核，这篇给我的感觉是知识点更加具体化了（有点互补的感觉），也是啃了两三遍后搞懂了，一般硬核的第一遍都是比较模糊的，因为概念还比较新，结构也是第一次看，但只要仔细翻看两三遍，且完完整整做一遍笔记，整个知识点就通了，收获会很大，不要吝啬你的学习时间。</div>2022-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/ec/9c/7ff05224.jpg" width="30px"><span>知白</span> 👍（3） 💬（2）<div>好熟悉啊，我想起我那段时间看李忠老师的x86汇编：从实模式到保护模式。老师的这一章直接浓缩了那本书的大量章节。把各个知识点以这种方式整合在一起，高屋建瓴，实在是让我感到震撼。</div>2021-07-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/1d/97/9a8b2d0c.jpg" width="30px"><span>🙃</span> 👍（3） 💬（1）<div>刚读完一遍，真的是醍醐灌顶，感觉自己的知识面太狭隘了，这种好文不得读个四五遍，自己也在思维导图同步整理。希望跟着东哥一步一步探索操作系统的时间！！！（PS：感觉这专栏太有性价比了）</div>2021-06-20</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/dXf9e0gmVVV1ozqBIiaWiaxz1qgPZrYHT9x3ytnjfZ6quCH7gNtibXhsg66kH1E4FeTVHMB9J3PibNaMN2GthvceqA/132" width="30px"><span>Geek_032c4a</span> 👍（3） 💬（1）<div>请教下各位，文章中提到的中断门各种检查是CPU硬件做的还是软件做的？</div>2021-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg" width="30px"><span>送过快递的码农</span> 👍（3） 💬（1）<div>好家伙，前几章关于操作系统的，还看的过来，这个CPU相关的，我只能做如下总结：字都认识，组合起来就蒙圈了</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg" width="30px"><span>杨军</span> 👍（3） 💬（1）<div>当 CPL 大于目标段 DPL 时，则 CPU 禁止访问，只有 CPL 小于等于目标段 DPL 时才能访问。  这个CPL、DPL应该是CPL数值、DPL数值吧？</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/12/c0/be71c20f.jpg" width="30px"><span>嘤novation</span> 👍（3） 💬（1）<div>请问实模式切换到保护模式的第四步中根据索引值8 到底是什么数据</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/80/5b/9b8877ea.jpg" width="30px"><span>淡然道奇</span> 👍（2） 💬（1）<div>保护模式下的平坦模式可以理解为只有一个段吗，即GDT里只有一个表项</div>2022-07-04</li><br/><li><img src="" width="30px"><span>Geek_389328</span> 👍（2） 💬（2）<div>那些特权级的寄存器 大部分 都可以看作是 C语言里的指针变量，  那些什么表都是数组。 描述符都是数组中的元素。。
CPU就是进程，计算核就是同一进程中的线程   硬盘就是静态链表或者树  内存也是</div>2022-02-21</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwiaS5xWUFDPesZAfMvE4iavUCosZstpf9CNpwkic2prTJpa9FsPxIIsCxcJra5P0Cho32nmM3UaIHw/132" width="30px"><span>袁少荣</span> 👍（2） 💬（1）<div>唉，看来是不是我水平不够，没怎么看懂，捂脸：）  明天早上再多看两遍</div>2021-05-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg" width="30px"><span>会玩code</span> 👍（2） 💬（2）<div>请教下老师，之前还说段寄存器是16位，为什么在【保护模式段选择子]这块又说段寄存器能存下64位的选择子呢？</div>2021-05-21</li><br/>
</ul>