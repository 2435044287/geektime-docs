你好，我是LMOS。

我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。

在开发我们自己的操作系统以前，还不能一开始就把机器跑起来，而是先要弄清楚数据同步的问题。如果不解决掉数据同步的问题，后面机器跑起来，就会出现很多不可预知的结果。

通过这节课，我会给你讲清楚为什么在并发操作里，很可能得不到预期的访问数据，还会带你分析这个问题的原因以及解决方法。有了这样一个研究、解决问题的过程，对最重要的几种锁（**原子变量，关中断，信号量，自旋锁**），你就能做到心中有数了。

## 非预期结果的全局变量

来看看下面的代码，描述的是一个线程中的函数和中断处理函数，它们分别对一个全局变量执行加1操作，代码如下。

```
int a = 0;
void interrupt_handle()
{
    a++;
}
void thread_func()
{
    a++;
}

```

首先我们梳理一下编译器的翻译过程，通常编译器会把a++语句翻译成这3条指令。

1.把a加载某个寄存器中。

2.这个寄存器加1。

3.把这个寄存器写回内存。

那么不难推断，可能导致结果不确定的情况是这样的：thread\_func函数还没运行完第2条指令时，中断就来了。

因此，CPU转而处理中断，也就是开始运行interrupt\_handle函数，这个函数运行完a=1，CPU还会回去继续运行第3条指令，此时a依然是1，这显然是错的。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/a2/57/219503c1.jpg" width="30px"><span>xiaoq</span> 👍（2） 💬（1）<div># 单CPU下
业务函数和中断函数会存在并发访问同一资源
1. 对于简单资源(原型变量？)，可以把访问资源变成原子操作，使用带lock前缀的`addl subl incl decl`原子指令；
2. 对于复杂资源(复合类型变量)，可以把访问资源处业务函数关掉中断，保证此处是串行访问资源；需要解决嵌套问题，通过在关中断前使用pushfl、popl保存之前的中断状态，在下一次开启中断时恢复该状态；

# 多CPU下
除了每个CPU存在业务函数和中断函数并发问题，还存在不同CPU之间并发问题；
在保证单CPU使用同步的情况下，还需要保证多个CPU同步；
1. 简单资源的原子访问操作：个人理解是因为锁了总线，所以单个、多个CPU均适用；
2. 自旋锁：关键指令xchg，确保 read(if) &amp; set 在多个CPU之间是原子的

# 信号量
在复杂的上下文中保护多个复合资源
使用spinlock和wait_queue以及resource_count实现等待、互斥、唤醒


使用方法
&#47;&#47; spinlock
spinlock_t spinlock;
spinlock_init(&amp;spinlock)

&#47;&#47; cpu转圈圈，直到获取锁
spinlock_lock(&amp;spinlock)
&#47;&#47; dosomething()
spinlock_unlock(&amp;spinlock)

&#47;&#47; semaphore
sem_t sem;
sem_init(&amp;sem);

&#47;&#47; 线程会休眠 直到拿到信号量
sem_down(&amp;sem);
&#47;&#47; dosomething()
sem_up(&amp;sem);
</div>2022-04-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/02/88/df790e16.jpg" width="30px"><span>lifetime</span> 👍（15） 💬（1）<div>看到楼上的各位都发表了那么多的总结，感觉你们都太厉害了！
我也跟着你们的脚步，谈谈我对这节课的理解：
1、对原子的理解：
抽象理解为一条指令，要么执行完成，要么没有执行
2、对中断的理解：
单个CPU中多个进程并发执行，是靠使用中断进行切换，关闭中断后，只有一个进程在执行这块临界区代码，其他进程无法切换执行，执行完这块代码后，再打开中断，再去切换到别的进程执行
3、对自旋锁的理解：
自旋锁解决多个CPU，多个进程并行执行的情况；
多个进程对同一个物理内存地址进行访问，先访问并判断为0的进程，进程加锁设置为1，执行临界区代码；
其他的进程陷入访问，判断为1的流程中，死循环；
执行完临界区的进程将地址设置为0，其他进程再去争抢
4、对信号量的理解：
信号量解决自旋锁中其他得不到执行的进程一直在轮询的问题，这个一直轮询会导致CPU无法切换到其他不需要执行该临界区的进程执行，效率低下；
所以引入能睡眠的机制，得不到的进程不让他们继续等了，先睡觉，负责其他进程执行的CPU去切换到别的进程执行；
等执行完临界区的进程OK后，再把这些睡觉的进程唤醒，他们再争抢
理解能力有限，只明白这么多，如果有不对的，麻烦指正！</div>2021-08-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/11/7c/bf5049b3.jpg" width="30px"><span>Freddy</span> 👍（12） 💬（2）<div>本节是关于共享数据的并发修改问题，总结了不同场景下的使用方式：
当共享数据是单体变量时，可以尝试使用原子操作指令；
当共享数据是复杂的数据结构时：
当是单CPU环境时，只有中断和业务进程两个代码操作流，此时我们可以手动控制CPU中断关闭&#47;开启，要注意解决CPU中断关闭&#47;开启的嵌套调用问题；
当是多CPU环境时，就不能同时控制多个CPU的中断了，此时我们用到了自旋锁；多个CPU进程竞争自旋锁，成功加锁的进程，可以执行自己的业务流程；这里要注意的是要保证自旋锁流程中的读取锁变量和判断并加锁的操作是原子执行的；
在多CPU环境时，没有获取自旋锁的CPU，就会一直在循环读取锁变量和判断是否加锁的流程当中，浪费了CPU资源，为了解决这个问题，引入了信号量；
首先，各个进程会去竞争信号量；
没有获取信号量的进程放入等待队列，这样该进程所在的CPU就可以去执行其他业务进程了；
获取信号量的进程执行完后，会释放信号量后，同时会去唤醒在等待队列中的进程，这样等待的进程就会再次去竞争信号量；
思考：
1.那一个进程中的多个线程并发修改共享数据的模型，应该也是同样的道理吧？？
2.锁，应该是操作的前提条件，有了锁才能去执行业务代码；
但对原子操作来说，好像是加锁和业务操作一起执行了。
</div>2021-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg" width="30px"><span>noisyes</span> 👍（6） 💬（1）<div>真的是把锁的前生今世讲得明明白白，让我有种豁然开朗的感觉！可能到最后可能无法独自实现一个操作系统，但是真的能从底层的角度重新认识操作系统！</div>2021-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4b/46/717d5cb9.jpg" width="30px"><span>惜心（伟祺）</span> 👍（12） 💬（1）<div>这个问题抽象下就是在如何在并行执行中做到串联有序
解决思路就两个：
1.在结果端（确保内存一致）
2.在过程端（确保cpu计算中不被打断）
原子性就是确保内存一致，但是因为cpu计算需要时间所以只能保证一个单位的绝对一致
至于锁、信号都是在对上面两种思路的组合，妙的是会出现跨代组合来实现更多样化的应用
老师从根本上分析问题，由简到繁，一下抓住根本和牛逼
其实操作系统就是对简单的功能的组合重复实现无限复杂操作
这种思路和软件开发是一致的，用一种语言API，各种的组合重复利用时间空间的重复解决各种复杂问题</div>2021-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/c6/e648d118.jpg" width="30px"><span>嗣树</span> 👍（39） 💬（4）<div>记录下我学习本节内容的一些思考：
1. 学习到这里还没有引入抢占这个概念，所以讨论环境中默认进程上下文不会发生抢占，同样也没有进程切换这些东西。
其实讲进程上下文也不对，我们都还没有引入这些东西，暂且凑合这么用吧。

2. 首先讨论了单 cpu 情况下，保证数据一致性的方式，这一时期我们主要防中断：
	- 对于单个变量我们实现了原子变量（由硬件提供支持），中断是不能打断这个操作的
	- 对于复杂变量的操作，这个时候中断可以乱入了，我们通过关中断来保证单 cpu 下这些数据的正确

3. 到了多 cpu 时代，不止有中断这个小三，还有隔壁老王（其他核），关中断已经不管用了，
为了数据的一致需要大家在操作前都走自旋流程，自旋需要新的原子操作支持（xchg），到此我们解决了老王带来的问题。

4. 但是我们还需要面对中断的问题，自旋锁的实现是带条件的死循环，这也引入了一个问题：死锁。
cpu 间的互相抢锁最多抢不到等一会，但是 cpu 和本地中断之间就不同了。

当本 cpu 占有了锁，此时打来中断，假如中断中也要抢这把锁，那他抢不到嘛，只好死给你看咯。
而中断也可以嵌套，这种情况也可能死。所以对自旋锁升级，添加了关中断的操作。

5. 最后老师介绍了信号量，这里其实已经带入了调度的概念。

6. 最后在思考一下抢占和中断优先级带来的问题，其实也还是死锁的问题。
上面我们设想了两种死锁的情况。我们泛化一下，其实中断可以看作比普通进程优先级更高的进程，
只要是构成这种 低级持锁，高级来抢 的局面都可能死锁。而抢占和中断优先级创造了更多的阶级，
也就产生了更多的可能。所以 Linux 中自旋锁的实现第一步是关抢占。

错误或疏漏的地方还请指正，抱拳了老铁。</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（36） 💬（1）<div>当前版本还有几个问题还没有解决，希望后面课程有进一步详解：
1、跨用户进程时，如何共享内核的同一个锁或信号量
2、没有提供锁的可重入不可重入的限制
3、锁自旋时不会让渡CPU时间
4、暂时没有提供公平锁算法
5、暂时没有提供乐观锁算法

基于本节，其实大家可以尝试一下：
1、信号量如何提供最大资源数限制
2、信号量如何提供扣除多个资源的支持
3、如何实现互斥量这一类数据结构呢
4、如何实现读写锁这一类数据结构呢

锁一般用来做线程间或进程间的互斥操作
信号量一般用来做线程间或进程间资源同步操作，比如资源的占用和释放等</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg" width="30px"><span>pedro</span> 👍（141） 💬（8）<div>今天的专栏可谓是精彩至极！
锁是解决并发同步问题的关键，从本文来看，锁有两个核心点，一个是原子操作，另一个则是中断；
通过原子操作来实现临界区标志位的改变，关闭中断来避免CPU中途离开导致数据同步失败问题。
自旋锁(spinlock)是锁的最小原型，其它锁都是以它为基础来实现的，自旋锁的实现也颇为简单，只需一个简单的原子标志位就可以实现了，当然还要妥善管理中断。
在 xv6 中，对锁的实现只有两种，一种是刚才提到的 spinlock，而另外一种则是 sleeplock，spinlock 不会让出 CPU 执行权，而 sleeplock 则是在 spinlock 的基础上，增加 sleep 功能，即如果一个执行体(线程或者进程)加锁失败，就会进入休眠状态，让出 CPU 执行权，让其它的任务也能得以执行。
本文中的信号量(sem)也是 sleeplock 的一种，sem 的实现更为精致，通过等待队列来记录加锁失败的执行体，并后续通过一定的策略来选择唤醒，这也是很多编程语言中信号量的实现方式。
当然不同的语言会有不同的优化，比如 go 的 Mutex 是非公平的唤醒机制，但是针对非公平的场景，又设有饥饿补偿，总之本文中实现的 sem 几乎是任何信号量（锁）实现的基础蓝本。

对于思考题答案，这里就顺便贴一下吧，如果有啥问题，欢迎大家交流指正：
  spinlock_t lock;
  x86_spin_lock_init(&amp;lock);
  &#47;&#47; 加锁，如果加锁成功则进入下面代码执行
  &#47;&#47; 否则，一直自旋，不断检查 lock 值为否为 0
  x86_spin_lock_disable_irq(&amp;lock);
  &#47;&#47; 处理一些数据同步、协同场景
  doing_something();
  &#47;&#47; 解锁
  x86_spin_unlock_enabled_irq(&amp;lock);


  sem_t sem;
  x86_sem_init(&amp;sem);
  &#47;&#47; 加锁，减少信号量，如果信号量已经为 0
  &#47;&#47; 则加锁失败，当前线程会改变为 sleeping 状态
  &#47;&#47; 并让出 CPU 执行权
  krlsem_down(&amp;sem);
  &#47;&#47; 处理一些数据同步、协同场景
  doing_something();
  &#47;&#47; 解锁，增加信号量，唤醒等待队列中的其它线程（若存在）
  krlsem_up(&amp;sem);
</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg" width="30px"><span>不一样的烟火</span> 👍（12） 💬（2）<div>锁用来保证资源的使用不被打断，打断的情况包括中断，其他cpu执行流，其他线程
保护的情况有原子操作，关中断，自旋锁，信号量
原子操作好比瞬时动作，动作只有一个，不被打断
关中断好比学习的时候关闭电话，不被分心，专心学习
自旋锁好比上厕所的时候锁上门，其他人只能在外面团团转，干着急，其他事儿干不了
信号量好比正在忙，门口挂个闲人免进，等自己办完事儿再通知他过来，他可以先去处理其他事情</div>2021-07-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/65/32/36c16c89.jpg" width="30px"><span>Geek_osqiyw</span> 👍（11） 💬（1）<div>原子变量，中断，自旋锁，信号量，层层递进，都是在前一个技术的某些场景无法满足的情况下，更高级复杂的解决方案，当然也是基于前面的基础的封装</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg" width="30px"><span>Feen</span> 👍（9） 💬（3）<div>尝试用自己的理解去消化一下本章的内容，用最少的文字在每句话表达出问题和核心和解决办法，不然显得自己都没好好学习：
1、几十年前的一开始，计算机内只有一个CPU，而且执行单道程序，因为当时的整机性能不强，操作方式是一次提交指令等待返回。每次执行任务都发现当前正在运行的程序内部有执行中被打乱的问题，设计程序的时候以为是按照人的思维来运算，实际发现有问题。所以增加了原子操作解决，要不全部执行，要不全部失败。那时候计算机执行任务的时候，程序员都站在计算机（还不能称之为现代电脑）面前，等待结果返回。
2、从各种其他设备开始接入计算机开始，为了解决这些设备也要在计算机运行时候的同时解决输入输出问题（这时CPU开始分时切片运行，表象显得可以同时运行多个程序），引入了中断的概念，CPU整个运行时间被分切为每个单位时间，单位时间之间可以持续运行同一程序，也可以打断运行其他程序，现代操作系统也开始初具雏形，区别与老计算机的标志就在于能否中断。
3、现代电脑蓬勃发展，电脑开始进入千家万户，中断的大量使用给用户提供了无限的可能，单核CPU的频率随着工艺和材料的提升也在提高，在奔腾时代（P2 P3 P4）你甚至可以在主板BIOS中设置中断。
4、万物逃离不了本质，单核CPU频率提升到一定幅度后开始减缓，频率不够，核数来凑。多核CPU进入视野，而中断只能锁定当前占有的那一个CPU核心，无法锁定其他CPU核心不去碰你执行的程序，既然无法通过中断达到锁定，因为你的程序在电脑内只会存在一个程序（如果你一个程序要多开，那通过不同的PID来区分，目前还未讲到，暂且不考虑），聪明的程序员又想到了锁你的程序变量，自旋锁开始使用(xchg)。
5、自旋锁的使用几乎是同时出现信号量，在使用自旋锁的时候确实排他了，但是CPU的工作却发生了变化，不止要执行当前用户程序中正在运行的那一部分代码，还得运行另一部分未执行的代码。同时还有长时间等待的问题。因为它旋转着呢，就如同排队上厕所一样，肯定得敲CPU的大门，问下前面那位占着茅坑的好了没，上不到厕所决不罢休。还好电脑不像人，没有三急来了就骂人的情绪，所以聪明的程序员又干了一件事：发筹子（count），好了叫你，没好的时候躺平。（从这里看出程序的主导权或者执行权，已经由代码本身，移交到外部信号量控制部分。）
6、总结：计算机经过这么多年的发展，从思路上可以看出 ，解决问题的方法就是先从单个示例下手，不管是原子操作，还是中断，还是自旋锁，还是信号量。当你解决了单个实例的问题，那就是从0到1质变，从1到99都是在此基础上的衍生，而从单个实例下手的入口点可以有多个，但从局部性原理开始考虑更轻松一点。</div>2021-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/50/66/047ee060.jpg" width="30px"><span>Return12321</span> 👍（5） 💬（1）<div>信号量理解，比如有微信、QQ、钉钉应用需要获取到键盘输入值：
1、初始化sem_count=1，sem_waitlst等待链为空；
2、通过键盘输入字符到缓冲区，并通过进程调度通知进程；
3、三个进程开始竞争，微信抢到，先给sem_lock加锁，此时QQ、钉钉的进程不能读取信号量，循环判断(自旋锁的逻辑)；
4、微信进程对sem_count执行判断sem_count不小于1(sem_count=1)，获取信号量成功，执行sem_count“减1”操作(sem_count=0)，释放自旋锁sem_lock；
5-1、QQ、钉钉进程此时能读取sem_lock自旋锁，此时钉钉抢到，则先给sem_lock加锁，获取sem_count值并执行判断sem_count不小于1，此时sem_count=0（小于1），钉钉进程进入等待状态，并将其挂入sem_waitlst中，释放自旋锁sem_lock。最后QQ进程重复5-1步骤，sem_count=0，sem_waitlst=[QQ, 钉钉]；
5-2、微信进程执行读取缓存区代码流操作；
6、微信代码流执行(读取键盘值)完成，先给sem_lock加锁，对sem_count执行“加1”操作(sem_count=1)，检查sem_count不小于1，则执行唤醒sem_waitlst 中进程的操作，标记信号量释放成功，给sem_lock解锁；
7、sem_waitlst=[QQ, 钉钉]中的进程重复从4开始的步骤。

文章中写的是先执行“减1”操作、然后sem_count和0判断，但从代码上来看，sem_count是先和1比较，然后执行“减1”操作。</div>2021-11-01</li><br/><li><img src="" width="30px"><span>K菌无惨</span> 👍（4） 💬（1）<div>感觉信号量好就好在与操作系统的进程&#47;线程调度整合在一起，所以就能够在没有资源时（即信号量等于0），触发进程调度，避免了自旋锁的CPU空转，在拥有资源时能够唤起对应的代码执行下去（即goto start_step）；而至于为什么要用到自旋锁，而不用普通的锁，估计只是因为自旋锁在临界区较短的时候效率更高。 不知道对不对</div>2021-06-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/fc/53/836c87d1.jpg" width="30px"><span>李yong</span> 👍（3） 💬（1）<div>之前没有学习过操作系统，看了两遍，总结一下自己的理解,。
1. 原子操作，可以解决单个变量并发问题。不管后续多核cpu还是单核cpu. 
缺点在于只对于单个变量有效。
实现方式，汇编lock.
汇编lock这种方式后续几种方法都会涉及到。
2. 中断。单核cpu时只有一个流，唯一可能的并发就是中断，关闭中断即可解决问题。
缺点，只对于单核cpu有效。
实现方式，关闭中断。
不管单核还是多核，都会存在中断引起并发的情况，所以后面两种方法都涉及关闭中断。
3.自旋锁。可以突破原子操作和中断的限制，即支持多个变量并发以及多核cpu. 额外增加锁变量，锁变量值为0还是1指使此时是否存在并发。存在并发时，循环判断此锁变量的值，直到其他并发结束。不存在并发时，对锁变量加锁。需要关闭中断避免中断的影响。
缺点，存在并发时，其他流一直试图获取锁变量，占用cpu资源。
实现方式，增加锁变量，指使是否存在并发。
4. 信号量。增加结构体，结构体中包含count信号量计数值和list用于挂载等待任务流列表。count为0，任务流进入休眠状态(释放出cpu, 可以调度其他任务流)。count为1.获取信号量，可执行后续操作，并将count置为0，表示已占用，执行完成后，将count加1，</div>2021-08-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg" width="30px"><span>青玉白露</span> 👍（3） 💬（2）<div>return (*(volatile u32_t*)&amp;(v)-&gt;a_count);

这里为什么非要这么复杂？
return v-&gt;a_count;
难道有问题嘛？还得要先取地址再取值</div>2021-07-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg" width="30px"><span>哇咔咔</span> 👍（3） 💬（2）<div>“x86 CPU 给我们提供了一个原子交换指令，xchg，它可以让寄存器里的一个值跟内存空间中的一个值做交换”
这里说xchg是原子的，那么为什么在xchg前面还要lock呢？</div>2021-06-06</li><br/><li><img src="" width="30px"><span>Geek_0c1f07</span> 👍（2） 💬（1）<div>中断嵌套问题那里，我想不明白：【开启中断函数】那里到底是怎么才能打开中断的？
比如嵌套场景如下：
场景：{关闭中断函数，(关闭中断函数，操作数据，开启中断函数)，操作数据，开启中断函数}。
根据代码，只有在关闭中断函数中，能改变内存中的eflags寄存器的标志。而开启中断函数中永远是使用内存中的eflags寄存器的，没有改变内存中的寄存器。那么在此场景中，根据第二个关闭中断函数，内存保存的已经是关闭中断的eflags寄存器，那么开启中断函数每次从内存中读的都是关闭中断的eflags寄存器。所以很矛盾，【开启中断函数】到底是怎么打开中断的？
望老师解答我的迷惑！</div>2021-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/37/56/3a527963.jpg" width="30px"><span>吴国豪</span> 👍（2） 💬（1）<div>单核cpu，切换进程必须通过中断，因此可以通过关中断来执行一些同步操作。
多核cpu，同步的数据可能会收到别的核心上的进程影响，因此不能仅仅通过关闭当前核心的中断来执行同步操作。因此通过自旋锁。自旋锁要么被获得，要么就一直循环的申请，直到被获得。
前面的同步操作，都要求锁的使用时间短，否则就会存在多个经常一直在等待某个进程，造成资源的浪费。信号量通过挂起的操作，让获取锁失败的进程，不再进行循环申请的操作，不再占用cpu资源。直到释放锁的进程，在释放的时候，才将挂起的进程释放，让他们进入竞争锁的状态。
</div>2021-07-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4f/b2/1e8b5616.jpg" width="30px"><span>老男孩</span> 👍（2） 💬（1）<div>java可以会把锁的状态值放到redis中，然后让redis执行lua脚本来保证执行的原子性。
加锁：  if redis.call(&#39;setNx&#39;,KEYS[1],ARGV[1]) == 1 
        then if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] 
		then return redis.call(&#39;expire&#39;,KEYS[1],ARGV[2])
		else return 0 end else return 0 end
		
释放锁：if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] 
        then return redis.call(&#39;del&#39;, KEYS[1]) 
		else return 0 end
		
用一个while循环，退出条件是加锁成功。在循环体中把当前线程挂起，并放到一个等待列表中。
获得锁的执行流，最后释放锁，并唤醒等待的线程去竞争锁。

学到这里，我算是明白为什么行业里边有一个鄙视链 ：搞汇编-&gt;搞C的-&gt;搞C++-&gt;搞Java的,看来还是有些道理的。
java有很多类库，工具包，第三方组件来帮助程序员解决偏底层的技术实现，让java程序员更专注业务的开发，也就是java们经常自嘲的堆代码搬砖。
身为一个java老码农，我觉得我也不用纠结了。跟着老师还有大神们认真的学一下，目标不能搞太高，学完这门课至少能从我不知道我不知道变成我知道我不知道就可以了。如果有意外惊喜，那就更好了。这就是所谓的佛系学习法吧。哈哈！</div>2021-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/cf/eb/0a9295e1.jpg" width="30px"><span>舞铲阶级</span> 👍（2） 💬（1）<div>一开始，从单个变量可能由于中断，而产生达不到预期结果的情况，可以通过硬件层面的原子操作，来解决相应问题；但硬件层面的的原子操作没办法适应多种多样的数据结构，这个时候就需要对中断来进行处理，保证数据处理过程中的“原子性”，对于嵌套中断的问题采用栈来保存对应的标志寄存器内容，用于还原来解决嵌套问题；但多核CPU可以绕过单个CPU的中断从而影响数据处理的“原子性”（个人理解希望老师指点），这时候通过硬件提供一个变量来形成自旋锁，保证处理的“原子性”，但是仍会由于嵌套中断从而导致占有自旋锁后进入死循环，因此引入关中断自旋锁来保证“原子性”；最后以上三种情况都不支持长时间等待情况，因此引入了信号量，注意对信号量的操作时要使用自旋锁来保证其“原子性”，如有不对希望大家指正。</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg" width="30px"><span>Fan</span> 👍（2） 💬（1）<div>好</div>2021-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg" width="30px"><span>Qfeng</span> 👍（1） 💬（1）<div>这篇文章帮助我又从新梳理了一边锁机制，温故知新，又有了新的认识。

认识锁机制（资源竞争和同步）主要抓住2条线：1）保护资源的大小；2）CPU数

从保护资源的大小由大到小排列：
1. 单变量资源（例如整型变量），可使用原子变量, CPU核数不影响。
2. 超过单变量数目的少量资源，此时操作数很多，寄存器就容不下了。
    1）对于单核CPU，因为单核CPU的任务调度也是通过中断发起的，在加上对普通中断函数的处理，直接关中断即可。
    2）对于多核CPU，引入自旋锁，同时要注意为了防止当前CPU中断嵌套拿锁造成死锁的情况，自旋锁需要关闭本地CPU中断。
3. 对于需要长时间等待处理完成的资源，为了避免忙等造成CPU资源的浪费，需要设计出一套既能安全的竞争又能尽可能释放CPU能力的机制，这就是信号量了。
   1）包含等待、互斥和唤醒等操作，当拿不到信号量时CPU可以做其他事情；
   2）信号量的操作同样需要用自旋锁（关中断）保证排他性；
   3）单核和多核CPU都适用。

以上，谢谢。</div>2022-03-26</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132" width="30px"><span>tuyu</span> 👍（1） 💬（1）<div>看了好多遍. 终于有点看懂了, 我总结一下我的笔记

锁是为了解决多并发安全处理一个数据

1. 当这个数据比较简单或者处理的数据比较简单时, 如果保证只有原子操作, 就能够很好的解决这个问题

2. 当这个数据比较复杂, 比如一个数据结构, 可以同时修改数据结构中不同的属性的时候, 就需要中断来解决这个问题, 但是单CPU的中断有个问题就是嵌套会出现bug, 于是把eflag的F位值+栈+内存巧妙的解决了这个问题

3. 随着计算机的发展, 大家开始有多CPU了, Eflag的F是不能解决这个问题, 这个时候科学家用了一个自旋锁, 自旋锁的实现也很巧妙, 操作系统提供一个函数, 保证程序读取锁, 上锁, 开锁都可以是原子性的, 感觉这个是大家使用分布式锁的原型

4. 现在多个CPU, 但是不能只执行你一个多并发程序, 其他的进程可能会占用你的CPU, 所以有信令这个数据结构, 其中count=1可以抢占, 用悲观锁的思想, 抢占这个信令先锁住这个信令, 然后count-1, 然后执行doSomethins, 然后如果有新的程序来占取, 如果count &lt; 1, 则到队列中排队, 等处理完了，唤醒队列中的人物, 就count+=1, 然后释放sem的锁</div>2021-11-17</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132" width="30px"><span>ppd0705</span> 👍（1） 💬（1）<div>获取信号量的说明`2. 对信号值 sem_count 执行“减 1”操作，并检查其值是否小于 0。` 和函数krlsem_down的逻辑不匹配：krlsem_down里面是先判断sem_count是否等于1，等于1表示获取到信号量，然后才对sem_count减一</div>2021-09-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/fc/53/836c87d1.jpg" width="30px"><span>李yong</span> 👍（1） 💬（1）<div>之前没有学习过操作系统，看了两遍，总结一下自己的理解,。
1. 原子操作，可以解决单个变量并发问题。不管后续多核cpu还是单核cpu. 
缺点在于只对于单个变量有效。
实现方式，汇编lock.
汇编lock这种方式后续几种方法都会涉及到。
2. 中断。单核cpu时只有一个流，唯一可能的并发就是中断，关闭中断即可解决问题。
缺点，只对于单核cpu有效。
实现方式，关闭中断。
不管单核还是多核，都会存在中断引起并发的情况，所以后面两种方法都涉及关闭中断。
3.自旋锁。可以突破原子操作和中断的限制，即支持多个变量并发以及多核cpu. 额外增加锁变量，锁变量值为0还是1指使此时是否存在并发。存在并发时，循环判断此锁变量的值，直到其他并发结束。不存在并发时，对锁变量加锁。需要关闭中断避免中断的影响。
缺点，存在并发时，其他流一直试图获取锁变量，占用cpu资源。
实现方式，增加锁变量，指使是否存在并发。
4. 信号量。增加结构体，结构体中包含count信号量计数值和list用于挂载等待任务流列表。count为0，任务流进入休眠状态(释放出cpu, 可以调度其他任务流)。count为1.获取信号量，可执行后续操作，并将count置为0，表示已占用，执行完成后，将count加1，</div>2021-08-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/e0/10/5ff0a104.jpg" width="30px"><span>imzzq</span> 👍（1） 💬（1）<div>疑问, 自旋锁里面关闭中断的话时钟中断不就没用了吗?  代码中要到释放自旋锁的时候才会再次打开中断, 也就是说获得自旋锁的进程在释放自旋锁之前不会被调度?... 那是不是影响太大了点, 如果临界区中死循环了, 整个系统就死了?</div>2021-07-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg" width="30px"><span>Feen</span> 👍（1） 💬（1）<div>这一章对我来说很干，非常干。内容包括程序本身的原子操作和外部中断，还有在等待期的自旋锁和信号量，将单体应用和分布式应用所能碰到的问题统一。数据同步的问题不止在高并发环境中有，在单机中也有。最后将中断+自旋锁或者中断+信号量的用法甚至中断+自旋锁+信号量的组合用法都用示例表达出来。一步一步的详细说明了如何解决数据同步，本章肝的肝疼。</div>2021-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg" width="30px"><span>哇咔咔</span> 👍（1） 💬（3）<div>没看懂为啥x86_spin_lock这个函数上来就用xchg把lock设置为了，不应该只是读取lock的值？不为0才设置为1吗？</div>2021-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0b/39/e05b4f74.jpg" width="30px"><span>LIUYU</span> 👍（1） 💬（1）<div>4. 损坏列表那个没有明白，看了一下C语言和汇编，没有发现GCC 保存与恢复现场
-------C------------
int main()
{
   __asm__ volatile (&quot;movl $1, %%eax\n\t&quot;
                            :::&quot;%eax&quot;);
}
&#47;&#47; 生成汇编代码如下
#APP
       movl $1, %eax
#NO_APP
没看到哪里有恢复eax 之前的值</div>2021-06-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/f1/24/07ce02a0.jpg" width="30px"><span>熊光红</span> 👍（1） 💬（3）<div>“在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题”，这句话怎么理解，能否举一个有问题的例子</div>2021-05-30</li><br/>
</ul>