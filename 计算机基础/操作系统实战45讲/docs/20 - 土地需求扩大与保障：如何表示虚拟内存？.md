你好，我是LMOS。

在现实中，有的人需要向政府申请一大块区域，在这块区域中建楼办厂，但是土地有限且已经被占用。所以可能的方案是，只给你分配一个总的面积区域，今年湖北有空地就在湖北建立一部分厂房，明年广东有空地就在广东再建另一部分厂房，但是总面积不变。

其实在计算机系统中也有类似的情况，一个应用往往拥有很大的连续地址空间，并且每个应用都是一样的，只有在运行时才能分配到真正的物理内存，在操作系统中这称为虚拟内存。

那问题来了，操作系统要怎样实现虚拟内存呢？由于内容比较多，我会用两节课的时间带你解决这个问题。今天这节课，我们先进行虚拟地址空间的划分，搞定虚拟内存数据结构的设计。下节课再动手实现虚拟内存的核心功能。

好，让我们进入正题，先从虚拟地址空间的划分入手，配套代码你可以从[这里](https://gitee.com/lmos/cosmos/tree/master/lesson19~21/Cosmos)获得。

## 虚拟地址空间的划分

虚拟地址就是逻辑上的一个数值，而虚拟地址空间就是一堆数值的集合。通常情况下，32位的处理器有0～0xFFFFFFFF的虚拟地址空间，而64位的虚拟地址空间则更大，有0～0xFFFFFFFFFFFFFFFF的虚拟地址空间。

对于如此巨大的地址空间，我们自然需要一定的安排和设计**，比如什么虚拟地址段放应用，什么虚拟地址段放内核等。**下面我们首先看看处理器硬件层面的划分，再来看看在此基础上我们系统软件层面是如何划分的。
<div><strong>精选留言（12）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/02/5b/ce326cfc.jpg" width="30px"><span>二三子也</span> 👍（19） 💬（1）<div>内核代码使用虚拟地址，但是内核有时需要用到物理地址，比如设置页表项等。线性映射区使得内核能通过加减一个固定值的方式，方便的完成虚拟地址与物理地址的转换。</div>2021-06-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg" width="30px"><span>pedro</span> 👍（12） 💬（2）<div>0xFFFF800000000000～0xFFFF800400000000 的线性映射区是MMU 页表映射数据，保存虚拟地址和物理地址之间的映射关系，没有这块区域，CPU无法在长模式下工作，通过虚拟地址将无法访问真实的数据。

且这个区域必须在内核态，放在用户态太危险了，万一被某个应用程序修改，直接爆炸。</div>2021-06-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/67/0f/3cb10900.jpg" width="30px"><span>菜鸟</span> 👍（5） 💬（1）<div>关于内存的分配与管理定义了大量的数据结构，这些数据结构是借鉴的Linux，还是自己创建的？</div>2021-08-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg" width="30px"><span>青玉白露</span> 👍（4） 💬（1）<div>这个线性映射区主要是用来存放MMU的
试想，如果所有的地址都是物理地址转换到虚拟地址，这个转换关系存在哪？存在虚拟内存里？那这不是套娃么，你连MMU都找不到，根本没法转换。
所以才有了一段映射区，内核态直接去访问这个区域就可以获取MMU的数据，避免套娃。</div>2021-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg" width="30px"><span>Feen</span> 👍（3） 💬（1）<div>最后的思考题：因为不管是实模式还是保护模式或者长模式，物理内存 0～0x400000000的实体空间是被系统的启动类型文件占用，这里不止包括内核相关的，还有BIOS中断表等等前面课程讲过的硬软件系统必须要的文件，开机就占用，关机谁也占用不了，首先给这段物理地址就固定下来。这是必要的。
而操作系统运行在非实模式下虚拟地址空间之后，如果不建立线性映射表，那对这块物理地址时不安全的，就如同实模式切换到保护模式为什么增加了各种检查和权限一个道理，也需要虚拟地址与物理地址有一个线性和固定的映射表，保护此段物理内存上的的文件，告知操作系统在分配内存的时候避开雷区。就如同隔着墙货架上抓东西，你可以抓货架上的任何东西，但要是抓到货架的框子，使劲一抓，可以想象到什么后果。
另外0xFFFF800000000000～0xFFFF800400000000的地址数值时可以变的，比如改成0xFFFF800400000000～0xFFFF800800000000,还可以改成其他，只要按照这里的规则和做好映射关系就可以，当然选择0xFFFF800000000000～0xFFFF800400000000对应0x0~0x400000000更符合人的阅读习惯。</div>2021-07-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/6f/a7/565214bc.jpg" width="30px"><span>│．Sk</span> 👍（0） 💬（1）<div>老师好，请问我下面的理解对吗？

1. 在 init_kvirmemadrs 函数中，初始化完 initmmadrsdsc 及相应的 userspace 虚拟内存地址区间后；调用了 hal_mmu_init 方法

2. 在 hal_mmu_init 方法中复制了在内核初始化时设置的顶级页目录到 mmu-&gt;mud_tdirearr，并把顶级页目录的第 0 项清空（我理解此处是为了清除原来该处映射到内核空间的项，改为未映射，这样访问用户空间的虚拟地址时候会触发 page fault，再分配实际的物理页并映射）

3. 在 hal_mmu_init 执行完后，紧接着执行了 hal_mmu_load 函数，该函数会把 mmu-&gt;mud_tdirearr 转换为物理地址设置到 cr3；该步骤执行完后，访问 0～0x400000000 的地址会触发 pagefault

4. 在执行完 init_kvirmemadrs 后，cosmos 代码还有许多访问内核全局变量（如 osdevtable 等）代码，这些变化是定义在内核文件的 .data 段中的，是不是因为内核文件链接脚本用了如下定义 .data ALIGN(4) : AT(ADDR(.data)-VIRTUAL_ADDRESS) { *(.data) *(.bss) }，所以可以让这些内核全局变量的加载到物理地址 0～0x400000000 中，但是代码中直接访问这些内核全局变量实际上用的是 0xffff800000000000～0xffff800400000000 中的虚拟地址，这样才会在顶级页目录的第 0 项被清空后访问内核全局变量不会造成 page fault</div>2022-10-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg" width="30px"><span>艾恩凝</span> 👍（0） 💬（1）<div>打卡，再重新梳理一遍</div>2022-04-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（1）<div>各位大神666</div>2022-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/72/c1/59509397.jpg" width="30px"><span>沈畅</span> 👍（0） 💬（1）<div>课后题目我再补充一点，本节为虚拟内存管理创建的一系列结构，需要进行内存分配（调用了内存对象分配接口），0xFFFF800000000000～0xFFFF800400000000 地址空间，之前已经在MMU建立了地址映射，为内核分配内存，使用内存的必要条件。否则内核无法使用内存了。</div>2021-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg" width="30px"><span>相逢是缘</span> 👍（0） 💬（4）<div>一直有一个疑问，应用空间和内存空间有各自的页表，虚拟内存为什么要划分为用户空间和内核空间呢，有什么作用呢？内核空间和应用空间从虚拟内存看都能申请0~4G的内存（假如是32位机），会有什么问题呢？为什么为内核分配内存的时候硬要规定3G以上的才是内核用的呢？</div>2021-08-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg" width="30px"><span>相逢是缘</span> 👍（0） 💬（1）<div>
对于思考题自己的理解：
因为开启长模式和MMU之后，访问的所有地址都应该是“虚拟地址”，这个地址必须经过MMU转换才能访问到真正的物理地址。而我们的内核代码以及数据都放在物理地址的0x0~0x400000000内，当划分0xffff800000000000为内核虚拟地址的开始地址时，需要进行这个虚拟地址到物理地址的转换。
之前的课程中，在启动MMU之前，虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，在内核启动时，虚拟地址和物理地址要保持相同。后续在启动进程时，因为 0～0x400000000这个虚拟地址为用户空间了，在进程的虚拟地址空间中虚拟地址：0～0x400000000就不能映射到物理空间 0～0x400000000处了。</div>2021-06-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg" width="30px"><span>blentle</span> 👍（0） 💬（2）<div>是不是因为内核地址空间是共享的，而内核页表部分是又是相同的，才会有一个线性映射目的是相对于外部程序来说仿佛是访问不同的内存空间.不知道理解的对不对……真的是越来越难，上一节还没消化</div>2021-06-23</li><br/>
</ul>