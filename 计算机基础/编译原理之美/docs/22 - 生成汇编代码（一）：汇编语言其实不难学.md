> 敲黑板：课程用的是GNU汇编器，macOS和Linux已内置，本文的汇编语言的写法是GNU汇编器规定的写法。Windows系统可安装MinGW或Linux虚拟机。

对于静态编译型语言，比如C语言和Go语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。

![](https://static001.geekbang.org/resource/image/fe/76/feadbf7a473c420d0693c249b48e0e76.jpg?wh=1142%2A169)

就算像JavaScript这样的解释执行的语言，也要在运行时利用类似的机制生成机器码，以便调高执行的速度。Java的字节码，在运行时通常也会通过JIT机制编译成机器码。**而汇编语言是完成这些工作的基础。**

对你来说，掌握汇编语言是十分有益的，因为哪怕掌握一小点儿汇编技能，就能应用到某项工作中，比如，在C语言里嵌入汇编，实现某个特殊功能；或者读懂某些底层类库或驱动程序的代码，因为它可能是用汇编写的。

本节课，我先带你了解一下汇编语言，来个破冰之旅。然后在接下来的课程中再带你基于AST手工生成汇编代码，破除你对汇编代码的恐惧，了解编译期后端生成汇编代码的原理。

以后，当你看到高级语言的代码，以及IR时，就可以想象出来它对应的汇编代码是什么样子，实现从上层到底层认知的贯通。

## 了解汇编语言
<div><strong>精选留言（18）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg" width="30px"><span>沉淀的梦想</span> 👍（26） 💬（4）<div>没太看懂文稿中的&quot;leaq    L_.str(%rip), %rdi&quot;里面的&quot;L_.str(%rip)&quot;的含义，能再解释一下吗？</div>2019-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fe/21/cd5e5fd8.jpg" width="30px"><span>不的</span> 👍（12） 💬（1）<div>老师，为啥要设计成区分调用者、被调用者保护的寄存器，统一被调用者或者调用者保护，有啥问题么</div>2019-10-23</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132" width="30px"><span>有学识的兔子</span> 👍（5） 💬（1）<div>一直想着学习逆向工程，奈何汇编理解不足 学习摸不着头脑，老师的课程给我带来了启发。</div>2020-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/00/1b/eee13196.jpg" width="30px"><span>李圣悦</span> 👍（2） 💬（1）<div>确实汇编并不难，最近一直在查内核宕机问题，阅读内涵汇编代码没什么阻碍。难就难在如何恢复c代码…</div>2020-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/46/2e/1017900c.jpg" width="30px"><span>牛逼中…</span> 👍（0） 💬（1）<div>这里面说到地址，指的是可执行文件中的相对地址么？肯定不是内存吧，这个时候还没加载运行，和内存无关吧？</div>2020-03-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg" width="30px"><span>Dylan</span> 👍（0） 💬（2）<div>记得汇编入门的时候是从写一个简单的斐波那契数列开始～～当时真的觉得神奇，后来和内核驱动程序打交道，看多了大神们写的汇编，感觉好像也没那么难</div>2020-03-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7a/6e/cec25432.jpg" width="30px"><span>宝鹏</span> 👍（0） 💬（2）<div>老师，as工具生成的文件不能直接运行，as hello.s -o hello，生成的hello并不是可执行文件</div>2020-02-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/01/37/812d50ab.jpg" width="30px"><span>好雨知时节</span> 👍（0） 💬（1）<div>宫老师，想问下：文中在示例中提到：
8(%rbp)，是比 %rbp 寄存器的值加 8。 &#47;&#47;想知道这里的%rbp 寄存器中存储的内容一个地址还是具体的数据值？8(%rbp) 的含义是：%rbp 寄存器中存储的地址加8后的新地址 还是 %rbp 寄存器中具体数据值+8 得到的具体值？
-8(%rbp)，是比 %rbp 寄存器的值减 8。&#47;&#47;</div>2020-02-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/2b/84/3fe59164.jpg" width="30px"><span>权华</span> 👍（0） 💬（1）<div>刚刚的问题，xorl    %eax, %eax，将返回值置为0。</div>2019-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/2b/84/3fe59164.jpg" width="30px"><span>权华</span> 👍（0） 💬（1）<div>leaq    L_.str(%rip), %rdi    
leaq    L_.str.1(%rip), %rsi    
xorl    %eax, %eax    
callq   _printf    
xorl    %eax, %eax

宫老师你好，这是文章前面的汇编代码的一部分，我不明白 xorl    %eax, %eax 这两行代码，它的作用是什么？为什么没有给寄存器 eax 就直接 xorl 操作了。</div>2019-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg" width="30px"><span>沉淀的梦想</span> 👍（0） 💬（1）<div>看了老师的回答与讲解&quot;RIP相对寻址&quot;的文章，但是还是不太理解：%rip存储的是下一条要执行的代码的地址，他存储值应该在不停地变，所以他和静态数据的偏移应该也在不停地变，为什么这里的偏移（L_.str）看起来是个常量啊？</div>2019-10-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" width="30px"><span>峰</span> 👍（0） 💬（1）<div>感受是写了一大坨，天都黑了，还没写完。。。</div>2019-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg" width="30px"><span>sugar</span> 👍（12） 💬（2）<div>我觉得读到这节 依然发现宫老师花费了很多笔墨在字里行间穿插探讨后端技术的重要性和应用场景。我也来贡献一个应用场景吧： 几年前我曾经听组里一位资深的后端（服务器后端）工程师分享过一道golang面试题，题目很简单：“写一个for循环输出从1到10 用go比用c更快，为什么？” ，当时的我不明觉厉，于是去查了些资料发现似乎考点是一个叫达夫机器的概念。如果熟悉汇编，其实大可不必被这些听起来高大上的理念吓到，一个forloop在汇编层面代码也不会长得可怕，直接读读编译后的代码就可以直观研究这样的问题了～</div>2020-05-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/8e/7d/cfe91f29.jpg" width="30px"><span>青南</span> 👍（1） 💬（1）<div>老师，请教一下汇编里面的“寄存器”是物理意义上的CPU里面的寄存器还是逻辑意义上的寄存器？如果是物理意义上的，那么，为什么多个程序同时操作同一个寄存器的时候，他们的数据不会冲突呢？因为操作系统里面肯定上有很多程序在运行的，如果A程序现在mov一个数字到rsp寄存器里面， 而B程序此时也mov了一个数字到rsp寄存器里面，那么当a程序从rsp寄存器里面读取数据的时候，不就读到B程序写进去的数据了吗？</div>2022-03-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/1a/1c/d160d44b.jpg" width="30px"><span>coder</span> 👍（1） 💬（0）<div>mov指令的源和目的不能同时为内存地址吧？</div>2021-11-02</li><br/><li><img src="" width="30px"><span>Geek_656245</span> 👍（0） 💬（0）<div>很有用</div>2021-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/07/19/76943b89.jpg" width="30px"><span>David</span> 👍（0） 💬（0）<div>大学时微机原理，工作后看gcc后汇编代码发现和大学时讲的不一样了，很头疼，老师这篇文章一扫阴霾，解了我多年的疑惑。</div>2021-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg" width="30px"><span>sugar</span> 👍（0） 💬（2）<div>我一直不太明白 汇编里的push和pop所操作的这个栈，是不是就是操作系统在内存中给当前进程分配的应用内存空间当中的栈区（旁边还有堆区 静态区 常量区 代码区）呢？还是说汇编这里边的栈是单独的一套寄存器&#47;高速缓存 之类的硬件设备？ 望解答 </div>2020-05-03</li><br/>
</ul>