在[文件系统](https://time.geekbang.org/column/article/97876)那一节，我们讲了文件的写入，到了设备驱动这一层，就没有再往下分析。上一节我们又讲了mount一个块设备，将block\_device信息放到了ext4文件系统的super\_block里面，有了这些基础，是时候把整个写入的故事串起来了。

还记得咱们在文件系统那一节分析写入流程的时候，对于ext4文件系统，最后调用的是ext4\_file\_write\_iter，它将I/O的调用分成两种情况：

第一是**直接I/O**。最终我们调用的是generic\_file\_direct\_write，这里调用的是mapping-&gt;a\_ops-&gt;direct\_IO，实际调用的是ext4\_direct\_IO，往设备层写入数据。

第二种是**缓存I/O**。最终我们会将数据从应用拷贝到内存缓存中，但是这个时候，并不执行真正的I/O操作。它们只将整个页或其中部分标记为脏。写操作由一个timer触发，那个时候，才调用wb\_workfn往硬盘写入页面。

接下来的调用链为：wb\_workfn-&gt;wb\_do\_writeback-&gt;wb\_writeback-&gt;writeback\_sb\_inodes-&gt;\_\_writeback\_single\_inode-&gt;do\_writepages。在do\_writepages中，我们要调用mapping-&gt;a\_ops-&gt;writepages，但实际调用的是ext4\_writepages，往设备层写入数据。
<div><strong>精选留言（22）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg" width="30px"><span>geraltlaush</span> 👍（23） 💬（1）<div>文件系统中的page_cache对应逻辑上的块的概念，将page_cache打包成bio递交给通用块设备层，通用块设备层将多个bio打包成一个请求request, 尽量把bio对应的sector临近的数据合并，提交给块设备调度层，块设备调度层就是把各个request当成段提交给设备驱动程序，因为设备驱动程序只识别段，也就是说通用块设备层捣腾的其实就是把bio对应的页框和在磁盘中对应的sector进行合并的过程，调度层只负责把合并的request放进队列，用调度算法下发给驱动程序处理，其实所有复杂的合并操作以及内存和磁盘扇区的对应关系都是通过块设备层做了，老师，可以这么理解吧</div>2019-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg" width="30px"><span>djfhchdh</span> 👍（6） 💬（1）<div>&#47;sys&#47;block&#47;xvda&#47;queue&#47;scheduler 磁盘的调度算法，临时修改：echo noop &gt; &#47;sys&#47;block&#47;xvda&#47;queue&#47;scheduler，永久修改就需要修改内核参数，然后重启。
iostat -d  -x 中的avgqu-sz是平均I&#47;O队列长度。
</div>2019-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg" width="30px"><span>geraltlaush</span> 👍（6） 💬（1）<div>那个队列，队头和队尾的合并都是为了所谓的顺序写，减少机械硬盘寻址消耗吧，能赶上就上同一辆车，赶不上自己叫一辆车等满了再走，但是也是有超时等待时间的，可以这么理解吧</div>2019-06-17</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/7dSgJbCaoS5CnCI4toP6mPueW1f0eQ0Ua9LxymPqJjH49cNYkJK0s9NcvrapPU4gvZb12j2u3l2A8Rw5onlJMQ/132" width="30px"><span>眭东亮</span> 👍（2） 💬（1）<div>查看磁盘调度算法
cat &#47;sys&#47;block&#47;sda&#47;queue&#47;scheduler
</div>2019-07-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（2） 💬（1）<div>往设备里面写的时候调用的是request_fn，这个函数是谁来调用的呢？触发这个调用的时机是什么呢？还是说请求一旦进入队列就会立即写入？</div>2019-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg" width="30px"><span>蚂蚁内推+v</span> 👍（1） 💬（1）<div>会不会断电丢失数据呢？</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（1） 💬（1）<div>直接读写裸设备不会走文件系统，那还会走通用块层吗？</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg" width="30px"><span>游弋云端</span> 👍（0） 💬（1）<div>老师，是否可以认为直接 IO执行完成后，数据就是下盘的，还是不一定，还有驱动层以及磁盘缓存等因素。</div>2019-09-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（0） 💬（1）<div>老师，希望在答疑篇能讲一讲request_fn取出请求之后的具体执行过程，具体的执行是不是和block_device有关，磁盘的最底层的操作是不是都在block_device中？</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg" width="30px"><span>石维康</span> 👍（0） 💬（1）<div>bio_list_merge(&amp;bio_list_on_stack[0], &amp;lower);
bio_list_merge(&amp;bio_list_on_stack[0], &amp;same);
bio_list_merge(&amp;bio_list_on_stack[0], &amp;bio_list_on_stack[1]);

请问这些加到bio_list_on_stack[0]上的bio是在什么时候被处理的？</div>2019-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg" width="30px"><span>hello</span> 👍（9） 💬（0）<div>太爽了，听了三四遍这节课，以前一直担心io在内核内部会发生多次拷贝，听完发现并没有。下一次我一定要边读源码边听。</div>2019-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（5） 💬（0）<div>         make_request_fn被初始化成了blk_queue_bio函数。submit_bio会调用到generic_make_request，然后进一步调用到make_request_fn，也就是blk_queue_bio。在blk_queue_bio里面其实是先尝试将bio合并到当前进程的plug_list里面的request，如果可以合并，则合并后直接返回了，如果不能合并，则接着向磁盘设备的request_queue中合并，向request_queue中合并的时候一定会成功（因为即使不能合并也会新生成一个request）。而每个进程的plug_list里面的request也会在适当的时候就行泄流，泄流的时候会调用到磁盘设备的request_queue里面的电梯成员的elevator_add_req_fn，这个函数就是讲plug_list里面的request加入到request_queue里面的电梯队列里，进行更进一步的合并。
        设备驱动会调用request_queue的request_fn，平时写块设备驱动也就是申请一个request_queue，然后调用一些内核api初始化这个request_queue，并且实现自己的request_fn函数，request_fn会调用blk_peek_request从request_queue的queue_head成员取出request，并转化为更底层的指令来执行，如果发现queue_head为空，则会调用request_queue的elevator_dispatch_fn分发request。</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（5） 💬（0）<div>看了一点儿其它的资料，大概了解了一下，有以下几种情况：1、request_fn是在unplug泄流的时候调用（也就是队列里面的请求达到一定的数量）  2、或者是由定时器触发，也就是即使队列里面的请求很少，但是也不能无限期的不执行它们，所以在定时器超时后会调用request_fn 3、或者在添加request进行合并的时候，判断一下是哪种合并方式，如果是后向合并就会立即调用requset_fn。
不知道这样理解的对不对？</div>2019-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg" width="30px"><span>TableBear</span> 👍（1） 💬（0）<div>好晕啊</div>2021-12-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/30/1e/0b05530d.jpg" width="30px"><span>Yakmoz</span> 👍（1） 💬（0）<div>这里的page_cache和文件系统里的page_cache是不是不一样的? 不太明白,为什么直接IO 提交的时候也会操作page_cache</div>2020-09-22</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/uG2kliaKAroGkNaXSwFNEmVz8xM6srw7OEHBMSBbPibuXQMctibLyuQEpRVmOth8sdojb3u5VUEjWm2D2lzRGuMDA/132" width="30px"><span>Geek_ae11ce</span> 👍（0） 💬（1）<div>能否结合新版Linux内核再来一次？现在很多代码和机制已经变了。</div>2024-08-06</li><br/><li><img src="" width="30px"><span>minsreal</span> 👍（0） 💬（0）<div>有个问题:没有讲request_fn是什么时候调用的。make_request只是创建了请求并加入队列中，队列的数据什么时候处理呢？</div>2023-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cc/56/df75ed7d.jpg" width="30px"><span>Geek_6174df</span> 👍（0） 💬（0）<div>老师，关于文件cache 有没有一个总的大小限制呢？ </div>2023-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/be/68/57f39422.jpg" width="30px"><span>specter</span> 👍（0） 💬（0）<div>刘老师，我是一个老师，您画的图实在是太好了，我能在讲课的时候借用您的图吗？</div>2022-02-05</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/VX0ib4CV0m7fwxB2xFcIJaYYWXXpfxxYbfBErqBej9395hgZszqS3dz9bThCxOuFfJ8Xibx9HbdNmZJwL5m33wIw/132" width="30px"><span>chaoxifuchen</span> 👍（0） 💬（0）<div>老师，有个疑问，什么情况下会用到直接 I&#47;O，还有假设一个页里只有1个字节改变了，从page_cache往磁盘里刷脏页时也是重新写整个页4k字节吗？</div>2021-07-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/67/df/8b85d0d9.jpg" width="30px"><span>--</span> 👍（0） 💬（0）<div>补充知识点：块设备多队列架构。内核在5.0之后已经完全从单队列架构迁移到了多队列架构，按照老师的思路去了解多队列架构还是挺有意思的。</div>2020-12-28</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（0） 💬（0）<div>请问老师，do_direct_IO 里面每一页(page)可能对应多个块（block），是不是现实中大多数情况页和块相等（4K），也就是每页也就循环一次。是不是从这里也可以看出，页的大小虽然可以配置，也必须是4K的整数倍，块的大小应该是不可配置的（永远4K）。</div>2019-12-31</li><br/>
</ul>