上一节，你获得了一本《企业经营宝典》，完成了一件大事，切换到了老板角色，从实模式切换到了保护模式。有了更强的寻址能力，接下来，我们就要按照宝典里面的指引，开始经营企业了。

内核的启动从入口函数start\_kernel()开始。在init/main.c文件中，start\_kernel相当于内核的main函数。打开这个函数，你会发现，里面是各种各样初始化函数XXXX\_init。

![](https://static001.geekbang.org/resource/image/cd/01/cdfc33db2fe1e07b6acf8faa3959cb01.jpeg?wh=2639%2A1742)

## 初始化公司职能部门

于是，公司要开始建立各种职能部门了。

首先是**项目管理部门**。咱们将来肯定要接各种各样的项目，因此，项目管理体系和项目管理流程首先要建立起来。之前讲的创建项目都是复制老项目，现在咱们需要有第一个全新的项目。这个项目需要你这个老板来打个样。

在操作系统里面，先要有个创始进程，有一行指令set\_task\_stack\_end\_magic(&amp;init\_task)。这里面有一个参数init\_task，它的定义是struct task\_struct init\_task = INIT\_TASK(init\_task)。它是系统创建的第一个进程，我们称为**0号进程**。这是唯一一个没有通过fork或者kernel\_thread产生的进程，是进程列表的第一个。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKbwJ55niaS6Df8BjvKK2ug2jFibCYhicz1lx7GDYOGs9MMgbHJmWoH1DXZAR5TKsESyUz1zsaw4Flew/132" width="30px"><span>Virtue</span> 👍（73） 💬（4）<div>感觉大家不用太纠结于代码细节了，知道内河初始化都干了啥就行了吧。。</div>2019-04-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0f/71/9273e8a4.jpg" width="30px"><span>时间是最真的答案</span> 👍（69） 💬（7）<div>我做Java的，看的云里雾里，好慌啊</div>2019-04-12</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" width="30px"><span>ninuxer</span> 👍（50） 💬（4）<div>打卡day9
0生1，1生众生，2是内核态的办公室主任～</div>2019-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg" width="30px"><span>Arthur.Li</span> 👍（39） 💬（8）<div>0号进程不属于内核态吗？属于的话为啥2号才是内核态祖先</div>2019-06-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/75/69/791d0f5e.jpg" width="30px"><span>rocedu</span> 👍（38） 💬（1）<div>推荐一本入门书配套本课程学习，《庖丁解牛Linux内核分析》（ https:&#47;&#47;j.youzan.com&#47;BA2Fr9）</div>2019-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（29） 💬（1）<div>ramdisk里面是不是也要提前放上存储设备的驱动，然后ramdisk里面的init起来之后，加载对应存储设备的驱动，为了适应各种存储设备，ramdisk里面需要放上市面上各种存储设备的驱动吗？如果是这样的话，那跟把这些驱动放到内核里有什么区别呢？反正也没有节省空间。 

我的理解是这样的，ramdisk中只放要运行的电脑上的存储设备驱动，内核中不放存储设备驱动，这样的话如果每次存储设备不同，我们只需要做一个对应的ramdisk，每次更换存储设备只需要做ramdisk，而内核只需要编译一次就行了，这样效率会提高？如果驱动放到内核一起编译，每次换存储设备都要重新编译内核，效率低。编译内核比做一个新的ramdisk效率低。

不知道以上理解对不对，还请老师指点一二。</div>2019-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg" width="30px"><span>孜孜</span> 👍（26） 💬（1）<div>逐渐一篇文章要读很多遍，花很多时间。坚持，多看一点，多花点时间，总比啥都不干强。</div>2019-04-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/af/27/76489618.jpg" width="30px"><span>sunsweet</span> 👍（14） 💬（1）<div>0号进程能详细说说嘛，它是干啥用的</div>2019-04-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg" width="30px"><span>焰火</span> 👍（11） 💬（1）<div>超哥您好：
用户态 --&gt; 内核态 --&gt; 用户态  这点感觉很像进程间的切换啊
如果把 内核态 也当作 一个进程来看，这个一个内核态进程 是 服务于 多个用户进程的嘛？ 
多个用户进程对某一个硬件资源进行系统调用 应该也是有  阻塞排队等待的吧 ~~  </div>2019-04-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4e/38/3faa8377.jpg" width="30px"><span>登高</span> 👍（11） 💬（1）<div>不去看源码似乎跟不动了</div>2019-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg" width="30px"><span>栋能</span> 👍（7） 💬（1）<div>我有个小小的疑问：kernel_thread创建的是进程么？例如：ps命令查看，发现kthreadd有pid，且在command的内容是[kthreadd]，[]包裹说明这是个内核线程。既然这样，大家都称呼kthreadd是一个进程，我就有点困惑了</div>2019-05-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg" width="30px"><span>马以</span> 👍（6） 💬（3）<div>有什么工具可以打开内核源码，在能直接跳转方法的</div>2020-01-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/59/f6/ed66d1c1.jpg" width="30px"><span>chengzise</span> 👍（6） 💬（1）<div>老师好，在执行start_kernel时候还是单任务环境，创建好0，1，2号进程后，start_kernel所在的函数栈属于0号进程吗？start_kernel执行结束，会退出到哪里？之前学习RTOS的时候，主任务相当于0号进程，然后由0进程创建其他进程，创建结束0号进程后进入死循环，监控系统。不知道Linux中start_kernel执行完是怎么处理的，请老师解答，谢谢</div>2019-04-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/6b/8f/eba34b86.jpg" width="30px"><span>星光</span> 👍（6） 💬（1）<div>深入内核，才发觉操作系统原来这么神奇！</div>2019-04-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg" width="30px"><span>刘強</span> 👍（6） 💬（3）<div>问题1:
     这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。 
     这句话是正文中的一句话。我的疑问是所有线程的祖先不也是一个线程吗？为什么说是函数？难道这个函数就是2号线程的程序镜像？
    kernel_thread函数的第一个参数是一个函数指针，这个传进来的函数干啥用的，什么时候执行？创建1号线程的时候，我们加载了文件系统中的init程序文件，2号线程的程序文件在哪里？

问题2：
    引导程序将控制权交给内核后，内核开始执行，这时候还没有什么进程，代码的执行是线性的，也就是没有任何调度，但是创建进程1,2,3后，调度就开始了，那怎么再回到内核的初始化代码中去，也就是start_kenel函数中区，因为我看到创建进程后还有工作需要初始化，但这段代码貌似不在任何进程中。还是初始化彻底完成后，调度程序才开始运行？

   水平有限，写的比较乱，提的问题比较弱智😄</div>2019-04-12</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132" width="30px"><span>雷刚</span> 👍（5） 💬（3）<div>对于你我这种搞 java 的，对 c 基本上是小白，看源码连函数位置都找不到，强烈建议：使用 source insight4.0 打开 Linux 源码，然后重点来了，使用 project -&gt; synchronize files -&gt; force all files to be... 工具同步一下（找了好久才找到，说出来都是泪啊），基本上就可以到处跳转啦。
这样基本上都可以找到函数位置了，爽歪歪的，不过源码我也只是验证一下文中的内容，陷太深了也完蛋。</div>2020-04-17</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJqWuvuicHD7RVlEDJamWNmwVdkjeH4pLxPXoicwqbnpOibI1MFFz9SIVJmQeKSZQRP9np1NUV3wpmnA/132" width="30px"><span>编码者</span> 👍（5） 💬（1）<div>对着源码把找文中提到的函数找到，瞄一眼长啥样。现在也只能大概看下有哪些，具体的也看不懂，不过随着瞄的越来越多，应该就越来越懂了吧。</div>2019-04-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/40/52/7266ee09.jpg" width="30px"><span>哈</span> 👍（4） 💬（1）<div>在考研正好要考操作系统，结合参考书和老师文章的讲解感觉完全串起来了！！！！越学越有劲</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/fe/fe/12638c5b.jpg" width="30px"><span>邢世宝</span> 👍（4） 💬（1）<div>x86的权限控制，怎么保证application是跑在r3，内核是跑在r0的？</div>2019-04-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/ca/e3/447aff89.jpg" width="30px"><span>记事本</span> 👍（3） 💬（1）<div>学了后面的课程再回过来复习 又感觉多理解了那也一些。</div>2019-08-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/fc/5c/a3d42cdb.jpg" width="30px"><span>ilovealt</span> 👍（3） 💬（1）<div>刘老师您好，我想问 为什么先创建用户态进程管理再创建内核进程管理，为什么不是反过来的呢？</div>2019-07-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg" width="30px"><span>garlic</span> 👍（3） 💬（1）<div>list_head存放维护双向链表的指针， 进程结构中task_struct中存放一个类型list_head 的指针task， 在创建进程时将进程放入进程列表2.6.17 版本 使用宏  SET_LINKS， 之后使用list_add_tail_rcu， RCU后续还要在学习一下</div>2019-05-27</li><br/><li><img src="" width="30px"><span>Dispy</span> 👍（3） 💬（2）<div>为什么先初始化用户态进程的祖先，而不是内核态进程的祖先</div>2019-04-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg" width="30px"><span>牛牛</span> 👍（2） 💬（1）<div>我写php的，看的云里雾里，慌的一批。5年了，留下没有技术的泪水。</div>2019-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg" width="30px"><span>嘉木</span> 👍（2） 💬（1）<div>kernel&#47;fock.c :
 kernel_thread -&gt; _do_fork -&gt; copy_process -&gt; dup_task_struct生成一个task_struct*，然后各种初始化赋值拷贝（files、fs、signal、signhand、mm、io、threadlst）

没找到在哪加入task列表的</div>2019-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0b/d4/39763233.jpg" width="30px"><span>Tianz</span> 👍（2） 💬（1）<div>Hi， 超哥， 如果能在你用公司职能部门来形象比喻内核子系统的后面括号指明对应的子系统，如：项目管理部（进程管理子系统），感觉能给对内核有点经验的人减少一些脑切换的开支和对新人有明确的记忆。</div>2019-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/46/dffc60d2.jpg" width="30px"><span>凛</span> 👍（2） 💬（1）<div>听说还有个 “Ring -1” 层，虚拟化实现方案里提到的...</div>2019-04-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/1e/8d/4239f463.jpg" width="30px"><span></span> 👍（2） 💬（1）<div>关于内核启动流程，大家可以参考下https:&#47;&#47;blog.csdn.net&#47;mahang123456&#47;article&#47;details&#47;88722948博客</div>2019-04-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/42/af/8c37ca95.jpg" width="30px"><span>haiker</span> 👍（2） 💬（1）<div>内核初始化的时候为啥先创建用户态祖先进程，后创建内核态的祖先进程，这个顺序重要吗？还是谁先创建都一样？</div>2019-04-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg" width="30px"><span>吴小智</span> 👍（2） 💬（1）<div>需要自己去看源码，才能理解了。老师画的图是真的好</div>2019-04-12</li><br/>
</ul>