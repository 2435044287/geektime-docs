前几节，我们介绍了task\_struct数据结构。它就像项目管理系统一样，可以帮项目经理维护项目运行过程中的各类信息，但这并不意味着项目管理工作就完事大吉了。task\_struct仅仅能够解决“**看到**”的问题，咱们还要解决如何制定流程，进行项目调度的问题，也就是“**做到**”的问题。

公司的人员总是有限的。无论接了多少项目，公司不可能短时间增加很多人手。有的项目比较紧急，应该先进行排期；有的项目可以缓缓，但是也不能让客户等太久。所以这个过程非常复杂，需要平衡。

对于操作系统来讲，它面对的CPU的数量是有限的，干活儿都是它们，但是进程数目远远超过CPU的数目，因而就需要进行进程的调度，有效地分配CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。

## 调度策略与调度类

在Linux里面，进程大概可以分成两种。

一种称为**实时进程**，也就是需要尽快执行返回结果的那种。这就好比我们是一家公司，接到的客户项目需求就会有很多种。有些客户的项目需求比较急，比如一定要在一两个月内完成的这种，客户会加急加钱，那这种客户的优先级就会比较高。

另一种是**普通进程**，大部分的进程其实都是这种。这就好比，大部分客户的项目都是普通的需求，可以按照正常流程完成，优先级就没实时进程这么高，但是人家肯定也有确定的交付日期。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/15/56/a969e60b.jpg" width="30px"><span>拾贝壳的孩子</span> 👍（66） 💬（3）<div>如果优先队列一直有任务,普通队列的task一直得不到处理，操作系统会怎么做呢？
-------------------------------------------------------------------------------------
我现在知道这个问题的答案了。这种现象叫做饿死。我当时想到这个问题时其实不知道这个概念。
为了防止这种现象的发生，操作系统在一定的时间周期会重置所有task的优先级，这样就保证
了低优先级的task得以执行,而不被饿死。但是这个时间设置为多少合适？设置的短了会导致系统的频繁重置。设置的长了，又会使普通优先级的task切换太慢。这个时间一般是系统研究人员研究得到的，我觉得可能可以通过一些统计学上的方式来做。
为了解决task响应时间和完成时间的平衡，现代操作系统如Windows和Linux都依赖于Multi-Level Feedback Queue, 和文章讲的正好对应起来了。首先面对的情况是：
1. 操作系统无法知道每个task何时到来 ？
2. 操作系统无法知道每个task运行完成实际需要多少时间 ？
那么FIFO ShortJobFirst或者Short Time Completed First 算法，面对这两种场景将无从下手。
面对这样的问题，为了使交互性的TASK能够得到快速的响应，提升用户的的体验，同时缩短task 的完成时间。计算机科学家提出了Multi-Level Feedback Queue的解决方案。基本思想是通过优先级保证交互性的task，能够快速响应，同时通过统计task 对CPU的使用时间以期对TASK判断，有点类似于机器学习。
如果某个task 在其时间片里用完前释放CPU， 可以认为这是种交互式的task, 优先级保留。反之认为某个task是需要运行时间长的。同时基于对task 对cpu 时间使用的统计作为判断依据。这样经过一段时间运行后，长时间运行的队列会被逐渐降低优先级。
而快速响应的task 能够优先使用CPU。但是这里面还有两个问题: 首先，如果优先级低的一直得不到cpu, 可能会出现饿死。其次，有人可能会利用这个漏洞编程的方式在使用完CPU时间片后释放CPU，从而控制CPU。 基于此，Multi-feedback-queue有以下5条规则：
1. 如果A的优先级大于B， 则A先运行。
2. 如果A的优先级等于B， 则以RR算法交互运行。
3. 新来的 Task 会被置于最高的优先级。
4. 如果一个task 在其当前优先级运行完被分配的时间片后，会降低其优先级，重置其放弃使用CPU的次数。（这条规则修改过，是为了防止有人利于原有规则的漏洞控制CPU, 原来的规则是如果一个task 在其时间片用完前释放cpu, 则其优先级保持不变， 这个修正增加了对task 实际使用cpu 时间统计作为判断依据）。
5. 系统每过时钟周期的倍数，会重置所有task 的优先级。（这条规则是为了防止task被饿死的，也是我之前所疑惑的）。</div>2019-05-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg" width="30px"><span>Keep-Moving</span> 👍（20） 💬（2）<div>本节讲的是进程的调度，那线程的调度是什么样的呢？Linux调度的基本单位是进程还是线程呢？</div>2019-05-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg" width="30px"><span>刘強</span> 👍（14） 💬（1）<div>感觉这个sched_class结构体类似面向对象中的基类啊,通过函数指针类型的成员指向不同的函数，实现了多态。</div>2019-05-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg" width="30px"><span>kdb_reboot</span> 👍（10） 💬（1）<div>可以通过sched_setscheduler和pthread_setschedparam设置进程和线程的API</div>2019-07-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a2/94/ae0a60d8.jpg" width="30px"><span>江山未</span> 👍（9） 💬（4）<div>有个疑问，sched_class和rq这些结构，都存在内核态的哪里啊，也有一个进程负责维护他们吗，CPU怎么有他们的地址的。。抱歉问题比较多</div>2019-07-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg" width="30px"><span>why</span> 👍（9） 💬（2）<div>如果是新建的进程如何处理, 它 vruntime 总是最小的, 总被调度直到与其他进程相当.</div>2019-05-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg" width="30px"><span>garlic</span> 👍（8） 💬（1）<div>进程线程的API ： http:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man7&#47;sched.7.html, Posix Threads API  http:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man7&#47;pthreads.7.html , 实时调度策略可以设置优先级普通调度策略设置nice值。 线程要设置指定的调度策略， 主线程 PTHREAD_EXPLICIT_SCHED 否则默认集成主线程调度策略。 网上找了个例子验证了一下： https:&#47;&#47;garlicspace.com&#47;2019&#47;07&#47;16&#47;linux-%e8%bf%9b%e7%a8%8b%ef%bc%8c%e7%ba%bf%e7%a8%8b%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5api&#47;</div>2019-07-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg" width="30px"><span>焰火</span> 👍（8） 💬（1）<div>一个task 分配给一个cpu执行后，就不会再被其他cpu 执行了吧？  </div>2019-05-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg" width="30px"><span>奔跑的码仔</span> 👍（5） 💬（1）<div>对于CFS的这个比喻很贴切，之前看过CFS相关的内容，一直找不到如何用一个现实中的过程类比一下。大口袋和小口袋所放入的球的比例一样，对应到CFS，也就是vruntime一样，从这个角度来看，也就是做到了完全的公平！</div>2019-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/03/11/f58c6278.jpg" width="30px"><span>你好呀</span> 👍（3） 💬（1）<div>想要cpu使用率一直100 % 进程的优先级是不是要最高  好一直占用时间片？</div>2019-07-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/90/5d/08f28cb0.jpg" width="30px"><span>叫啥好捏</span> 👍（3） 💬（1）<div>大佬假期也不休息么</div>2019-05-01</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6J3aB8SFk2p54J1NtwZ4fXfxMNlWC4mGH1NAvZicKwCTXbiaRRClb6IicMF2X3VHfnE5mZZiaQhLj2w/132" width="30px"><span>Geek__WMK</span> 👍（2） 💬（1）<div>@why是小灰吧</div>2019-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg" width="30px"><span>nora</span> 👍（2） 💬（1）<div>老师，请教一下 虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD&#47; 权重中NICE_0_LOAD是什么意思呢？cfs调度实体是红黑树，那实时进程呢，是普通队列嘛？</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（2） 💬（3）<div>讲的清晰明了，但是有个疑问，task_struct中为什么需要指向sched_class的指针呢？没想到有啥作用？</div>2019-05-01</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132" width="30px"><span>蹦哒</span> 👍（1） 💬（1）<div>看到SCHED_DEADLINE，想到了React中的Fiber调度策略，优先完成距离超时时间最小的任务</div>2020-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/87/9b/8bebc8b6.jpg" width="30px"><span>Marshall</span> 👍（1） 💬（2）<div>老师一个task绑定完一个cpu以后 还会解绑去然后交给其他cpu吗</div>2019-07-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/7b/32/60089a62.jpg" width="30px"><span>杨领well</span> 👍（1） 💬（1）<div>建议：
1、源码在第一行标记出具体出处（某某文件某某行）
2、文中出现的源码尽量将其标签（如：again）的位置标记出来。</div>2019-05-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/15/56/a969e60b.jpg" width="30px"><span>拾贝壳的孩子</span> 👍（1） 💬（1）<div>如果优先队列一直有任务,普通队列的task一直得不到处理，操作系统会怎么做呢？</div>2019-05-07</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eov38ZkwCyNoBdr5drgX0cp2eOGCv7ibkhUIqCvcnFk8FyUIS6K4gHXIXh0fu7TB67jaictdDlic4OwQ/132" width="30px"><span>珠闪闪</span> 👍（0） 💬（2）<div>刘超老师，每个CPU上的任务队列是谁分配的？什么时候分配的？</div>2020-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/56/35/eeee9309.jpg" width="30px"><span>sun</span> 👍（0） 💬（2）<div>老师，请问同一个task会出现在所有cpu的队列中吗</div>2020-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg" width="30px"><span>奔跑的码仔</span> 👍（0） 💬（1）<div>“如果没有才会去 CFS 运行队列找是否有进行需要运行”</div>2019-08-26</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8a5dg6aBRohA4bQ5KcHdDt6nCnrk0PiarfnVZ3zsgrBbjayAG1bhuAEfyZaNpplnXYDytZlWpfkA/132" width="30px"><span>唐荣轩</span> 👍（0） 💬（1）<div>胖子吃馒头这个例子，改成搬砖吃馒头可能更合适。高级搬砖工吃两个，一般搬砖工吃1个</div>2019-07-20</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/vTku9cFYPh2T8DSImQoPRLxgSibcVgCRYqMcEYibexxLkfn9IKhUSAasZ7QoB72SDWym31niah2y00ibRWdHibibib1wQ/132" width="30px"><span>Regina</span> 👍（0） 💬（1）<div>每个 CPU 都有 rq 结构体，是轮流执行task队列里面的task吗</div>2019-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/ea/c2/445977ea.jpg" width="30px"><span>youyui</span> 👍（0） 💬（2）<div>一个task是不是永远只能绑定在一个CPU的rq上，不会在其他CPU上运行了？有没有 一个CPU比较闲，去其他比较忙的CPU那窃取点任务的机制？</div>2019-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（0） 💬（1）<div>虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD&#47; 权重
同样的实际运行时间，给高权重的算少了，低权重的算多了

这里的权重不是优先级吧，那么权重和优先级是怎么个对应关系呢？

</div>2019-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg" width="30px"><span>郑晨Cc</span> 👍（0） 💬（1）<div>CFS对vruntime 的排序为啥要用复杂的红黑树呢？他只需要知道最小的vruntime和插入新的vruntime ，也不需要随机的查询，按理说用小顶堆更合适的啊 </div>2019-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（0） 💬（1）<div>对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100~139
这里为什么 实时进程 的范围是100，而普通进程的优先级范围才是40 ？
</div>2019-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg" width="30px"><span>nora</span> 👍（0） 💬（3）<div>所以Linux下其实进程和线程一样的，都会占用task，故Linux下线程并不会比进程轻量级？</div>2019-05-08</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132" width="30px"><span>Helios</span> 👍（0） 💬（1）<div>“每次新进程创建完毕后，都会试图先让新的抢占一次”。

那如果不断有新的任务进来，那岂不是对以前的任务不公平了呢，尤其是那些快运行完（可能就差几个时间片了）的任务。</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/3a/d7/454a1b90.jpg" width="30px"><span>leon</span> 👍（0） 💬（1）<div>Linux的最小调度单位是线程，每个进程又至少都有一个线程，当我们在谈Linux调度的时候为啥不说是线程调度？所谓的进程调度是说的也是调度的里面的线程吗？那是不是就没有所谓的进程调度了呢？</div>2019-05-04</li><br/>
</ul>