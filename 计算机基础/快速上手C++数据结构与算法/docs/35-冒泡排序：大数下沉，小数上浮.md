你好，我是王健伟。

前面我带你学习了插入类排序中的直接插入排序和希尔排序，这次，我们讲解另一类排序——交换类排序。

所谓交换类排序，就是根据序列中两个关键字的比较结果，来决定是否要交换这两个关键字对应的记录在序列中的位置。

交换类排序主要包括冒泡排序和快速排序，这在前面已经提到过。这节课，我先带你看一看冒泡排序。

## 冒泡排序基本概念

冒泡排序的英文名称是Bubble Sort，也叫起泡排序。

按照从小到大排序来说，它的基本思想是在有n个元素的序列中，先将第一个记录的关键字和第二个记录的关键字进行比较，也就是两两**比较相邻**记录关键字，如果第一个记录的关键字大于第二个记录的关键字，则交换这两个记录。接着，比较第二个记录的关键字和第三个记录的关键字，如果第二个记录的关键字大于第三个记录的关键字，则交换这两个记录。依次类推，直到第n-1个记录和第n个记录比较完为止。

上述这些过程叫**第一趟**冒泡排序。这样做的结果就是将关键字最大的记录放到了最后一个记录位置上。显然，对于数组{16,1,45,23,99,2,18,67,42,10}，第一趟冒泡排序后，结果为{1,16,23,45,2,18,67,42,10,99}。如图1所示：
<div><strong>精选留言（1）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/2a/f0/82/f235d91d.jpg" width="30px"><span>Yj.yolo</span> 👍（2） 💬（2）<div>【思考题回答】
1、两种方式的区别就是两个数交换的条件不同，从大到小排序是前面的数比后面的小的时候交换，而从小到大排序是前面的数比后面的数大的时候交换
2、进一步优化冒泡排序算法的方法：
        记录最后一次交换的索引，作为下一次冒泡的比较次数。
        这样操作可以让某个数组中后面“大部分”已经有序的情况下，无需再比较额外的次数。

基于该篇文章给出来的代码，修改如下

&#47;&#47;冒泡排序（从小到大）
template&lt;typename T&gt;
void BubbleSort(T myarray[], int length)
{
  if (length &lt;= 1) &#47;&#47;不超过1个元素的数组，没必要排序
    return;
  
  int num = length - 1;
  
  &#47;&#47;外层循环只控制排序的趟数
  while (true) {
    int last = 0; &#47;&#47;最后一次交换索引问题
    &#47;&#47;内层循环控制元素的大小比较和交换位置
    for (int j = 0; j &lt; num; ++j) &#47;&#47;每趟比较的次数都会减少
    {
      if (myarray[j] &gt; myarray[j + 1])  &#47;&#47;前面的数据如果比后面的数据大
      {
        &#47;&#47;交换元素位置
        T temp = myarray[j + 1];
        myarray[j + 1] = myarray[j];
        myarray[j] = temp;
        last = j;  &#47;&#47; 发生最后交换的索引
      }
    } &#47;&#47;end for j

    num = last;  &#47;&#47;最后交换的索引当做下次遍历时比较次数
    if(num == 0) {  &#47;&#47; 没有发生交换，退出循环
      break;
    }

  }

  return;
}</div>2023-06-08</li><br/>
</ul>