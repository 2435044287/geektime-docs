你好，我是王健伟。

我们已经一起学习了不少主要的数据结构知识。不知你学得怎么样了，是不是很轻松呢？从这节课开始，咱们就要进入到算法知识的学习了。

这一次，我们学习一下“排序”算法。

无论是日常生活还是很多科学领域当中，排序都是会经常面对的问题，比如按成绩对学校的学生排序，按薪水多少对公司员工排序等。

根据在排序过程中待排序的数据是否全部被载入到内存中，排序分为内部排序和外部排序。接下来我为你介绍的各种排序算法涉及的主要是内部排序，包含各种经典的内部排序算法。

我将按照对**数据操作方式**的不同来分类讲解。这里先给你提供一个思维导图。

![](https://static001.geekbang.org/resource/image/1b/09/1b8e6be12dee5213ff3cdc82ed7d7109.jpg?wh=1568x1190)

在讲解具体的排序算法之前，我们先一起看一些它的基本概念。

## 排序算法有哪些基本概念？

所谓排序（Sort），就是将一组数据（也称元素），按照一定的规则调换位置，使这组数据按照递增或递减的顺序重新排列。例如数据库中有一个“学生表”，可以针对该表中的“年龄”字段进行排序，那么这个待排序的字段就称为键（key）或者关键字。排序一般是为了让查找数据的效率变得更高。

这里涉及一个**排序算法的稳定性问题。**依旧以“学生表”为例，假如表中数据如下：

![](https://static001.geekbang.org/resource/image/53/4d/533ed617d199eb08f5bcb19c674d104d.jpg?wh=1533x485 "图1 学生表数据")

在图1所示的学生表中，需要针对表中的“年龄”字段（键）按照某种排序算法进行递减或者递增排序。此时（排序前）张三和赵六的年龄都是27岁且张三这条记录位于赵六之前，而在排序后，如果张三这条记录依旧位于赵六之前，那我们就说这种排序算法是稳定的，如图2所示：
<div><strong>精选留言（1）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/2a/f0/82/f235d91d.jpg" width="30px"><span>Yj.yolo</span> 👍（2） 💬（1）<div>带哨兵的直接插入排序，思想就是利用数组中的第一个位置暂存待插入的元素而不使用临时变量，这样有一个好处是防止数组下标越界：即如果没有哨兵，for循环就会多一次判断数组下表有没有越界，所以使用数组下表能一定程度上提高效率。

以下为修改后代码

&#47;&#47;直接插入排序（从小到大）
template&lt;typename T&gt;&#47;&#47;T代表数组元素类型
void InsertSort(T myarray[], int length) &#47;&#47;myarray：要排序的数组元素，length：数组中元素数量
{
  if (length &lt;= 1) &#47;&#47;不超过1个元素的数组，没必要排序
    return; 
  
  for (int i = 2; i &lt;= length; ++i) &#47;&#47;从第2个元素（下标为2，因为第一个位置被当做哨兵位置了）开始比较
  {
    if (myarray[i] &lt; myarray[i - 1]) 
    {
      myarray[0] = myarray[i];   &#47;&#47;暂存myarray[i]值，防止后续移动元素时值被覆盖        
      int j;
      for (j = i - 1; myarray[j] &gt; myarray[0]; --j) &#47;&#47;检查所有前面排好序的元素，由于myarray[j]不可能比myarray[0]小，所以这里无需对数组下标进行额外判断
      {
        myarray[j + 1] = myarray[j]; &#47;&#47;所有大于temp的元素都向后移动
      } &#47;&#47;end for j
      myarray[j + 1] = myarray[0]; &#47;&#47;复制数据到插入位置，注意j因为被减了1，这里加回来
    } &#47;&#47;end if
  } &#47;&#47;end for i
  return;
}</div>2023-06-08</li><br/>
</ul>