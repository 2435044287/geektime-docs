你好，我是王健伟。

上节课介绍的KMP模式匹配算法是通过next数组参与计算来达到加速匹配的目的。但是，在next数组中，因为没考虑当前字符的位置情况，只考虑了字符不匹配时单纯的指针移动问题（point1和point2值的改变），这很可能导致移动后将进行比较的字符仍和上一次不匹配的字符相同导致产生多次重复的无效比较。

那这个问题要怎么解决呢？别着急，我们一步一步分析。

## next数组使用中暴露的问题

下面我会用一个相对简单点的主串和子串，通过图示说明多次重复无效比较这件事。

假设主串S为“aaacaaaabeg”，子串T为“aaaab”，可以求得子串的next数组为如图1所示：

![](https://static001.geekbang.org/resource/image/7f/d3/7f9705851e26e89d422c1dfd70eefdd3.jpg?wh=1388x419 "图1 子串“aaaab”对应的next数组")

主串与子串开始比较。当比较到下标为3的位置时，子串中的字符是a，主串中的字符是c，两者不同了，如图2所示：

![](https://static001.geekbang.org/resource/image/24/ff/245a2df789d0d1e8da3750a530f2e5ff.jpg?wh=1650x702 "图2 主串的point1指针所指向的字符c与子串point2指针所指向的字符a进行比较")

依据子串的next数组（依据next\[3]的值），子串的point2指针应该恢复到子串第3个字符位置再用该位置的字符a与主串中point1所指向的字符c做比较，如图3所示：

![](https://static001.geekbang.org/resource/image/56/2b/56b8a512b9f8ec4fafb420e726be5b2b.jpg?wh=1558x872 "图3 主串的point1指针所指向的字符c与子串point2指针所指向的字符a进行比较")

图2中已经进行了主串中的c和子串中的a比较，而图3又再次进行了主串中的c和子串中的a比较，显然这第2次比较毫无意义。

第2次主串中的c和子串中的a再比较，两者还是不同，依据子串的next数组（依据next\[2]的值），子串的point2指针应该恢复到子串第2个字符位置再用该位置的字符a与主串中point1所指向的字符c作比较，如图4所示：