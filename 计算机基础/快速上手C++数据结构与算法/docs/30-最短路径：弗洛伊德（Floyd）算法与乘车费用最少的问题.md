你好，我是王健伟。

上节课我和你分享了用迪杰斯特拉（Dijkstra）算法求解最短路径。除此之外，还有一个求解最短路径的方法——佛洛依德（Floyd）算法。

那他们有什么不同吗？

如果说迪杰斯特拉算法比较适合一次性求某个顶点到其他**各个**顶点的最短路径信息，那么这节课所讲的佛洛依德算法往往比较适合求某个顶点到**另外一个**顶点的最短路径信息。

此外，迪杰斯特拉算法是不断计算从开始顶点到其他各个顶点的最短距离。而佛洛依德算法是通过从开始顶点到目标顶点之间不断增加新的顶点进行试探，看是否开始顶点和目标顶点之间的路径变短来求解最短路径的。

## 佛洛依德（Floyd）算法详解

这个算法是美国的一位计算机科学家罗伯特·弗洛伊德提出的，用于求解每一对顶点之间的最短路径。

这个算法实现的大致思路是什么呢？

那就是对任意一对顶点之间的最短路径的计算，都要进行|V|次试探。那么，每次试探都向图中加入一个新顶点，再去比较加入这个顶点之后这对要求解的顶点之间的最短路径是否变得更短，如果更短，则这条路径被采纳。以此类推，经过|V|次比较后，最后必然能够得到要求解的顶点之间的最短路径。

这里以图1所示的带权值有向图为例来讲解这个算法。图中同时展示了存储图中数据的邻接矩阵，为描述方便，我也标示出了每个顶点对应的下标。
<div><strong>精选留言（1）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/2a/f0/82/f235d91d.jpg" width="30px"><span>Yj.yolo</span> 👍（1） 💬（1）<div>【思考题】
（1）弗洛伊德算法
①是一种动态规划算法，通过比较任意两点之间的距离来不断更新距离矩阵，直到求得任意两点之间的最短路径。
②具体实现过程中，弗洛伊德算法需要先构建出邻接矩阵表示图的连接情况，然后利用两个循环嵌套的方式，遍历每一个节点，同时更新任意两点之间的距离。
③该算法的时间复杂度为 O(N^3)，适用于较小的图。（N即顶点个数）
（2）迪杰斯特拉算法
①是一种贪心算法，通过从起点开始遍历图中的每个节点，找出距离起点最近的节点，并将其加入到最短路径集合中，然后以该节点为基础，更新起点到其他节点的距离。
②具体实现过程中，迪杰斯特拉算法需要利用一个距离矩阵和一个 visited 数组来表示节点之间的距离和是否被访问过。
③该算法的时间复杂度为 O(N^2)，适用于较大的图。（N即顶点个数）</div>2023-07-19</li><br/>
</ul>