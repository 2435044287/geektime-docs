和学习小学数学一样，学完了加法之后，我们自然而然就要来学习乘法。既然是退回到小学，我们就把问题搞得简单一点，先来看两个4位数的乘法。这里的4位数，当然还是一个二进制数。我们是人类而不是电路，自然还是用列竖式的方式来进行计算。

十进制中的13乘以9，计算的结果应该是117。我们通过转换成二进制，然后列竖式的办法，来看看整个计算的过程是怎样的。

![](https://static001.geekbang.org/resource/image/49/4b/498fdfa2dc95631068d65e0ff5769c4b.jpg?wh=2523%2A939)

## 顺序乘法的实现过程

从列出竖式的过程中，你会发现，二进制的乘法有个很大的优点，就是这个过程你不需要背九九乘法口诀表了。因为单个位置上，乘数只能是0或者1，所以实际的乘法，就退化成了位移和加法。

在13×9这个例子里面，被乘数13表示成二进制是1101，乘数9在二进制里面是1001。最右边的个位是1，所以个位乘以被乘数，就是把被乘数1101复制下来。因为二位和四位都是0，所以乘以被乘数都是0，那么保留下来的都是0000。乘数的八位是1，我们仍然需要把被乘数1101复制下来。不过这里和个位位置的单纯复制有一点小小的差别，那就是要把复制好的结果向左侧移三位，然后把四位单独进行乘法加位移的结果，再加起来，我们就得到了最终的计算结果。

对应到我们之前讲的数字电路和ALU，你可以看到，最后一步的加法，我们可以用上一讲的加法器来实现。乘法因为只有“0”和“1”两种情况，所以可以做成输入输出都是4个开关，中间用1个开关，同时来控制这8个开关的方式，这就实现了二进制下的单位的乘法。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（89） 💬（11）<div>最后一个的展开电路图，没有看懂</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/85/bf/5c5e86bb.jpg" width="30px"><span>旺旺</span> 👍（38） 💬（2）<div>从加法到乘法，先是计算过程变得复杂了，步骤变得更多，可以像人一样，逐位计算，但线性带来时间复杂度高。从而可以考虑通过增加线路&#47;硬件复杂度，从空间换时间的思路，加快乘法速度。
空间 vs  时间。
但CPU毕竟也是很珍贵的资源，晶体管也不宜太多，这中间需要相互平衡。</div>2019-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg" width="30px"><span>活的潇洒</span> 👍（14） 💬（3）<div>“这之间的权衡，其实就是计算机体系结构中的RISC和CISC的经典历史路线之争”
这句才是重点，day14 笔记：https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;10929985.html</div>2019-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9c/07/14f1088b.jpg" width="30px"><span>WB</span> 👍（12） 💬（1）<div>最后一张图片中的加法器是一个与门和一个或门？？
加法器不是由一个与门和一个异或门组成的吗？</div>2019-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg" width="30px"><span>愤怒的虾干</span> 👍（5） 💬（1）<div>老师好，最近在看您推荐的计算机组成公开课，x86保护模式下会使用全局符号描述表寻址，同时操作系统又是使用页表来分配地址、映射物理和逻辑地址。我想问全局符号描述表和页表在寻址上有什么区别与联系？</div>2019-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0c/09/a46ad0a6.jpg" width="30px"><span>Become a architect</span> 👍（2） 💬（1）<div>我想现在并发编程的思想起源于此吧。效率确实高了，但是编程的复杂度变高了。</div>2019-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg" width="30px"><span>木心</span> 👍（2） 💬（2）<div>4位加法器的最大门延迟是进位，是2＊4＋1 9个门延迟</div>2019-09-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ce/4f/3a89d29a.jpg" width="30px"><span>J.D.Chi</span> 👍（2） 💬（1）<div>“把结果加到刚才的结果上”，想起了编程语言里的 sum = sum + i 之类的语句。</div>2019-09-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/46/be/d3040f9e.jpg" width="30px"><span>小广</span> 👍（0） 💬（1）<div>徐老师你好，最后那个展开图，第二列的最下面一个运算组件，标注的表达式是&quot;P3*P2*P1*P0*G0&quot;，但是我认为这里是笔误，应该是&quot;P3*P2*P1*P0*C0&quot;，应该把G0改为C0，^_^</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg" width="30px"><span>Dylan</span> 👍（15） 💬（1）<div>CPU做除法时和做乘法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。除数右移，商左移，商左移后最右位补0还是1取决于，本次余数和除数相减后余数最高位，最高位1则，回退；0那么商左移后最右位补1。</div>2020-02-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（5） 💬（1）<div>老师好!前面的意思大概看懂了，最后那个优化版本的加法器看不懂了。。。</div>2019-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/3b/f5/4931260b.jpg" width="30px"><span>冰凉的咖啡</span> 👍（3） 💬（0）<div>晶体管的增加，意味着功耗的增加吧，这也就是为什么移动端的ARM架构的CPU采用的精简指令集，而PC的X86架构却采用的是复杂指令集。</div>2021-03-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/22/d7/db041954.jpg" width="30px"><span>haoly1989</span> 👍（3） 💬（0）<div>除法器算法实现描述：
步骤1 从余数寄存器中减去除数寄存器中的值，将结果保存在除数寄存器中；
步骤2 测试余数是否小于0
如果余数小于0，则执行步骤2b；
否则，执行步骤2a；
步骤2a 将商寄存器左移，且最低位设置为1；
步骤2b 将余数寄存器的值跟除数寄存器的值相加，结果存放在余数寄存器中；将商寄存器左移，最低位设置为0；
步骤3 将除数寄存器右移1位
步骤4 测试是否第N+1次执行
如果是，则结束；否则，跳转到步骤1执行；</div>2019-08-14</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0RWHypVI6QkiaeLxnOs96ZlJShWBDicwBm8fFRP2nkrpyxA03A5jnMNAEZZuS200QFM4w52vG5dwg/132" width="30px"><span>张驰</span> 👍（2） 💬（0）<div>所以各种“门”也不一定必须是两路输入信号，像 C4 有4路输入信号也是可以的是吧？</div>2021-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg" width="30px"><span>李二木</span> 👍（2） 💬（0）<div>可以配套看视频https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1VE411o7nx?p=21</div>2021-04-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg" width="30px"><span>X</span> 👍（1） 💬（0）<div>这章看的好吃力了，已经过了两遍了，继续加油。
不言放弃，这次要补回大学欠下的东西。</div>2022-08-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/86/cc/d63bb0f2.jpg" width="30px"><span>苏格拉没底</span> 👍（1） 💬（0）<div>就是时间与空间的互换,和软件中的算法一样</div>2021-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0f/c0/e6151cce.jpg" width="30px"><span>花仙子</span> 👍（1） 💬（0）<div>对于最后那个优化版本的加法器，我的理解是这样的：每一位都是又全加器组成，而每个全加器由两个半加器和一个或门电路组成，其中一个半加器是计算每个位相加的和进位信息无关，所以这个半加器在各个位上可以同时并行计算，同时计算后每个位会得出相加结果Y和进位信息U，Y与上一位的进位信息W0用另一个半加器相加后得到结果Z和进位信息V，Z为此位最终相加结果，U和V通过或门电路计算可得出最终进位信息W提供给下一位进行同样的计算。这样看来似乎第二个半加器和或门电路计算还是要依赖上一位同样的计算得出的进位信息，貌似这里无法并行。但是真的就此结束了吗？看老师给出的图我的理解是这样的：每一位的运算公式是这样的：W=U||V，Z=（Y+W0）1，V=（Y+W0）2，（请允许我这里用+表示半加器，后缀1表示半加器得到的相加结果，后缀2代表半加器得到的进位信息），而W0=U0||V0，所以有Z=（Y+（U0||V0））1，W=U||（Y+W0）2，这样以来即便是最高位也能得到一个基于各位第一个半加器计算结果的逻辑表达式，对于人类来解这个表达式似乎也没有优化效果，但是正如老师所说电路的天然并行行，我们将这个很长的表达式展开，硬件就可以并行计算很多小步骤，从而得到空间换时间的巨大效率提升。</div>2019-07-03</li><br/><li><img src="" width="30px"><span>Geek_88604f</span> 👍（0） 💬（0）<div>1、电脑的计算实现方式和人脑的思考方式差别挺大，电脑可以提前进位，人脑通常做不到。不知道最强大脑里面的人是不是掌握了提前进位。
    2、被乘数左移是为了在做加法的时候对齐位次，乘数右移是为了找到下一次要相乘的位。
    3、乘法器内部控制测试部件的四个输出信号就有时钟信号和乘数当前需要ALU计算的移出位，一个输入信号应该会包括乘数左移出的位以及结束信号。</div>2023-10-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/96/a7/a9bfe8d3.jpg" width="30px"><span>漂泊者</span> 👍（0） 💬（0）<div>后面的电路图后面基层电路有多个输入，一个门电路输入都是2个，可以同时接受多个输入吗。这也是多个门组合的抽象图吧</div>2023-02-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/7e/5a/da39f489.jpg" width="30px"><span>Ethan New</span> 👍（0） 💬（0）<div>是用更少更简单的电路，但是需要更长的门延迟和时钟周期；还是用更复杂的电路，但是更短的门延迟和时钟周期来计算一个复杂的指令，这之间的权衡，其实就是计算机体系结构中 RISC 和 CISC 的经典历史路线之争。</div>2022-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a5/70/d7b70282.jpg" width="30px"><span>张无忌</span> 👍（0） 💬（0）<div>1个半加器有2个门电路：异或门+与门，1个全加器由2个半加器和1个或门组成，也就是一个全加器共有5个门，所以没太明白为什么全加器的门延迟是3T，而不是5T。希望老师解答，谢谢！</div>2022-10-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a5/70/d7b70282.jpg" width="30px"><span>张无忌</span> 👍（0） 💬（1）<div>“把被乘数左移一位，把乘数右移一位”，那他们两个岂不是错开两位？</div>2022-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg" width="30px"><span>X</span> 👍（0） 💬（0）<div>弄懂了7788了吧，顺序乘法器、并行乘法器，引出了门延迟和时钟频率带来的性能影响。使用“牺牲空间，追求时间”的方法，提升更多的晶体管，复杂电路的方式，追求更好的计算性能。</div>2022-08-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg" width="30px"><span>X</span> 👍（0） 💬（0）<div>最后一个图老师画的应该是加法器的电路图？
全加器是一位一位的累加的，每一个进位都需要耗费3个门延迟。如果两个64位的二进制做累加，那么门延迟就需要63 * 3个。
除了门延迟之外就是时钟频率，每一次的开闭电路就是一次时钟频率，因为高位需要等低位的进位信息，所以说，对两个64位二进制做加法，需要等待63次进位，也就是说要63个时钟频率，而这个时钟频率是比门延迟和夸张耗时的东西。
所以如果单独用全加器做加法运算的话，那么会变得很耗时。需要63 *3 的门延迟还有63个时钟频率。
所以我们需要通过复杂电路，让其耗时更短，加法器直接做4位二进制的累加。总体速度快了很多。</div>2022-08-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg" width="30px"><span>X</span> 👍（0） 💬（0）<div>看第三遍，终于看懂了一点。
继续第四遍……</div>2022-08-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e7/20/70a95f94.jpg" width="30px"><span>潮汐</span> 👍（0） 💬（0）<div>第一遍没看懂，第二遍再读的时候，就明白了每一步每一步的含义，老师讲的太好了</div>2022-08-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/d1/2e/d531b29b.jpg" width="30px"><span>图吐兔</span> 👍（0） 💬（0）<div>c4提前算出来了，但整个计算结果得要c0-c3算完才能得到，这的话整体上不就只少了一个T吗？</div>2022-04-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/27/f2/50ba2f35.jpg" width="30px"><span>憨豆桑</span> 👍（0） 💬（0）<div>以前觉得异步的控制电路设计得好，现在觉得同步的设计才是真大哥。</div>2022-03-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/e0/09/919e001e.jpg" width="30px"><span>伟大的疯狂</span> 👍（0） 💬（0）<div>&quot;一个全加器，其实就已经有了 3T 的延迟（进位需要经过 3 个门电路）。而 4 位整数，最高位的计算需要等待前面三个全加器的进位结果，也就是要等 9T 的延迟。如果是 64 位整数，那就要变成 63×3=189T 的延迟。这可不是个小数字啊！&quot;
这个地方我看了北大《计算机组成》原理，不知道是不是作者计算不对，对于4位整数，最长的门延迟包括最低位的三个门和高三位的两个门，计算方法为2*4+1=9，那么对于64位整数，应该是64*2+1=129，不是63*3</div>2022-03-09</li><br/>
</ul>