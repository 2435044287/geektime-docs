过去两讲，我为你讲解了通过增加资源、停顿等待以及主动转发数据的方式，来解决结构冒险和数据冒险问题。对于结构冒险，由于限制来自于同一时钟周期不同的指令，要访问相同的硬件资源，解决方案是增加资源。对于数据冒险，由于限制来自于数据之间的各种依赖，我们可以提前把数据转发到下一个指令。

但是即便综合运用这三种技术，我们仍然会遇到不得不停下整个流水线，等待前面的指令完成的情况，也就是采用流水线停顿的解决方案。比如说，上一讲里最后给你的例子，即使我们进行了操作数前推，因为第二条加法指令依赖于第一条指令从内存中获取的数据，我们还是要插入一次NOP的操作。

![](https://static001.geekbang.org/resource/image/49/2d/49f3a9b1ae2972ac5c6cfca7731bf12d.jpeg?wh=2497%2A640)

那这个时候你就会想了，那我们能不能让后面没有数据依赖的指令，在前面指令停顿的时候先执行呢？

答案当然是可以的。毕竟，流水线停顿的时候，对应的电路闲着也是闲着。那我们完全可以先完成后面指令的执行阶段。

## 填上空闲的NOP：上菜的顺序不必是点菜的顺序

之前我为你讲解的，无论是流水线停顿，还是操作数前推，归根到底，只要前面指令的特定阶段还没有执行完成，后面的指令就会被“阻塞”住。

但是这个“阻塞”很多时候是没有必要的。因为尽管你的代码生成的指令是顺序的，但是如果后面的指令不需要依赖前面指令的执行结果，完全可以不必等待前面的指令运算完成。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg" width="30px"><span>88591</span> 👍（55） 💬（2）<div>应该是数据一致性问题，多核访问相同的内存。但是有自己的缓存，寄存器。</div>2019-12-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg" width="30px"><span>许先森</span> 👍（0） 💬（1）<div>我的思考是上面的例子只是简单的计算，会不会是后面有一些逻辑运算对a和x的结果读取有顺序要求，如果不保证先正确读取a再正确读取到x的话会对逻辑运算有影响。</div>2020-01-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg" width="30px"><span>许先森</span> 👍（0） 💬（1）<div>“3. 这些指令不会立刻执行，而要等待它们所依赖的数据，传递给它们之后才会执行。这就好像一列列的火车都要等到乘客来齐了才能出发。”
这里有个问题啊，所有指令都是在保留站中等待自己依赖的数据，那如果依赖的是上一条指令的结果呢？</div>2020-01-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/69/bf/58f70a2a.jpg" width="30px"><span>程序员花卷</span> 👍（0） 💬（2）<div>我觉得如果不保证它们的执行顺序的话，那最终得到的结果也可能不是我们期望的结果</div>2019-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/1e/5d/62fdc917.jpg" width="30px"><span>Mango</span> 👍（0） 💬（1）<div>思考题，感觉是内存屏障，防止多核CPU操作共享内存时出现数据冒险问题。</div>2019-08-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg" width="30px"><span>焰火</span> 👍（26） 💬（3）<div>数据从cpu --&gt; 寄存器 --&gt; 内存， 数据从CPU到内存中间有个寄存器，寄存器和内存数据交换应该也是整页交换，如果不顺序写回寄存器的话，很有可能在寄存器页边界的时候，到内存发生时间差，导致后面寄存器再重新取内存的时候发生数据错误，之前数据不依赖，不保证后面数据不依赖。所以还是顺序写回比较安全。</div>2019-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg" width="30px"><span>xindoo</span> 👍（10） 💬（2）<div>我觉得强内存模型是为了保证不同指令对同一内存地址的读写正确性，不同指令的执行不仅仅有寄存器数据依赖，还会有内存数据依赖。</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg" width="30px"><span>zhengfan</span> 👍（4） 💬（0）<div>徐老师您好。我有两个问题如下：
1. 乱序执行是否在debug模式下不启用？还是说reorder输出后，已经满足了单步执行下的顺序？
2. 乱序执行这样的优化是否对编码过程透明？换言之，编码过程中有意识的遵从乱序原则，是否会对运行效率有影响？个人感觉是会有影响的，至少在reserve和reorder两个阶段降低了排序难度。您认为呢？</div>2020-04-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg" width="30px"><span>有米</span> 👍（4） 💬（1）<div>老师您好！乱序执行就是我们平时说的指令重排么？</div>2020-03-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/56/35/eeee9309.jpg" width="30px"><span>sun</span> 👍（2） 💬（0）<div>比如 两个线程分别在两个核中执行fun1（）{int i1=1; int i2=i1+1; boolean b = true;）和fun2（）{if(b) {System.out.println()i2}},假设 协会阶段不是顺序的，b=true被先写回缓存中，此时因为内存屏障，同步到主存中b位true，i2为0，另一个线程输出0，也就是说如果不保证最后的写回阶段有序，内存屏障也会失效？？
请问老师是这样吗？</div>2020-04-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/eb/19/19e706a5.jpg" width="30px"><span>cc</span> 👍（2） 💬（4）<div>老师，有一点没想明白。五级流水线，取指令-译指令-执行-访存-写回。这里的访存是干什么的？能否具体举例讲一讲？我理解访存是把数据读入寄存器。那这样的话，访存应该先于执行才对。感谢答疑</div>2019-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg" width="30px"><span>geraltlaush</span> 👍（2） 💬（2）<div>搜了下资料，假如有两个阶段，之间没有数据依赖，第一个阶段判断变量a是否为true，再执行，否则退出。第二个阶段直接把a置为false，如果乱序执行，第二个阶段先执行影响业务逻辑，第一个阶段本来可以执行的，现在直接退出了</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/75/35/a0c15ca8.jpg" width="30px"><span>一頭蠻牛</span> 👍（1） 💬（0）<div>老师 请问保留站靠什么“保留”数据   它又是什么 cpu缓存，内存，还是寄存器</div>2022-06-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/81/e9/d131dd81.jpg" width="30px"><span>Mamba</span> 👍（0） 💬（0）<div>最重要的原因是确保程序的可预测性和正确性。保障内存访问顺序能够确保程序员编写的代码在内存访问方面的行为符合预期，这是多线程编程和同步机制正确工作的基础，也是维护系统稳定性和可靠性的关键。</div>2024-08-24</li><br/><li><img src="" width="30px"><span>Geek_88604f</span> 👍（0） 💬（0）<div>这里确实是为了保障数据一致性而强制做一次数据同步。但并不是每次都是必须的，这里面可能还有优化空间，就是按需同步，当后面的数据依赖前面的数据时才做同步</div>2023-11-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg" width="30px"><span>静✨</span> 👍（0） 💬（0）<div>二刷，莫名想到tcp协议的实现…</div>2022-11-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg" width="30px"><span>一格状语</span> 👍（0） 💬（0）<div>图2的执行EX，怎么看上去占了2个时钟周期，不是每个阶段都是1个时钟周期吗？求解</div>2022-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/aa/62/78b45741.jpg" width="30px"><span>Morty</span> 👍（0） 💬（0）<div>分手厨房就是一个类似CPU流水线设计的游戏呀</div>2022-11-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/82/d1423f4c.jpg" width="30px"><span>三刀</span> 👍（0） 💬（0）<div>&quot;也充分利用了较深的流水行带来的并发性&quot;---流水行-&gt;流水线</div>2022-11-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/3e/f0/9e7288d2.jpg" width="30px"><span>一棹烟波</span> 👍（0） 💬（0）<div>老师，您好。请问乱序执行需要在编写代码层面，对多条C++语句进行重排，还是编译器会自行优化重排。</div>2021-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/75/f0/2c65887d.jpg" width="30px"><span>活着即是修行</span> 👍（0） 💬（0）<div>我们在进行CPU乱序执行的过程中，可以认为是在译码和执行的过程中增加了一个缓冲层，这样可以让CPU能够选择满足条件的指令进行执行。在指令执行完结果之后，CPU又将结果按照指令译码的顺序重排序，这样做是保证新数据不会被旧数据给覆盖。</div>2021-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/24/d3/a9/2b84cc97.jpg" width="30px"><span>乡村爱情代言人-刘能</span> 👍（0） 💬（0）<div>课后思考问题。应该说的是多线程下的访问和回写问题。课程现在介绍的都是基于单核的</div>2021-08-15</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyNezT33TyZdPI8DtRe7LzV9geutjMkaNNByOkyMXhNQVia5CJE54lWrBpicftq7jdo8bCcXhokjUQ/132" width="30px"><span>Geek_337e21</span> 👍（0） 💬（0）<div>思考题：是不是因为数据的局部性存储原理，一般顺序位置相近的指令访问的数据都会集中在某一块地方，可以从高速缓存中加载，速度快，而如果乱序执行，缓存可能就失去了意义，需要不停更新缓存，从内存中获取数据。</div>2021-08-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg" width="30px"><span>skye</span> 👍（0） 💬（0）<div>C++11引入的内存模型，如果不采用强内存模型，那访存和写回阶段是不是就不要遵循取指顺序了？</div>2021-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/e3/01/a254f22d.jpg" width="30px"><span>童言</span> 👍（0） 💬（0）<div>指令的乱序执行：解决了ALU空闲等待的问题。通过加入保留站，使译码后的指令进行统一管理，ALU直接与保留站对接。由于保留站具有视野的全局性，能够知道哪些指令是没有依赖的，因此可以下发给ALU进行执行。
感觉有点像Go语言的GMP模型，M就是ALU，P就是保留站，G就是若干的译码后的指令。</div>2021-05-05</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKG6nZXNOaobCtd2XQbnoh0QcovEDn6MfqXxhC4niaAeK8BZ7a2l87Q4wDE00FNUXS9MeOyLrmZWAw/132" width="30px"><span>城北时公</span> 👍（0） 💬（2）<div>请问，多线程情况下，加volatile关键字，不但会禁止指令重排序，也会禁止CPU乱序执行么？</div>2021-02-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6d/87/21e516ec.jpg" width="30px"><span>林杨</span> 👍（0） 💬（0）<div>讲的真好，必需点赞下</div>2021-02-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3e/e9/116f1dee.jpg" width="30px"><span>wy</span> 👍（0） 💬（1）<div>老师，假如有两个操作
a=1+2;
a=2+2;
最后a是3还是4？</div>2020-08-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg" width="30px"><span>A君</span> 👍（0） 💬（0）<div>乱序分发，在固定的流水线的上游装了个调度器，alu少浪费</div>2020-06-30</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132" width="30px"><span>WENMURAN</span> 👍（0） 💬（0）<div>冒险和预测三:
解决流水线停顿的方案，
流水线停顿的时候，对应的电路也是停着的，这时我们可以先把后面的指令调到前面来先执行，充分利用这个空挡。
有些指令必须依赖前面指令的数据，有些则不用，我们才用乱序执行的方法，把这些没有前后依赖的指令可以提前利用空挡执行，就相当于在CPU里面创造一个进程池。哪个指令准备就绪就执行哪个，某一个发生阻塞时，先执行其他指令。
指令执行完后，按照前面指令的顺序返回数据。</div>2020-04-17</li><br/>
</ul>