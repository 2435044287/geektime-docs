你好，我是宫文学。今天，我们继续一起学习垃圾收集的实现机制以及与编译器的关系。

对于一门语言来说，垃圾收集机制能够自动管理从堆中申请的内存，从而大大降低程序员的负担。在这门课的第二大模块“真实编译器解析篇”中，我们学习Java、Python、Go、Julia和JavaScript这几门语言，都有垃圾收集机制。那在今天这一讲，我们就来学习一下，这些语言的垃圾收集机制到底有什么不同，跟语言特性的设计又是什么关系，以及编译器又是如何配合垃圾收集机制的。

这样如果我们以后要设计一门语言的话，也能清楚如何选择合适的垃圾收集机制，以及如何让编译器来配合选定的垃圾收集机制。

在讨论不同语言的垃圾收集机制之前，我们还是需要先了解一下，通常我们都会用到哪些垃圾收集算法，以及它们都有什么特点。这样，我们才能深入探讨应该在什么时候采用什么算法。如果你对各种垃圾收集算法已经很熟悉了，也可以从这一讲的“Python与引用计数算法”开始学习；如果你还想理解垃圾收集算法的更多细节，也可以去看看我的第一季课程《编译原理之美》的[第33讲](https://time.geekbang.org/column/article/162854)的内容。

## 垃圾收集算法概述

垃圾收集主要有标记-清除（Mark and Sweep）、标记-整理（Mark and Compact）、停止-拷贝（Stop and Copy）、引用计数、分代收集、增量收集和并发收集等不同的算法，在这里我简要地和你介绍一下。
<div><strong>精选留言（3）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/a7/4d/096e99ec.jpg" width="30px"><span>Tino＇s Park</span> 👍（2） 💬（2）<div>文章有几个问题请教下：
1. Go的GC目前为止(1.14.3)是非分代，非移动的并发算法（三色标记）算法，不是分代的；
2. 并发标记算法还有有一个问题，就是write-barrier在扫描期间，也需要一直运行，从而干扰业务的执行；
3. 关于STW，在大数据量下目前很难做到较优吧。
</div>2020-09-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg" width="30px"><span>D</span> 👍（0） 💬（1）<div>增加内置关键字支持不可变对象，比如像rust，Scala等语言。</div>2020-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg" width="30px"><span>写点啥呢</span> 👍（0） 💬（1）<div>请问宫老师，增量收集算法，看上去是在增量做标记，这样可以尽量不打断程序的情况下完成标记（屏障代码会带来一定性能影响），不知道我的理解对么？

进而有个疑问，如果程序的对象变化非常频繁，导致增量过程一直无法完成（就是灰色集合始终不为空）那什么时候才能做内存回收释放呢？</div>2020-08-26</li><br/>
</ul>