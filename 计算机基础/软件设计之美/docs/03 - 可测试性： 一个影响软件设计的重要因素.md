你好！我是郑晔。

上一讲，我们讲了软件设计的第一步：分离关注点。作为至关重要的第一步，分离关注点常常被人忽略，严重影响了设计的有效性。这一讲，我们再来看另一个经常被很多人忽视的因素：可测试性。

在讨论可测试性之前，我们不妨先来思考一个问题：你觉得软件开发中最浪费时间的环节是什么？答案肯定不是写代码，因为写代码是一个建设的过程，谈不上是在浪费时间。在我接触过的诸多项目里，集成测试可以说是一个浪费时间的大户。

那你的项目是怎么做集成测试的呢？一个常见的测试场景是这样的：你先花了一些时间打包部署一个服务端应用，然后开始测试。测着测着，你发现一个Bug，然后调查半天，最后发现是一个简单的错误。你就在心里暗恨，为啥写代码的时候没发现呢！

这还只是一个简单的场景，也有稍微复杂一点的。比如，有多个不同项目组的人一起联合测试。当你测出一个Bug，然后辛辛苦苦调查半天，发现是另外一个模块出了问题，你唯一能做的就是等着那个组的同事把Bug改好，测试才能进行下去。更可恨的是，他们查了半天，结果也是一个简单的错误。你会在心里嘀咕，为啥写代码的时候不仔细一点呢？

在实际工作中，我们经常遇到类似的场景。你觉得这种状态正常吗？可能很多人对此习以为常。虽然难受，却不得不忍受。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg" width="30px"><span>Michael</span> 👍（119） 💬（10）<div>最近有同事正好在做PDF的生成，也就是把业务数据从各个别的服务拉取回来 然后清洗加工成自己想要的数据 然后传递给模版引擎进行渲染 最终生成pdf文件上传s3 然后通过API把上传的文件地址返回给客户端 想请问老师 这部分逻辑应该怎么测试？因为同事在写完代码之后只做了简单的测试（也就是直接mock其他的service的服务然后mock数据返回 以及mock了s3上传 ）最后只是简单看了一下返回值是否为空就完事了。最后到环境上验证才发现好多字段的格式有问题。那像这类场景我们该怎么合理测试才能尽可能保证做到测试完整性呢？</div>2020-05-29</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqia9gfbDeu8RqUlSozxmnzr6micGefNs5QGehBBl23xH6V82GxYwjgFgCKIA9n6iafFVKFoxVw5fHWw/132" width="30px"><span>Moonus</span> 👍（32） 💬（5）<div>比如service层有个很长，包含复杂逻辑的private方法，但我又想测试他。只能通过最顶层的public方法作为入口，这导致需要保证大量的前提条件的正确，我们需要mock很多外部依赖。
当private方法复杂并包含逻辑，其正确应当重构代码，而不是在测试做妥协，可以将需要测试的private方法转移到另一个对象中，成为一个public的方法。同时让我体会到测试驱动设计的含义。</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg" width="30px"><span>段启超</span> 👍（22） 💬（2）<div>    和大家分享一下我最近发现的一个问题：滥用@Autowired
    最近在给手上的代码上加测试的时候我进行了如下操作：
    1. 我在测试类中写了一个测试，因为类A中要执行的这个逻辑需要依赖另外一个对象B，于是我把这个需要依赖的对象B从全局变量中移动到构造中，作为参数放了进去，然后再构造方法上加了注解@Autowired。（注意： 原来的这个@Autowired 是在这个全局变量上的）
    2. 我在测试中mock 了这个依赖的B对象，然后给到了这个Service 的实例中去。
    3. 写业务代码实现，让测试通过。 
     
    本来以为测试已经通过，没什么问题了，结果在集成测试启动Spring 容器的时候，发现挂掉了，发生了循环依赖，查看代码，果然，在B中也@Autowired 注入了A ，他们两个就此开始循环～～～～
    结果用idea 的分析工具扫了一通，发现循环依赖不止于此，还有很多很多。。。。。
   
  从这件事儿上体现出来的问题： 
  1:  滥用@Autowired 体现出来的首先就是没有分离关注点，让一个类中做了过多的事情。 现在想过来原来写过的很多代码里头都是一大堆的@Autowired 注入 ，很多XXXService 的代码大概率的会发生这种事情。 
  2:  其实IDEA 编译器里边早就提醒过你了，当你在字段上使用@Autowired 去注入的时候，会有黄线的提示，提醒你不要这么使用，推荐你使用构造器的方式去注入。而很多人的处理方式就是对这个黄线视而不见。 
  3：如果从代码的测试性的角度来出发，你一定不会这么做，因为这么做没有办法去mock 你的依赖。 代码会丑到你自己都不想看。 
  4:  以前没想过循环依赖是怎么发生的，现在明白了：一个罪魁祸首就是滥用@Autowired  。循环依赖本身也是一个设计上的坏味道。如果有人问我说如何解决循环依赖，我会回答他： 首先不要循环依赖。 
 </div>2020-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/48/ee/96a7d638.jpg" width="30px"><span>西西弗与卡夫卡</span> 👍（18） 💬（1）<div>曾经开发过堆场应用，其中一个步骤是从远端服务器同步到本地服务器，然后再执行本地逻辑。如果每次测试本地逻辑都要从服务端拉取数据的话，就没法自动测了。当时采用的测试方法就是先抓取接口数据生成接口文件，测试就从文件中加载，再运行，最后销毁整个数据库。如果有接口相关的bug，也同样抓取数据保存，构建一个bug号命名的测试方法测试bug。

后来做过系统高可用软件，采用的方法是将代码自动部署到多个Docker里，测试代码里依据场景（为了方便，场景还用DSL写）比如杀某个Docker来测试高可用逻辑是否正常。</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg" width="30px"><span>阳仔</span> 👍（15） 💬（6）<div>其实难度是，现在大多开发者接触的一个已有的系统，在这个系统进行维护，修改各种bug，以及添加一些新需求。那么问题来了，如何将一个已有系统改造成粒度小且可测试的程序？我觉得这个应该是大家关心的工程实践</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（8） 💬（1）<div>1.对于自己重构大半代码的项目，我觉得应该是有偏见的（恶心太多次了）。但我还是认为我现在的项目可测试性很差。
a.项目启动太慢(服务包启动一次7-8分钟，war包启动一次20几分钟)。虽然单测时我们可以控制扫包范围，但总会扫到一些&quot;基础包&quot;莫名其妙的玩意，逼着你只能扩大扫包范围，而扩大扫包范围就会让单元测试的间隔无意义的变长。（项目本身分层没规范。部分基础公共包的分层不规范，且强依赖，无法按需加载）
b.工具包大量非纯函数的工具。静态方法不采用mock框架的高级功能是mock不了的，所以往往我们不会去测试工具类的逻辑。但这些工具包往往也存在文档不全或文档和功能脱节的情况。这个时候，一旦你使用不当或者工具类有bug那么就可能出现与预期不符的情况，而这个排查起来是比较难受的。因为这往往是你排查的最后一步，而你可能没有权限，只能看着反编译的源码，找到问题也改不了。只能改动自己的功能不用这个工具。（由此可见DI是多么美好的东西）
c.臃肿的大类+强依赖中间数据结构。近百个字段的核心类，让你找个字段都很晕。中间数据(map,键值的list)在功能间传递，缺少封装。每次要获取自己要用的数据结构都要对中间数据做转换。逻辑走完后，还要对中间数据做变动，以保证变更对外部生效。这一切的结果就是逻辑被变得复杂了，代码行数增多了。而代码行数和逻辑变多出问题的可能就变大，测试的工作量就变大。

2.其他的，诸如不要有未决行为,尽量少用全局变量，低耦合等等都是个人编码能力的事，怪不得老项目了。提高可测试性,其实我觉得就是要遵循最小依赖的原则。最好就只有入参和本地逻辑（逻辑中没有外部依赖，没有外部变量，没有外部静态方法），这样可测试性是最好的。而要做到这个也并非不可能，全在你的设计和拆分力度上。</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/21/30/8ecce1e1.jpg" width="30px"><span>北天魔狼</span> 👍（6） 💬（1）<div>测试前置数据，测试API，测试完清理数据。
感觉测试主要是为了防止自己或者别人改了自己的代码</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg" width="30px"><span>业余爱好者</span> 👍（6） 💬（1）<div>由于集成测试环境复杂，排错复杂，所以我们要尽量在前期，开发甚至设计阶段就要考虑测试，尽量把bug消灭在集成测试之前。每个模块保证接口功能正常，模块交互又是按照规范的，一般集成都问题不大，当然只是概率非常低。

单元测试还有一个好处，那就是自动化。写一个功能，就运行一下单元测试。单元测试是代码功能的保障。经常对曾经一些低级的bug如手误少些个！之类的错误深恶痛绝，觉得怎么能犯这么低级的错误。我错怪自己了，人就是这样一种粗心的动物，应该让程序来检查代码的正确性，程序检查的又快又不会出错，何乐不为?当然前提是得有单元测试。

Tdd是一种好的实践。在测试上要多下点功夫。
</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg" width="30px"><span>阳仔</span> 👍（5） 💬（1）<div>前面一节提到软件设计的首先是要分解，而分解的一个目的我觉得就是为了软件的可测试性。
当然这也是建立在分解粒度要小的基础上，</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/7a/63/487f537e.jpg" width="30px"><span>PM2</span> 👍（4） 💬（2）<div>有什么好的资源关于单元测试吗？网上内容虽然很多，但是鱼龙混杂</div>2020-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg" width="30px"><span>FelixFly</span> 👍（4） 💬（1）<div>可测试性现在是大家普遍关注的事情，公司能写单元测试的人是极少数，由于单元测试的缺失，很多问题都是暴露在集成测试，而在集成测试中发现问题会需要大量的时间来查找问题，是本身问题还是上下游服务问题导致，这就是后来引发出来的链路跟踪需求，不然就没办法定位问题</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" width="30px"><span>aoe</span> 👍（3） 💬（1）<div>开始工作的时候，为了测试定时任务，要修改服务器时间！很多年后才学会传参数给定时任务要调用的方法就能测试</div>2021-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c2/cc/ca22bb7c.jpg" width="30px"><span>蓝士钦</span> 👍（3） 💬（2）<div>有些项目从controller一直到dao都是一个简单的方法调用，逻辑都在sql里，这样如何单元测试呢？难道只能通过集成测试验证相互关联的方法里sql正确性了嘛……</div>2020-06-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/7a/63/487f537e.jpg" width="30px"><span>PM2</span> 👍（3） 💬（1）<div>单元测试的前提是测试单元划分的足够细。</div>2020-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg" width="30px"><span>Being</span> 👍（2） 💬（1）<div>如果提成一个个的API后，如何测试就很好理解了，想像自己在命令窗口调用一个个command，就是一个个API后执行，来assert返回结果就简单了。反过来其实也是在提醒我们实现功能，提接口时考虑一种最简单的通过命令行调取方式，能否实现。
那么这样无论是后台执行，还是涉及界面的调用逻辑，都是可测的。</div>2020-05-30</li><br/><li><img src="" width="30px"><span>Flynn</span> 👍（2） 💬（1）<div>现在的测试都是人工测试，造成的问题主要是频繁回归，改了代码就担心破坏了以前的功能。因为没考虑可测试性，项目里存在很多的单例。不用单例可以用什么方式呢？</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/8b/a7/b6471f02.jpg" width="30px"><span>远逝的栀子花</span> 👍（1） 💬（1）<div>测试用例的开发设计，可以针对每一个函数进行测试，利用好各种现有的测试接口进行测试，一旦接口发生变化就能测试用例失败，立马进行修复，不用等到代码上了测试环境或者代码上网阶段才发现。</div>2021-06-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/7d/95/2ad3bb05.jpg" width="30px"><span>大晨_Richard</span> 👍（1） 💬（1）<div>没有设计，写到什么写什么，是最大的问题</div>2020-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（1） 💬（1）<div>“保证每个模块在开发阶段能够测试”，是否一定要引入测试驱动开发或者单元测试？如果对每个模块进行手工测试，或者是自动化黑盒测试呢？

在瀑布开发模式，或者是普通的团队中，测试人员一般都是在整个软件基本完成之后才开始进行测试。外部测试很难在函数或者模块级别开始介入。

在设计的时候，想一下这个模块要怎么测，其实就是考虑清楚这个模块要怎么调用。

之前接触过测试驱动开发，使用 Mock 框架来模拟各种外部访问资源，应该算是其中的高级技术话题。另外一个难点，是在于任务分解，所以我准备同步去学习《10X程序员工作法》。

如果没有单元测试和测试驱动开发，我觉的重构和持续集成也很难做好，主要是每次调试 bug 都需要比预计更多的时间。

做软件设计的时候，考虑可测试性，其实也算是“以终为始”的一种思维方式。

看了一下留言，虽然不多，但是藏龙卧虎。

老师在留言里面提到做好 TDD，前提是懂一点设计。我的理解是先有 TDD，然后重构，最终得到好的设计。当然，如果有一定的经验，知道什么是好的设计，无疑可以少走一点弯路。</div>2020-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/af/1e/d4935b21.jpg" width="30px"><span>若飞</span> 👍（0） 💬（1）<div>最近是为项目可测试性头疼，由于前期没有做好测试设计，所以当前针对方法、类、接口、模块以及系统各个层次的测试都会一抓一头麻，多谢提供如此好的思路。</div>2020-07-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/b2/fb/fa145af3.jpg" width="30px"><span>刘超</span> 👍（0） 💬（1）<div>singletone模式构造函数可以是protected的，是可以有子类的。</div>2020-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg" width="30px"><span>giteebravo</span> 👍（0） 💬（1）<div>
项目伊始，写代码还会有可测试性的意识，但写着写着，就写飞了～
</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a0/14/c3f6c745.jpg" width="30px"><span>灰尘</span> 👍（0） 💬（1）<div>如果要测试复杂查询条件的sql，还是要依赖数据库吧</div>2020-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/02/59/989f65c8.jpg" width="30px"><span>jacky</span> 👍（0） 💬（1）<div>为了可测试性，系统可能无形中多了很多的接口，比如数据库有200个表，可能会出现200个接口，而膨胀的接口让人看起来非常难受。这要怎么解决？</div>2020-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg" width="30px"><span>捞鱼的搬砖奇</span> 👍（0） 💬（3）<div>还有个问题，因为方法封装的 关系，有些业务逻辑是访问级别是私有的 ，如果想在单元测试里测试这样的代码，只有暂时性的把访问级别提高到公有了吗，这个问题困扰了很久，没想到什么好的办法。</div>2020-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg" width="30px"><span>捞鱼的搬砖奇</span> 👍（0） 💬（1）<div>想请教老师，类似 Spring 这样的，举例子说我要测试一个业务逻辑，这个逻辑里包含了对表的操作。最好的方式是把逻辑和表操作分开测试吗，还要 在测试能运行之前 Spring 要创建一堆的 Bean，如果系统规模大启动的时间就要很久，这样有简化的办法吗</div>2020-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg" width="30px"><span>Michael</span> 👍（0） 💬（2）<div>还想请教一下老师对于模块应该怎么理解？比如您给我回复的生成pdf的步骤里：是否把每一个步骤都作为一个模块？那是不是把内部的实现细节暴露出去了，因为对于caller来说 我给你数据 你帮我生成pdf至于你通过什么方式渲染caller不管也无权过问 但是如果把模块独立出去了那是否以为着某些方法会变成public的？那是否说明我们把实现细节暴露出去了？</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/02/59/989f65c8.jpg" width="30px"><span>jacky</span> 👍（0） 💬（1）<div>延迟，安全为什么叫执行质量？可测试性叫演化质量？有点绕</div>2020-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg" width="30px"><span>术子米德</span> 👍（0） 💬（0）<div>🤔☕️🤔☕️🤔
【R】软件开发最费时间的环节 = 集成测试。
【.I.】除了废大量时间在集成测试环节，更耗的是精力，以及最磨的是信心。满心欢喜开始集成测试，到发誓再也不要这样玩，除了爆弃式情绪释放，更要反思如何欢喜感保持、直到满足感升起。针对每个问题，盯着去质疑，如何在集成前可发现、如何在集成时易发现，是否为可测性迭代的最佳起点。
【R】非功能性需求 = ‘质量属性（Quality Attributes）’ = 执行质量（Execution Qualities）[=吞吐|延迟|安全|…]+ 演化质量（Evolution Qualities）[=可测试性+可维护性+可扩展性…]。
可测试性 = 技术债务之源头（造楼用的钢筋质量，是在混泥土灌入前单独质检，还是在大楼造成后整体验证）
【.I.】客户直接付钱的叫功能需求，客户潜在赔钱的叫执行质量，厂家持续利润的叫演化质量。功能需求决定当前单子的钱能不能收齐，执行质量决定未来新单子是否还来合作，演化质量决定挣到的钱多少可用于未来。
【R】设计函数、模块、系统时，可测性在不同层次纳入考量，本地模拟集成优先于真实集成环境。
【.I.】可测性，这个词本身容易带向具体的测试手段和方法，这本身没错，只是要认清楚，这些具体的测试手段和方法，它们是可测性的果。可测性本身作为因，要盯着去回答，何谓符合预期的正确、何谓预期之外的异常，以及什么信号和指标，准确反应这两方面的所谓。基于这样的追问得出的信号和指标，去指导整体设计和模块设计，去回答哪些在模块级解决、哪些到系统层面解决，再确定解决的具体方法和手段，即看到可测性时，脑子里直通的具体测试手段和方法。东西都是一样的，差别在于思考的路径。
【Q】可测性，在理论中学习掌握，跟在实践错误中反思理解，如何搭配出好方子？
    ---- by 术子米德@2023年10月5日</div>2023-10-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg" width="30px"><span>小袁</span> 👍（0） 💬（0）<div>赞成在集成测试前测试，但不赞成通过测试保证每个模块的正确性。</div>2022-05-08</li><br/>
</ul>