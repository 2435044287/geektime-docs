你好！我是郑晔。

上一讲，我们讲到了编程范式，现在开发的一个重要趋势就是多种编程范式的融合，显然，这就要求我们对各种编程范式都有一定的理解。从这一讲开始，我们就展开讨论一下几个主要的编程范式。首先，我们来讨论程序员们最熟悉的编程范式：结构化编程。

很多人学习编程都是从C语言起步的，C语言就是一种典型的结构化编程语言。C的结构化编程也渗透进了后来的程序设计语言之中，比如，C++、Java、C#等等。

说起结构化编程，你一定会想起那些典型的控制结构，比如：顺序结构、选择结构和循环结构，还会想到函数（如果用术语讲，应该叫subroutine）和代码块（block）。这几乎是程序员们每天都在使用的东西，对于这些内容，你已经熟悉得不能再熟悉了。

但是，不知道你是否想过这样一个问题？面向对象编程之所以叫面向对象，是因为其中主要的概念是对象，而函数式编程主要的概念是函数。可结构化编程为什么叫结构化呢，难道它的主要概念是结构？这好像也不太对。

其实，**所谓结构化，是相对于非结构化编程而言的**。所以，要想真正了解结构化编程，就要回到非结构化的古老年代，看看那时候是怎么写程序的。也就是说，只有了解结构化编程的发展历程，你才能更好地认清结构化编程的不足。
<div><strong>精选留言（17）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（21） 💬（1）<div>看了一下 Edgar Dijkstra 的那篇 Go To Statement Considered Harmful，其中说到，go to statements should be abolished from all “higer level” programming languages. 

论文里面提到两个 remark，一个是说一旦程序被编写完成，那么程序的控制权就交给了机器；第二个是说，程序员（人）对于静态关系掌控和动态过程视觉化都有一定的局限，所以要尽量减少静态程序代码和动态过程的“认知鸿沟”。

专栏里面提到了“非结构化编程”，结合 Dijkstra 的论文，感觉使用 go to 语句的非结构化编程更像是一种“线性编程”，在一个很长的代码文件上给出了几个索引（标签），然后使用 go to 语句来跳转。如果不怕重复，把所有的 go to 都展开，那么应该就是更长的一段代码。

而使用了 if&#47;else、do&#47;while 的结构化编程，感觉是把一条线变成了一棵树，从一维坐标到二维坐标（？）。从认知的角度，更有利于程序员去开发程序——其实也就是前面 Dijkstra 说的，程序的复杂度超出了程序员的控制，所以需要结构化编程来降低认知的难度。

1969 年阿波罗 11 号登月的时候，使用的编程语言应该是汇编吧，即没有结构化也没有面向对象。后来看到了左耳朵耗子在酷壳上的一片文章《50年前的登月程序和程序员有多硬核》，确实 hardcore。

最早学的也是 C 语言，然后学到面向对象的时候（C#）的时候，看到那些小猫小狗、继承多态的例子，感觉也很震撼，后来才发现在实际的工作中，面向对象的分析并不简单，面向对象的落地也不容易。</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（14） 💬（2）<div>1.结构化编程&#47;过程式编程，感觉栏主漏了一个很重要的点，贫血模型。结构化编程里面有结构体（自定义的类型）的概念，站java角度看,这其实这就是一个&quot;类&quot;，但这个类只承接属性却不会有行为。也就是说过程式编程里面，行为和数据是完全分离的（我不认为这是坏处，毕竟这样代码实现和阅读都相对简单）。并且结合对过程的抽象（这里应该算得上函数了）,可以定义各种复杂的指令，以便达到复用和隔离复杂性的效果。（这些特性也是导致大部分开发都面向过程编程的主要原因）

2.既然结构化编程能做到复用和隔离复杂性，那么还要面向对象干嘛？或者说面向对象相较于结构化编程优秀在哪里？我认为至少有两点优秀的地方，1.易用 2.更好的复杂性隔离。易用，某种带有数据结构的&quot;类&quot;,其具备哪些行为一目了然(打点可见)。而不像过程式编程，数据与过程的关系是松散的（java开发可以理解为所有代码都以静态方法+贫血模型实现）;更好的复杂性隔离,这主要依托于面向对象的一个特性,封装。面向对象不主张绕过对象的使用接口侵入到对象的内部实现细节，如此一来对象内部的变动与所有使用方就隔离了，换句话说，只有在对象内部才能变更对象的属性，变更点全部收敛。（封装其实是一种约束，让代码没办法那么灵活。但这个约束对于代码的可读和可维护却有着深远的价值）

3.学习ddd让我受到了很大的震撼。起初，我看了一遍领域驱动设计实战那本号称比较好理解的“红皮佳作”。然并软，看了一遍基本不理解各中缘由，也就拿着专业名称跟别人瞎应付几句，表示自己也学过。但后来，深入去学习设计原则与设计模式，面向对象思想，并做了大量的重构（期间经常会翻到“红皮佳作”的某些章节思考）。对于ddd为啥这么做有了自己的见解。1.为什么依赖倒置，基础层要在最上层。因为这样做技术相关代码可以从应用层和领域层抽离，保证应用层和领域层业务代码的干净（技术组件可以单独升级）。 2.为什么要封装充血模型？为了更好的复用以及隔离复杂性. 3.为什么要分应用层和领域层？将基础的领域服务代码和上层的应用服务代码隔离，将不同的领域服务代码相隔离，将不同的应用服务代码相隔离。做到,虽然将多个模型（基础模型和应用模型）写在一个包里，但以目录和编程规范的方式将之间的代码隔离，为后续业务拓展后的调整铺平道路。（也包含去重的理念）4.为什么要制定规范，为什么要抽象系统模型图? 为了降低认知差异（同规范下，相互间代码可读性自然会更好），提高共识度(没办法产品技术一体两面，就在业务逻辑和代码实现间再架设一层中间语言，方便两者沟通。是不是有点IR“高级语言与机器语言的中间表达式”的味道)。等等。。。</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/48/ee/96a7d638.jpg" width="30px"><span>西西弗与卡夫卡</span> 👍（11） 💬（1）<div>刚开始接触函数式编程时，就被它背后的数学理论所震到，之前一直把计算机看成是工程学。后来看到它的不变性天生适合并发时，又深深体会到它的美感</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/af/d4/59e2bfd4.jpg" width="30px"><span>hello zero</span> 👍（6） 💬（1）<div>在学习机器学习和深度学习编程的过程中，被其背后的数学思想所震撼，这是第一次觉得数学离编程这么近且不可或缺。</div>2020-06-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg" width="30px"><span>Hank_Yan</span> 👍（4） 💬（1）<div>布隆过滤器，hyperloglog，这些基于统计思想设计的算法，着实把我镇住了，数学真重要！ </div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg" width="30px"><span>青鸟飞鱼</span> 👍（2） 💬（2）<div>之前看设计模式中提到面向过程与面向对象，让我产生了困惑；写类成员函数时，可它的实现我用的明明是面向过程，让我产生了困惑。读了今天的课程，解决了我的困惑。</div>2020-07-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/12/f4/1bf8568e.jpg" width="30px"><span>学要有所用</span> 👍（2） 💬（1）<div>汇编的goto特性使得编程不可控，不受约束，为了约束编程行为，结构式编程应运而生，其自上而下的编程方法使得程序易于编写和理解，但由于自上而下，每行代码紧密相连，下层代码的运行依赖于上层代码，耦合度太高，约束性太强，一旦代码变动，所有相关连的代码可能都得变动，灵活度太低，于是面向对象编程横空出世，就拿java来说，其强大的语言特性使得代码灵活性大大提高，与汇编的goto特性相比，java的if else ，for循环等对程序的行为起到了约束作用，这些结构类代码将原本不受约束的代码行为控制在了结构代码内，它的各种访问修饰符所带来的封装特性对代码的行为也起到了约束作用，同时也一定程度提高了代码的安全性。继承特性的出现使得重复使用的代码变得可复用，减少了大量冗余代码，还能在继承之外添加自己的功能行为，多态的出现在继承的基础上进一步加强了这一行为，使代码的灵活性更高。为了进一步增强代码的灵活性，反射机制出现了，与结构化编程的按步骤执行不同，它能在代码的运行阶段操控代码，可以说，面向对象的编程范式通过对象模型的映射，配合其特性，极大地提高了代码的灵活性，减少了大量冗余的代码。不知道以上理解对不对？</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f2/13/3ee5a9b4.jpg" width="30px"><span>chenzesam</span> 👍（2） 💬（1）<div>flutter 一切皆 widget 的思考，远大于我们能看见的表面。</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg" width="30px"><span>阳仔</span> 👍（2） 💬（1）<div>相信很多人一开始学习c编程语言入门的，这时教材上会告诉这是结构化编程编程语言。
学习了体系结构和汇编相关知识之后，会发现底层语言是非结构化的，
这给编码效率带来不便，于是出现结构化编程，也出现了更高层次的分层与封装。
结构化编程符合人类的思维。当我们开发系统时，分解各个小系统，小系统分解成模块，模块分解为组件，组件分解类，类分解为功能函数。
一步一步下来，完成整体的功能拆分。
当然结构化编程不是银弹，它也有缺点，比如高层依赖底层模块强，不容易测试等，这些需要其它编程范式一起解决
</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/43/e1/b7be5560.jpg" width="30px"><span>sam</span> 👍（1） 💬（1）<div>初学编程的人都习惯所谓“面条型”代码，就是结构化编程吧^_^</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg" width="30px"><span>飞翔</span> 👍（1） 💬（1）<div>还是美丽介绍以结构语言 话说功能性拆分 这不就是面向对象嘛</div>2020-06-24</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132" width="30px"><span>Stay_Gold</span> 👍（0） 💬（1）<div>本质上我觉得不同的编程范式之间并没有什么高低贵贱之分。
不是说结构化编程就是不好，面向对象编程就是好。
只是适用的场景不一样，对象对象最核心的特性就是封装，而封装的本质是屏蔽复杂性，所以复杂场景更需要面向对象。而面向对象里面的具体函数实现如果是简单清晰的，就可以直接结构化编程。</div>2025-01-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg" width="30px"><span>Janenesome</span> 👍（4） 💬（0）<div>一直在写平铺直叙的结构化代码，很难测试，很难隔离变化，这些苦果真是吃了不少。

以前是没看过好代码，所以不知道什么是好代码。拥抱变化，努力学习，谢谢郑老师带我上路。</div>2020-10-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（2） 💬（0）<div>结构化编程不能有效地隔离变化，需要与其他编程范式配合使用。--记下来</div>2022-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg" width="30px"><span>favorlm</span> 👍（0） 💬（0）<div>在了解docker后，我知道它不是虚拟机，而是通过一个linux的特性（命名空间）来隔离。在此之前，我一直以为他是虚拟机。</div>2023-10-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg" width="30px"><span>6点无痛早起学习的和尚</span> 👍（0） 💬（0）<div>第一次接触编程范式，我理解“非结构化和结构化的区别”
1. 控制流程不一样
非结构：用 goto 跳转语句，太灵活、混乱和不易懂
结构化：就顺序、分支、循环结构

2. 模块化
非结构化：一口气写完
结构化：一口气分为几口气写完
</div>2023-09-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a7/42/f510bb91.jpg" width="30px"><span>wang_acmilan</span> 👍（0） 💬（0）<div>2022回头来看这篇文章时，对于我自己来说，还是非常的震撼：只有了解了一个问题发生的前因后果，才能更好的明白发展的方向。
在学习设计模式时绕不过面向对象的编程思想，学习面向对象是，又不得不说起结构化编程。
今天再次的复习文章，算是“弄明白”了这历史渊源，对于面向对象的理解，又更深入了一层。
感谢每天坚持学习的自己，也谢谢极客时间能找到优秀的老师写水平这么高的文章。</div>2022-11-13</li><br/>
</ul>