你好，我是宫文学。

今天这节课，我们继续上一节课未完成的内容，完成垃圾回收功能。

在上一节课，我们已经实现了一个基于Arena做内存分配的模块。并且，我们还在可执行程序里保存了函数、类和闭包相关的元数据信息。

有了上一节课的基础之后，我们这节课就能正式编写垃圾回收的算法了。算法思路是这样的：

- 首先，我们要有一个种机制来触发垃圾回收，进入垃圾回收的处理程序；
- 第二，我们要基于元数据信息来遍历栈帧，找到所有的GC根；
- 第三，从每个GC根出发，我们需要去标记GC根直接和间接引用的内存对象；
- 最后，我们再基于对象的标记信息，来回收内存垃圾。

在今天这节课，你不仅仅会掌握标记-清除算法，其中涉及的知识点，也会让你能够更容易地实现其他垃圾回收算法，并且让我们的程序能更好地与运行时功能相配合。

那接下来，我们就顺着算法实现思路，看看如何启动垃圾回收机制。

## 启动垃圾回收机制

在现代的计算机语言中，我们可以有各种策略来启动垃圾回收机制。比如，在申请内存时，如果内存不足，就可以触发垃圾回收。甚至，你也可以每隔一段时间就触发一下垃圾收集。不过不论采取哪种机制，我们首先要有办法从程序的正常执行流程，进入垃圾回收程序才行。

进入垃圾回收程序，其实有一个经常使用的时机，就是在**函数返回**的时候。这个时候，我们可以不像平常那样，使用retq跳回调用者，而是先去检查是否需要做垃圾回收：如果需要做垃圾回收，那就先回收完垃圾，再返回到原来函数的调用者；如果不需要做垃圾回收，那就直接跳转到函数的调用者。
<div><strong>精选留言（4）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/23/7f/24/ceab0e7b.jpg" width="30px"><span>奋斗的蜗牛</span> 👍（2） 💬（0）<div>太强了，轻轻松松就把这么复杂的知识讲明白</div>2021-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg" width="30px"><span>写点啥呢</span> 👍（2） 💬（0）<div>请问宫老师，为何GC操作的实现frame_walker只检查栈中的对象root，存在于寄存器中引用的对象我理解也应该是有效live的。请老师指点，谢谢</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ee/31/8a5cd41d.jpg" width="30px"><span>James Deng</span> 👍（0） 💬（0）<div>宫老师，想请教一下，JVM垃圾回收在代码的位置设计了安全点，有test()机制，这个与我们的playscript有什么区别吗？</div>2022-11-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（0）<div>学习打卡</div>2022-09-30</li><br/>
</ul>