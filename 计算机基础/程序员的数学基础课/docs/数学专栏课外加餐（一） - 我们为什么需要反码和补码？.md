你好，我是黄申。欢迎来到第一次课外加餐时间。

专栏已经更新了几讲，看到这么多人在留言区写下自己的疑惑和观点，我非常开心。很多同学在留言里提出了很多非常好的问题，所以我决定每隔一段时间，对留言里的疑问、有代表性的问题做个集中的解答，也是对我们主线内容做一个补充，希望对你有帮助。

## 什么是符号位？为什么要有符号位？

在[第1讲](https://time.geekbang.org/column/article/71840)里，我介绍了十进制数转二进制数。这里面很多人对逻辑右移和算术右移中提到的符号位和补码有疑惑。这里面涉及了几个重要的概念，包括符号位、溢出、原码、反码和补码。我详细讲一下这几个点的来龙去脉。

首先我们来看，**什么是符号位，为什么要有符号位**？用一句话来概括就是，**符号位是有符号二进制数中的最高位，我们需要它来表示负数。**

在实际的硬件系统中，计算机CPU的运算器只实现了加法器，而没有实现减法器。那么计算机如何做减法呢？我们可以通过加上一个负数来达到这个目的。比如，3-2可以看作3+(-2)。因此，负数的表示对于计算机中的二进制减法至关重要。

那么，接下来的问题就是，**如何让计算机理解哪些是正数，哪些是负数呢**？为此，人们把二进制数分为有符号数（signed）和无符号数（unsigned）。

如果是有符号数，那么最高位就是符号位。当符号位为0时，表示该数值为正数；当符号位为1时，表示该数值为负数。例如一个8位的有符号位二进制数10100010，最高位是1，这就表示它是一个负数。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6Nic6V6iawbbIF1RRbRlwNmC0Cmt3LlQRAiaiayCibpplSDPXticVyOp97CEypEuQm2Iib7ZYCjrrlIgWQ/132" width="30px"><span>奔跑的蜗牛</span> 👍（5） 💬（1）<div>疑问1:为什么i-j得加上取模的除数？
疑问2:2^n-1就是32位1，这个地方就又没有符号位之说了？
疑问3:非符号位计算溢出会进到符号位嘛？
麻烦老师帮忙解答下</div>2019-04-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/bd/d12f8907.jpg" width="30px"><span>梓航(﹏)</span> 👍（31） 💬（1）<div>老师，你讲的那个取模和反码的关系那一段我看不懂，之前看书也没有遇到你说的这种概念，请问还有其他学习资料吗？</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a2/35/04536ff4.jpg" width="30px"><span>随欣所遇</span> 👍（22） 💬（2）<div>用大家熟悉的一周七天进行对比吧
1、计算数据的溢出相当于模：假设第1天为周一，第2天为周二，以此类推第7天为周日，第8天已经大于7溢出了，8对7进行取模为1，也即第八天为周一；取模的除数为上限减去下限+1，替换过来换算：一周的上限为7，下限为1，那一周取模的除数换算为：7-1+1，所以我们想要知道第15天后是周几直接对（7-1+1）取模即可；
2、i-j=(i-j)+(2^n-1+1)=i+(2^n-1-j），可以换算为 周一 = （周一）+ （7-1+1）进行理解（ps：不一定周一，周几都为同一样，只是将 i-j 看成一个单元用其做概念上的替换）</div>2019-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d9/0a/ce61e397.jpg" width="30px"><span>石佳佳_Gemtra</span> 👍（19） 💬（4）<div>思考题：
原码：10100010
对补码除符号位取反得
反码：11011101
+1操作得
补码：11011110
对应十进制数：-94
还有一种方法，把负数原码除符号位外求和，减去 （2^n-1+1），即 2+32-(2^7-1+1)=-94</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/18/34/c082419c.jpg" width="30px"><span>风轨</span> 👍（12） 💬（1）<div>思考题
0b10100010 = 0b10000000 + 0b00100010
其中
0b10000000 = -128
0b00100010 = 34
所以答案是 -94

2进制取相反数公式
相反数 = 原数减一再取反

- 0b10100010 = !(0b10100010-1) = 0b01011110 = 94
</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/56/25/ba0e44af.jpg" width="30px"><span>恒</span> 👍（7） 💬（1）<div>补码代码的数值的快速求法
负数补码通过非符号位0出现的位置来计算，然后计算结果加1，最后带上符号即可。
比如 1000,非符号位为000，按照0出现的位置计算，000=2^2+2^1+2^0=4+2+1=7,结果加上1后得到8，所以这个二进制数
表示-8
正数补码看非符号位1出现的位置来计算，然后加上符号即可。
比如 0111，非符号位为111，按照1出现的位置计算,111=4+2+1=7 所以这个二进制数
表示+7

对补码的理解：
目的：为了使用相同电路来实现加减运算，使得计算机cpu设计更加容易
为何用补码，可以通过如下四位数模拟补码从0开始一直加1的情况
0000 = 0
0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = -8
1001 = -7
1010 = -6
1011 = -5
1100 = -4
1101 = -3
1110 = -2
1111 = -1
0000 = 0 （再加1又从0开始了，上面表示的不同数值的个数是2^4=16,所以模是16）
...
然后上溢和下溢也顺便理解了，如下所示，
上溢就是4位二进制数的正数的最大值加1，然后通过补码加法运算后结果是4位二进制数的最小数-8 
上溢：7 +  1 =0111+0001=1000(4位二进制数的最小数)=-8   注：加上1的目的是最大值再大一点，当然就溢出了
下溢就是4位二进制数的负数的最小值加-1，然后通过补码加法运算后结果是4位二进制数的最大数+7
下溢：-8+(-1)=1000+1111=0111(最大数)=7  注：加上-1的目的是最小值再小一点，当然就溢出了</div>2019-06-18</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/eyKgpIVFSDQBia7SJRVUKFh5qgwc3ohzEPSKvchLf9ZvwIO9CrS470ER7OhNzWTs0svECHCBiarQTa41BO3Hf0DA/132" width="30px"><span>Temme</span> 👍（6） 💬（1）<div>思考题:10100010
如果是原码，所对应的数字就是-34
如果是补码，那么就减一取反求原码，11011110，就是-94。

然而对着补码再去求一次补码也可以得出原码，所以神奇的是某个回答也是对的。。。这就是所谓的互为补码。
</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/08/17/e63e50f3.jpg" width="30px"><span>彩色的沙漠</span> 👍（6） 💬（1）<div>老师，不好意思
问题有一处错误，我纠正一下，以免误导后来的同学
java中int的最小值是-2^31
二进制源码:1 000 0000 0000 0000 0000 0000 0000 0000
二进制反码:1 111 1111 1111 1111 1111 1111 1111 1111
-2^31的补码还是自己，符号位进位舍弃</div>2018-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/89/e7/015d82b1.jpg" width="30px"><span>夏飞</span> 👍（5） 💬（1）<div>这不就是余数和取模的概念吗？
这句话不明其意</div>2018-12-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/fd/90/ae39017f.jpg" width="30px"><span>爱吃锅巴的沐泡</span> 👍（4） 💬（1）<div>老师，请教一下问题
文章中讲的是原码到补码的推导过程。
一个二进制数在计算机中存储的形式就是补码。
那么一个数输入到计算机中就是补码形式，还是说有一个从原码到补码的推导过程？可是这个推导过程中也有减法，和补码把减法加法化的说法就冲突了？</div>2019-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/8d/b7/326a90c4.jpg" width="30px"><span>吾本糊涂</span> 👍（3） 💬（1）<div>10100010直接用10进制表示不是-34吗 为啥要去它的补码再换算10进制？</div>2018-12-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/77/2b/788c15f7.jpg" width="30px"><span>毕明亮</span> 👍（3） 💬（1）<div>老师，评论里石佳佳说那个是源码取反加一，Li Shundong又说是补码取反加一得源码……看晕了</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/59/f6/ed66d1c1.jpg" width="30px"><span>chengzise</span> 👍（3） 💬（1）<div>计算机内部有符号数才用补码表示，10100010最高位为1是个负数，负数的绝对值是其补码取反再加1，为01011110。十进制为94.因此10100010的十进制值为-94</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/b8/e2/11b9f1a8.jpg" width="30px"><span>江宁猎妈人</span> 👍（2） 💬（1）<div>以前学计算机原理的时候，一直想不明白为啥补码这么设计，虽然也知道是取余，但一直没很清楚的推导过。这次看了文章更有体会。拿 4 位 2 进制数举例，-2 原码 1010，补码 1110，相当于 -6 的原码 ，也就是 -6 = -8 - (-2)，而 -8 正是一个循环。给 -6 加 1，1110 + 0001 = 1111 (-7)， -7 还原以后就是 - 1 = -2 + 1；继续下去 1111 + 0001 = 1&#47; 0000 = 0，这样就转回来了。
同样的，这也是补码 1000 代表 -8 的原因。 和上面一样，1001 是 -7 的补码，也是 -1 的原码。再减一位，变成1000 ，若用原码表示法，就是 -0，和 0000  都是 0，浪费了一个数。若以补码的思想，-8 - 0 = -8，这样摇身一变，就使得表示范围多了一位，弥补了 2 ^ n 的边界值。</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/89/73/e1e01096.jpg" width="30px"><span>Rainbow</span> 👍（2） 💬（1）<div>“其中 2^n-1 的二进制码在不考虑符号位的情况下是 n-1位的1“
这个地方不理解，2^n-1的符号位不是0吗？
而2^n - 1是有位的1啊。
这个地方不理解，希望老师能解答一下~</div>2018-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/0d/9e/f22e1c28.jpg" width="30px"><span>阿猫</span> 👍（2） 💬（1）<div>负数换算补码时，+1，符号位参与运算吗？听晕了。。。</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg" width="30px"><span>zj</span> 👍（1） 💬（1）<div>2^n-1-2这个图解中，为什么是n-1个1呢，不考虑符号位的话应该是n个1吧</div>2019-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/91/75a69d33.jpg" width="30px"><span>focus　根</span> 👍（1） 💬（1）<div>理解了负数的原码、反码和补码之后，你能算算看，8 位的有符号位二进制数 10100010，对应的是哪个十进制数吗？

针对这题  我发现我迷惑了
为什么要将这个二进制数  转化为补码才去求十进制呢

之前-2的原码是10000010，那么10000010的十进制表示不就是-2

然后我就看到这里迷惑了

在计算机表示中  比如c++的表示  一个int   8位的值  为-2   那么转化为byte  在大端模式下  是用补码来表示吗</div>2019-03-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/79/35/0f9fcaea.jpg" width="30px"><span>枫暂</span> 👍（1） 💬（1）<div>不错的文章，读罢对溢出，原码，反码，补码的由来有了点线成面的认识，以前对这些数字在计算机中的二进制表示相关知识的理解更多是零散的，串不起来，需要记忆的成分在里面，过上一段时间后，总得重新梳理好半会才理清楚。阅读了本文后，终于有水到渠成，一以贯之之感😁，为作者大大点赞😊</div>2019-01-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/d0/db/8b8173d0.jpg" width="30px"><span>OzoraTsubasa</span> 👍（1） 💬（1）<div>老师，请教您2个问题：
      1.您文章说的，Java Int类型是32位，最大值是2^31-1，这个最大值是去除符号位第31位的最大值还是从0位按照2^*n 这个算法 从0位相加一直加到31位得到的值那？

     2.为什么最大正值01111..11+1之后就变成10000..00啦 ，按照逢二进一也应该是01111..10,不明白老师？</div>2018-12-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/6a/f2/db90fa96.jpg" width="30px"><span>Oli张帆</span> 👍（1） 💬（2）<div>说的题外话，我发现每次看文字的时候，都很容易走神，但是听语音就好很多。不知道别的同学是怎样的。</div>2018-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b1/55/249c3abd.jpg" width="30px"><span>包美丽</span> 👍（1） 💬（1）<div>为什么Java中int的下限是-2^31，怎么计算出来的？</div>2018-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/7a/99/9f22eaa9.jpg" width="30px"><span>okawari</span> 👍（1） 💬（1）<div>黄老师还能看到吗，肥宅大哭ing，不知道理解的对不对，还请黄老师指正，谢谢黄老师～

我是这样理解的，-2就是再加2就到0的意思，0表示为全0，所以-2需要表示为11111110，这样加两个单位，最高位溢出后就归零了，即为补码。而原码为补码的一个映射，目的是使得人更加容易理解。</div>2018-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/7d/25/f59a0d5c.jpg" width="30px"><span>李雷</span> 👍（1） 💬（1）<div>32位的int值，最大值不应该是31个1么，那应该是2^32-1吧？</div>2018-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d7/85/f2d5997a.jpg" width="30px"><span>Zzzzz</span> 👍（1） 💬（1）<div>其中 2^n-1 的二进制码在不考虑符号位的情况下是 n-1 位的 1，那么 2^n-1-2 的结果就是下面这样的：

或者说为什么不把符号位加入计算</div>2018-12-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d7/85/f2d5997a.jpg" width="30px"><span>Zzzzz</span> 👍（1） 💬（1）<div>其中 2^n-1 的二进制码在不考虑符号位的情况下是 n-1 位的 1，那么 2^n-1-2 的结果就是下面这样的:


老师，这里不是很理解，为什么在计算i-j+取模的除数的时候，不考虑符号位？假设是8位的情况，不考虑符号位的话，那取模的除数不是才128吗？按道理8位的模数应该是256</div>2018-12-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（1） 💬（1）<div>对于 n 位的数字类型，符号位是 1，后面 n-1 位全是 0，我们把这种情形表示为 -2^n

为什么这样表示呢？</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/0c/5d/0ccc195b.jpg" width="30px"><span>自由港</span> 👍（1） 💬（1）<div>“而符号位是 1，后面 n-1 位全是 0，我们已经说过这表示 -2^n。”
这个是不是应该表示-2^n-1 ?</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg" width="30px"><span>云韵</span> 👍（1） 💬（1）<div>&quot;计算机数据的溢出，就相当于取模。而用于取模的除数就是数据类型的上限减去下限的值，在加上1“ 这句话不理解。老师可以帮忙在详细解答一下吗？</div>2018-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/63/a2/1123d904.jpg" width="30px"><span>Jermery</span> 👍（1） 💬（1）<div>正数的原码、反码、补码都一样；
负数的反码是给为取反、补码是反码+1；
两数相减就是 正数原码 - 负数补码。
是这意思不？</div>2018-12-24</li><br/>
</ul>