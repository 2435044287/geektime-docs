你好，我是黄申，今天我们接着聊复杂度分析的实战。

上一讲，我从数学的角度出发，结合自身经验给你总结了几个分析复杂度的法则。但是在实际工作中我们会碰到很多复杂的问题，这个时候，正确地运用这些法则并不是件容易的事。今天，我就结合几个案例，教你一步步使用这几个法则。

## 案例分析一：广度优先搜索

在有关图遍历的专栏中，我介绍了单向广度优先和双向广度优先搜索。当时我提到了通常情况下，双向广度优先搜索性能更好。那么，我们应该如何从理论上分析，谁的效率更高呢？

首先我们来看单向广度优先搜索。我们先快速回顾一下搜索的主要步骤。

第一步，判断边界条件，时间和空间复杂度都是O(1)。

第二步，生成空的队列。常量级的CPU和内存操作，根据**主次分明法则**，时间和空间复杂度都是O(1)。

第三步，把搜索的起始结点放入队列queue和已访问结点的哈希集合visited，类似上一步，常量级操作，时间和空间复杂度都是O(1)。

第四步，也是最核心的步骤，包括了while和for的两个循环嵌套。

我们首先看时间复杂度。根据**四则运算法则**，时间复杂度是两个循环的次数相乘。对于嵌套在内的for循环，这个次数很好理解，和每个结点的直接连接点有关。如果要计算平均复杂度，我们就取直接连接点的平均数量，假设它为m。
<div><strong>精选留言（11）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/15/3f/2b/966c348b.jpg" width="30px"><span>zzz</span> 👍（12） 💬（1）<div>老师的课非常棒，每篇都干货满满，收获很多，这些年的工作常常过于关注业务逻辑的实现（也与工作岗位和性质有关），忽略了技术和数学知识沉淀，最近看了老师的文章，有种回到学生时代的感觉，同时觉得这些知识真的很重要，有了这些知识的了解和沉淀，工作中在解决问题时一旦能够回忆起来，那么将是区别于普通程序员的体现，也是成就感和快乐之所在，值得反复阅读和练习。点赞。</div>2019-02-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg" width="30px"><span>qinggeouye</span> 👍（4） 💬（1）<div>案例一，广度优先搜索的时间复杂度，第 I 次 while 循环，这里的 I 可以认为是起始的那个搜索节点的最大度数？</div>2019-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg" width="30px"><span>建强</span> 👍（2） 💬（1）<div>思考题：
平时工作中，和数据库打交道比较多点，性能分析和优化主要集中在对SQL语句的优化，一般通过SQL语句的执行计划，可以大致看出语句的搜索算法，虽然运用分析工具可以看出每一步的耗时情况，但如果结合老师讲的复杂度分析方法，对SQL语句的性能分析会更精准一点。</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（2） 💬（1）<div>我在之前分析双向广度有限搜索的复杂度的时候，没有考虑到 a 和 b 两个节点的度相差比较大的情况。

平时似乎没有遇到与性能分析相关的项目，如果遇到了性能的瓶颈，一般来说，加硬件是比较容易的部分——内存、SSD，上更多的服务器。

其实这应该是算法分析的核心部分，六个法则加上最好、最差、平均情况的综合判断，需要经验积累。</div>2020-02-12</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/kT185qC7s1afo3w6mFUXPpagtZ0JRguoBF2GSLcoN0ib6L8pB7ZUicuC87JU6LEqtCRNsJfaGzQw5hTA6fEuHNqg/132" width="30px"><span>marcus1877</span> 👍（1） 💬（2）<div>我有个问题，不知道现在还有人能回答不？
“如果单向需要走 l 条边，那么双向是 l&#47;2”。为什么双向是I&#47;2？</div>2020-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg" width="30px"><span>总统老唐</span> 👍（1） 💬（2）<div>“查看b是否在这m个节点中，时间复杂度为O(1)”，怎么不是O(m)呢？</div>2019-11-28</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/BAuQlia9Dc07m3icOkibIqu2lhbnLD6cjgCNE8FSzG5Aj4cd26eRgspicTsWvA7WK1ftlQBD34PYRucZRXML5FA27A/132" width="30px"><span>cwtxz</span> 👍（0） 💬（1）<div>学习了老师的“使用六个法则进行复杂度分析”，让我对算法的复杂度分析不再那么一头雾水。以前在看算法书籍、看算法相关例题的时候，对于给出的程序，看倒是能够看懂，但是叫我进行算法复杂度分析，完全就是无从下手。说白了，自己是完全不懂算法复杂度分析的概念，又何谈进行算法复杂度分析。现在，有了老师的指导，至少有了一个进行复杂度分析的方向，不再是那么迷茫，至少我能能尝试着对一些简单的程序进行量化分析了。于我而言，通过这种分析，我能够将自己的代码进行性能调优，使自己的编程水准再上一个台阶。感谢老师，我会继续加油的！！！</div>2020-01-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/01/9c/1a750bc7.jpg" width="30px"><span>l c</span> 👍（2） 💬（0）<div>双向广搜的特殊情况时间复杂度，ab的大小并不影响其搜索深度即l，而会影响底数即m。假如全平均情况为m，a &lt; b情况为 x, y， 既然是特殊情况，不妨令 x &lt; m &lt; y，则a b的特殊情况时间复杂度都会向广度更高的一方偏斜，即结果为O(y^(l&#47;2))).</div>2020-07-12</li><br/><li><img src="" width="30px"><span>013923</span> 👍（1） 💬（0）<div>谢谢老师！</div>2022-07-28</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（1） 💬（0）<div>对于不平均的双向广度遍历可以用更均衡一点的方法，也就是按照大学推进。例如左边平均连接的点数2事情，右边连接的点数是8.可以左边推进3层右边推进1层的进度进行，最终取得的效果是左右访问的点数差不多，这样总的访问点数最少（往左右移一层，新增的点数都大于减少的点数）。</div>2019-08-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg" width="30px"><span>罗耀龙@坐忘</span> 👍（0） 💬（0）<div>茶艺师学编程

1、关于算法复杂度(2)

为什么要搞这个东西呢?因为计算机科学家，编程人员需要一个客观、通用的标准来估算效率，而计算机正是有着说&quot;一不二的性格&quot;，学不会人类的&quot;辩证法&quot;，这样的估算才能成立。

人类也许会对能说出&quot;这样···在另一方面···&quot;自我感觉良好，但正因为这样，在大多数情况下只是在空谈。

2、关于老师在文中提到的双向广度优先搜索的特殊情况

当a&gt;b，我认为其空间、时间复杂度应该是O(m^((a-b)&#47;a))，如果a、b差距越大，则会趋近O(m^a)

当a&lt;b，则可能是O(M^((b-a)&#47;b))，如果a、b差距越大，则会趋近O(m^b)

这么说，当a、b越不均匀时，双向广度优先搜索的效用会网单向广度优先搜索回归。</div>2020-04-09</li><br/>
</ul>