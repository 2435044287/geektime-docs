你好，我是黄申。

作为程序员，你一定非常清楚复杂度分析对编码的重要性。计算机系统从最初的设计、开发到最终的部署，要经过很多的步骤，而影响系统性能的因素有很多。我把这些因素分为三大类：**算法理论上的计算复杂度、开发实现的方案和硬件设备的规格**。

如果将整个系统的构建比作生产汽车，那么计算复杂度相当于在蓝图设计阶段，对整个汽车的性能进行评估。如果我们能够进行准确的复杂度分析，那么就能从理论上预估汽车的各项指标，避免生产出一辆既耗油又开得很慢的汽车。

可是，你也常常会发现，要准确地分析复杂度并不容易。这一讲，我来说说如何使用数学的思维，来进行系统性的复杂度分析。

## 基本概念

我先带你简短回顾一下几个重要概念，便于你稍后更好地理解本节的内容。

**算法复杂度**是一个比较抽象的概念，通常只是一个估计值，它用于衡量程序在运行时所需要的资源，用于比较不同算法的性能好坏。同一段代码处理不同的输入数据所消耗的资源也可能不同，所以分析复杂度时，需要考虑三种情况，最差情况、最好情况和平均情况。

复杂度分析会考虑性能的各个方面，不过我们最关注的是两个部分，时间和空间。时间因素是指程序执行的耗时多少，空间因素是程序占用内存或磁盘存储的多少。因此，我们把复杂度进一步细分为时间复杂度和空间复杂度。
<div><strong>精选留言（13）</strong></div><ul>
<li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132" width="30px"><span>pyhhou</span> 👍（12） 💬（1）<div>思考题感觉要根据具体图的情况来看具体时间复杂是多少，就之前的六度关系的例子，假设把关系看作是一个树，每个结点都有 n 个子结点，要确认两个人是几度好友，也就是确认两个结点相距多少层，如果是单向广度优先搜索，时间复杂度 O(n^degree)，双向可以运用加法法则，两边同时出发，时间复杂度 2 * O(n^(degree&#47;2))，空间复杂度是队列中暂存的结点的最大值，和时间复杂度一样</div>2019-03-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg" width="30px"><span>Being</span> 👍（5） 💬（1）<div>老师，我想了很久，不能确定，双向BFS的停止条件跟maxDegrees有关，也就是说最坏的情况是刚好到maxDgrees时搜索到，所以时间复杂度应该是 maxDgrees * 2*（V+E），运用四则运算法则，这个队列循环了maxDgrees次，每一次对node的访问都是（V+E），而双向是两端并进所以乘2，再根据主次分明，将常量这些去掉，最后就是O（V）。
空间复杂度也和maxDegrees有关，队列有两个maxDegrees*（V+E），visited的容器也有两个，同样的，主次分明来说，其他的变量就可以忽略了，然后用四则运算法则来计算，就是相加，最后是O（V）
以上都是算的最坏情况，最好情况是O（1），平均情况? 最后跟最坏情况一样，是使用排列组合法则推导吗？我后面再试试。</div>2019-01-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/c2/21/a8ef82ac.jpg" width="30px"><span>炎发灼眼</span> 👍（3） 💬（1）<div>老师，有一点不明白，为什么在计算归并的复杂度时，切分的复杂度就是按照节点来算，是算每次切的时间么？而归并的时候是算指数的，合并的时候，其实也是两个节点合并一个，应该是按照合并的数目来算的。   </div>2019-10-10</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/SBoicEsX0vbhwwDas5LbRGSy5Miba37hBXYYd9TJyHepUfIpr105WFPlCFkxlvKWfTgpLODkb6sswkTEpALANlPw/132" width="30px"><span>冉冉</span> 👍（2） 💬（1）<div>“ 在数据归并阶段，我们看二叉树的高度，为 log2n，因此归并的次数为 log2n ”  为什么是看二叉树高度呢？我觉得归并次数应该和切分次数一样，都是看非叶子结点的个数吧？</div>2020-09-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg" width="30px"><span>拉普达</span> 👍（1） 💬（1）<div>考虑图的平均节点度是d，平均最短路径（假设为无权图）为D。时间复杂度为O(D*d&#47;2),O(d＾(D&#47;2)*2)。</div>2020-03-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg" width="30px"><span>Being</span> 👍（1） 💬（1）<div>嗯，V是节点的数量，E是边的数量，根据邻接矩阵的概念来的。</div>2019-01-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg" width="30px"><span>建强</span> 👍（0） 💬（1）<div>双向广度搜索算法的时间复杂度：取决于算法中的搜索次数，每次搜索之后，还要计算两个搜索结果的交集，而搜索次数是两个节点的共同好友交集中，到各自的出发点度数最大的那些节点。
空间复杂度：搜索过程中两者所有好友的结点数之和，即存贮已访问节点的存贮空间。</div>2020-03-01</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwQvLGE4dMsF4JU0svW3DtGbodpjskbY65FdwF13JdtBYZfgL2IXHlHrdejWzHdjT0RibEIfib4QYA/132" width="30px"><span>知行合一</span> 👍（0） 💬（1）<div>平均复杂度的计算稍微繁琐一些。如果距离为 n-1，只有 1 种可能，a 为数组中第一个字符，b 为数组中最后一个字符。如果距离为 n-2，那么 a 字符的位置有 2 种可能，b 在 a 位置确定的情况下只有 1 种可能，因此排列数是 2。以此类推，如果距离为 n-3，那么有 3 种可能，一直到距离 1，有 n-1 种可能。所以平均的扫描次数为 (1 *(n-1) + 2 *(n-2) + 3(n -3) + … + (n-1)1) &#47; (1 + 2 + … + n)，最后时间复杂度简化为 O(n)。
老师，这个分母（1+2+•••+n）怎么理解</div>2019-12-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/dd/49/da7125ef.jpg" width="30px"><span>天佑</span> 👍（0） 💬（1）<div>看不懂里面的数学符号，怎么来的，为什么是log...</div>2019-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg" width="30px"><span>罗耀龙@坐忘</span> 👍（1） 💬（0）<div>茶艺师学编程

关于算法复杂度

1965年哈特马尼斯（Juris Hartmanis）和斯坦恩斯（Richard Stearns）提出了算法复杂度的概念（二人后来因此获得了图灵奖），而最早将复杂度严格量化衡量的是著名计算机科学家、算法分析之父高德纳（Don Knuth）。今天，全世界计算机领域都以高德纳的思想为准。

高德纳的思想主要有三部分：

1. 在比较算法的快慢时，需要考虑数据量特别特别大，大到近乎无穷大时的情况。

2. 决定算法快慢的因素虽然可能很多，但是所有的因素都可以被分为两类。第一类是不随数据量变化的因素，第二类是随着数量变化的。

3. 如果两种算法在量级上相当，在计算机科学里，就认为它们是一样好的。

大神的思想和今天老师讲的六原则，是不是已经很接近了?（特别是第三点）

回到思考题，请试着用使用规则，分析一下双向广度优先搜索的时间和空间复杂度。

（数学学渣，真的说错了请大家指教了）

由于是双头开始搜索，我猜其时间复杂度是O（logN），空间复杂度也应该是O(logN)

</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（0） 💬（0）<div>分析复杂度时，需要考虑最差、最好和平均情况，不过一般比较常见的是分析平均情况。

复杂度分析最关注时间和空间，但是因为一般来说，存储比较便宜，或者时间更容易度量，所以更多的考虑时间复杂度。

对于总结的六个法则比较有意思，但是感觉并不容易记住，但是如果分析的算法多了，就会变成自然而然的肌肉记忆了。

尝试分析一下双向广度优先搜索。

假设 a、b 两个节点的度数为 m、n，那么首先从 a 出发，分析 m 个子节点，如果未找到 b，就再找 b 的 n 个子节点。如果假设图上所有点的平均度数为 x，点数为 y，那么最好的情况下，时间复杂度为 O(x)，最差的情况为 O(xy)，那么平均的时间复杂度可能是 O(xy&#47;2)。

空间复杂度应该就是存储所有节点所占用的空间，加上 visited 的等辅助记录，一般也就是 O(X)</div>2020-02-12</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/BAuQlia9Dc07m3icOkibIqu2lhbnLD6cjgCNE8FSzG5Aj4cd26eRgspicTsWvA7WK1ftlQBD34PYRucZRXML5FA27A/132" width="30px"><span>cwtxz</span> 👍（0） 💬（0）<div>编程这么些年，其实并没有系统地学习过算法，更不用谈分析时间复杂度和空间复杂度了。时间复杂度和空间复杂度这两个算法分析领域的专业术语虽然如雷贯耳，可惜我却没有真正认真系统地去了解过它，这两个名词于我而言更像是遥不可及的概念而不是贴近生活的工具。早些年的时候，编程于我而言就是实现功能、实现业务逻辑而不必理会代码的质量，执行的效率等因素。编程，似乎就是单纯地粗糙地完成功能，而不用管代码的优雅。这是小公司程序员的通病，一切以开发效率为先，编码质量不是特别重要。久而久之，自己的水平还是原地踏步。看了、学了老师的课程，给我指明了前进的方向，让我切实地感受到了自己的进步，感谢老师，我会坚持学习下去的。加油！！！</div>2020-01-03</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（0） 💬（0）<div>算法的复杂度分析是一个统计+近似的过程，先用四则运算把所有消耗的成本统计出来，如果递归的话，可能用到画成递归树来求和，然后把一些低阶的复杂度全部删除只保留高阶的，多个变量需要表达成多变量的函数，最终得到一个最简表达式。</div>2019-08-28</li><br/>
</ul>