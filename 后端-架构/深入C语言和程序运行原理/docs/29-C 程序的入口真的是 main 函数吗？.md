你好，我是于航。

“main 函数是所有 C 程序的起始入口”，相信对于这句话，每个同学在刚开始学习 C 语言时都很熟悉，因为这是一个被各种教材反复强调的“结论”。但事实真是如此吗？

实际上，这句话对，但也不完全对。在一段 C 代码中定义的 main 函数总是会被优先执行，这是我们在日常 C 应用开发过程中都能够轻易观察到的现象。不过，如果将目光移到那些无法直接通过 C 代码触达的地方，你会发现 C 程序的执行流程并非这样简单。

接下来，我们先通过一个简单的例子，来看看在机器指令层面，程序究竟是如何执行的。

## 真正的入口函数

这里，我们首先在 Linux 系统中使用命令 “gcc main.c -o main” ，来将如下所示的这段代码，编译成对应的 ELF 二进制可执行文件。

```bash
// main.c
int main(void) {
  return 0;
}
```

在上述代码中，由于没有使用到任何由其他共享库提供的接口，因此，操作系统内核在将其对应的程序装载到内存后，会直接执行它在 ELF 头中指定的入口地址上的指令。紧接着，使用 readelf 命令，我们可以获得这个地址。然后，通过 objdump 命令，我们可以得到这个地址对应的具体机器指令。

我将这两个命令的详细输出结果放在了一起，以方便你观察，如下图所示：
<div><strong>精选留言（2）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg" width="30px"><span>一个工匠</span> 👍（9） 💬（1）<div>操作系统对 Shell 的执行，是靠 Shell 解释器完成的。在操作系统运行后，Shell 解释器本身就加载并运行了。其中如 pwd,cd 这些是内部命令，本质是函数调用，可以直接使用。ls 这些是外部命令，需要 fork 一个新进程执行当前命令。一个shell脚本，有很多个这些内外部命令组成，通过 shell 解释器逐行解释完毕后执行。shell 解释器也是一个应用程序，本质是一个 C 程序，不过在该程序中，手动模拟了函数调用栈，和 JVM 有相似之处。所以 shell 解释器，也有静态库&#47;动态库&#47;静态链接&#47;动态链接这些，为 shell 命令的执行保障护航。</div>2022-03-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg" width="30px"><span>荷兰小猪8813</span> 👍（1） 💬（0）<div>shell 本身就是个程序是运行在 Linux 上的进程，shell 内部命令的执行是在对应的 shell 进程内运行的，外部命令是不同的，要 fork 一个新进程～～</div>2022-05-15</li><br/>
</ul>