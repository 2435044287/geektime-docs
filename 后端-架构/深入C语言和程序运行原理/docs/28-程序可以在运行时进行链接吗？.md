你好，我是于航。

在上一讲中，我介绍了有关 Linux 下静态链接的内容。而这一讲，我们将继续程序的“链接”之旅，来看看我之前提到的另外两种链接类型，加载时链接与运行时链接。

实际上，加载时链接与运行时链接均可归为动态链接，只是在这两种方式中，程序进行链接的具体时刻有所不同。其中，加载时链接发生在程序代码被真正执行之前；而运行时链接则可发生在程序运行过程中的任意时刻。

## 为什么要使用动态链接？

在上一讲中，我已经简单介绍了静态链接与动态链接两者的区别。其实，动态链接技术出现的最重要目的，便是为了解决静态链接具有的一些明显缺点。试想，假设一个应用程序依赖于多个第三方模块提供的函数实现，而这些模块均以静态库（包含有多个目标文件）的方式提供。那么，每次想要使用它们的最新版本时，我们都需要显式地将程序与它们重新进行链接。对于大多数普通的应用使用者来说，这个过程所花费的成本当然是无法接受的。

另外，使用完全静态链接也会导致那些本可以被多次重用的通用功能函数，无法被统一“提取出来”，这便会导致程序的二进制可执行文件体积变大。并且，这些通用代码的副本会随着多个进程的运行，被多次加载到内存中，而这也极大地浪费了宝贵的内存资源。而动态链接技术的出现，便可以解决上述这些问题。
<div><strong>精选留言（7）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg" width="30px"><span>liu_liu</span> 👍（7） 💬（1）<div>
老师，有几个问题想了解下：

1. 假设共享库 M，引用由应用程序定义的某个全局变量 g。而 A、B 程序都链接了 M，那么 M 中的 .got 是不是需要复制一份？因为 A、B 中 g 变量的虚拟地址不一样。

2. 关于 _dl_runtime_resolve 做符号重定位，是会遍历到所有依赖的动态库吗？如果两个动态库中都有这个符号，那么会定位到顺序靠前的动态库中的符号？

3. 如果第 2 点成立，那遍历动态库的顺序是根据链接时参数的顺序来的吗？</div>2022-02-28</li><br/><li><img src="" width="30px"><span>福利社</span> 👍（3） 💬（1）<div>现在程序的链接库越来越多，请问老师，有没有办法找出程序所有存在symbol interposition的函数及所在的动态库。</div>2022-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/80/f4/564209ea.jpg" width="30px"><span>纳兰容若</span> 👍（2） 💬（1）<div>老师您好 有个问题请教一下
在图中的地址是不是画错了，一个是601008一个是6001008，还是地址之间有换算</div>2022-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/95/d1/72b27b22.jpg" width="30px"><span>谦谦</span> 👍（0） 💬（1）<div>老师你好，请问下，为什么编译应用程序的时候，共享库和应用程序要放在一起。假如我只知道共享库的名字，和运行时所在的路径。这种情况可以编译应用程序吗？</div>2022-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg" width="30px"><span>荷兰小猪8813</span> 👍（0） 💬（3）<div>假设共享库 M，引用由应用程序定义的某个全局变量 g。而 A、B 程序都链接了 M。。

这个关系很奇怪，这个应用程序是指的 A 和 B 么？？

如果是 A 和 B，这个依赖关系不是很怪么？</div>2022-05-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg" width="30px"><span>连瑞龙</span> 👍（1） 💬（0）<div>在Linux系统中，共享库（shared library）使用 soname（共享库的名字）机制来管理共享库的版本。soname是&quot;Shared Object NAME&quot;的缩写，它是在共享库中嵌入的标识符，用于指定库的版本信息。

soname机制的主要目的是在不同版本的共享库之间提供兼容性，以允许多个版本的共享库在系统上共存，而不会相互干扰。soname由以下两个部分组成：

1. **实际文件名（Real name）：** 共享库的实际文件名，通常以`.so`为后缀。

2. **soname：** 共享库的名字，包含主版本号。soname一般形式为`lib&lt;name&gt;.so.&lt;major&gt;`，其中`&lt;name&gt;`是库的基本名字，`&lt;major&gt;`是主版本号。例如，`libexample.so.1`。

在共享库的构建和安装过程中，开发者通常会使用`-soname`选项来指定soname。例如：

```bash
gcc -shared -o libexample.so.1.0 -Wl,-soname,libexample.so.1 example.o
```

这个命令将生成一个名为`libexample.so.1.0`的共享库文件，并且指定其soname为`libexample.so.1`。这样，当程序链接到共享库时，会使用soname来查找和链接共享库，而不是直接使用实际文件名。

使用soname的主要优势包括：

- **版本管理：** soname允许系统上存在多个版本的同一个共享库，每个版本都可以独立安装和管理。

- **向后兼容性：** 当共享库的API发生变化时，通过更新soname，可以确保新版本与旧版本兼容，从而防止因为API的变化而导致的程序崩溃。

- **符号冲突的解决：** 当多个共享库的实际文件名相同，但soname不同时，可以避免符号冲突，确保程序能正确链接到所需版本的库。

总之，soname机制在Linux系统中用于管理共享库的版本，提供了一种有效的方式来确保共享库的向后兼容性和版本管理。</div>2024-01-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/8d/0e/1f49ade9.jpg" width="30px"><span>海鲨数据库架构师_曾院士</span> 👍（0） 💬（0）<div>请问下如何把所有SO都打包进一个文件,包含系统依赖的SO?</div>2024-11-25</li><br/>
</ul>