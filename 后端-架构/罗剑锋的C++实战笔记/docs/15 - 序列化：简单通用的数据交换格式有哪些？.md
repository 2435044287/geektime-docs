你好，我是Chrono。

在前面的三个单元里，我们学习了C++的语言特性和标准库，算是把C++的编程范式、生命周期、核心特性、标准库的内容整体过了一遍。从今天起，我们的学习之旅又将开启一个新的篇章。

C++语言和标准库很强大，功能灵活，组件繁多，但也只能说是构建软件这座大厦的基石。想要仅凭它们去“包打天下”，不能说是绝对不可行，但至少是“吃力难讨好”。

还是那句老话：“不要重复发明轮子。”（Reinventing the wheel）虽然很多C++程序员都热衷于此，但我觉得对于你我这样的“凡人”，还是要珍惜自己的时间和精力，把有限的资源投入到能有更多产出的事情上。

所以，接下来的这几节课，我会介绍一些第三方工具，精选出序列化/反序列化、网络通信、脚本语言混合编程和性能分析这四类工具，弥补标准库的不足，节约你的开发成本，让你的工作更有效率。

今天，我先来说一下序列化和反序列化。这两个功能在软件开发中经常遇到，你可能很熟悉了，所以我只简单解释一下。

序列化，就是把内存里“活的对象”转换成静止的字节序列，便于存储和网络传输；而反序列化则是反向操作，从静止的字节序列重新构建出内存里可用的对象。

我借用《三体》里的内容，打一个形象的比喻：序列化就是“三体人”的脱水，变成干纤维，在乱纪元方便存储运输；反序列化就是“三体人”的浸泡，在恒纪元由干纤维再恢复成活生生的人。（即使没读过《三体》，也是很好理解的吧？）
<div><strong>精选留言（28）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg" width="30px"><span>被讨厌的勇气</span> 👍（34） 💬（1）<div>直接memcpy,同一种语言不同机器，或者不同语言可能存在兼容问题(变量内存存储布局、编码可能不同)，而Json是一种标准，由Json库处理编码问题(比如大小端)，且不同语言间统一，对头不？</div>2020-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg" width="30px"><span>蓝配鸡</span> 👍（13） 💬（1）<div>序列化&#47;反序列化命名就用 “脱水&#47;浸泡”， 会不会被打死- -</div>2020-06-12</li><br/><li><img src="" width="30px"><span>java2c++</span> 👍（11） 💬（1）<div>问题2:和redis交互一般使用json，主要原因是可读性强，有问题时直接登录到redis控制台可以查看json内容，不过序列化需要的时间成本空间成本都是最高，如果追求性能就需要选择其他的了。
现在一些网络框架（rpc框架）都支持多种序列化的方式了，msgpack，thift跨语言支持的比较好，性能也不错我工作中相对用的多一些</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg" width="30px"><span>风</span> 👍（7） 💬（1）<div>json不存在大小端，字节序的问题吧，反正就是一个字符串。messagepack这种二进制格式的东西，才要考虑大小端。</div>2020-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/1c/0e/f2954d1c.jpg" width="30px"><span>hy</span> 👍（7） 💬（1）<div>pb有2G内存限制问题，如果对象过大会不行</div>2020-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg" width="30px"><span>于小咸</span> 👍（3） 💬（1）<div>除了兼容不同语言外，序列化还有一个重要的作用是数据保存和网络传输，我们很难保证不同平台上内存里存的数据是一样的。

此外，对于包含指针的数据结构，我们是没法简单的memcpy，这会带来浅拷贝类似的问题。</div>2021-09-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/4b/22/10df9727.jpg" width="30px"><span>Why not.</span> 👍（3） 💬（1）<div>jsoncpp 也挺好用的 不知道老师怎么看</div>2020-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg" width="30px"><span>do it</span> 👍（3） 💬（1）<div>1、为什么要有序列化和反序列化，直接 memcpy 内存数据行不行呢？
  字节序问题；序列号反序列化可数据压缩(不确定😁)
2、你最常用的是哪种数据格式？它有什么优缺点？
  工作中使用json多一点，有时使用pb。
pb:压缩效率算优点吧。改变结构需重新生成proto文件、proto怎么难阅读算不足之处</div>2020-06-12</li><br/><li><img src="" width="30px"><span>java2c++</span> 👍（3） 💬（1）<div>问题1:针对跨服务间的调用，涉及到网络传输，需要使用到字节流进行传输，序列化就是发送方将数据对象转化成字节流的过程，反序列就是接收方将字节流转化成数据对象的逆过程</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg" width="30px"><span>EncodedStar</span> 👍（3） 💬（1）<div>序列化和反序列化 可以按用户自定义的方式去读取吧，底层应该也是用类似memcpy这样的操作去处理里，只不过是又封装了一次统一接口方便我们使用，老师，我可以这么理解吗？？
常用json 和 pb ，感觉就是json对C++不是很友好，很多时候有\转义符困扰，pb就是每次比较麻烦，改了协议之后还的生成一下对应文件</div>2020-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/d6/e4/fee14bd8.jpg" width="30px"><span>严腾</span> 👍（1） 💬（1）<div>message pack使用 MSGPACK_DEFINE 来处理自定义类，如果自定义类中有第三方库的成员变量，这时候该如何处理？
</div>2020-12-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/26/db/e2d69a2e.jpg" width="30px"><span>刘杰</span> 👍（0） 💬（1）<div>有的像csv的数据，带了时间列，并且数据包含了多种类型，用结构体存盘，这个怎么实现的，有什么好处？</div>2022-11-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg" width="30px"><span>孙新</span> 👍（0） 💬（1）<div>我们json用的boost做的编解码，不知道横向对比效率是个什么程度。</div>2022-03-16</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132" width="30px"><span>Stephen</span> 👍（0） 💬（1）<div>差点把序列化和持久化弄混了，差点答成memcpy是内存操作，不能持久化为文件。我知道json是可以持久化的，不知道另外两种可不可以。
</div>2021-06-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/2f/43601694.jpg" width="30px"><span>Patrick</span> 👍（0） 💬（1）<div>老师，您好；代码中的示例，关于msgpack.cpp，我遇见奇怪的问题，单独运行主函数的case3方法会出现std::bad_cast错误，意思是反序列化未能cast，但是如何case1()或者case2()与case3()一起运行，则就没有这问题了，我安装了最新的msgpack库，使用其中的msgpack.hpp，依旧不行。我不得其解，是什么原因造成的。</div>2020-12-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg" width="30px"><span>Sudouble</span> 👍（0） 💬（1）<div>问题1的，不同机器，大小端，字节的对齐不一样，还原时会产生不一致的问题</div>2020-09-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/80/e5/251d89b5.jpg" width="30px"><span>锦鲤</span> 👍（0） 💬（2）<div>C++服务端的gRPC框架有什么可以推荐的吗？</div>2020-07-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/c5/6e/604ec5d4.jpg" width="30px"><span>海漩涡</span> 👍（0） 💬（1）<div>section4里没有Makefile啊</div>2020-07-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ed/6c/6fb35017.jpg" width="30px"><span>群书</span> 👍（0） 💬（1）<div>做网络开发时 要将多字节数值型数据转换为网络字节序列兼容不同架构的机器，protobuf也有字节序列转化的过程吗</div>2020-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/72/52/8e81daf1.jpg" width="30px"><span>屈肖东</span> 👍（0） 💬（1）<div>有个问题，如果我把所有的要发送的数据类型，都转成字符数组，例如，int通过hton转为网络字节序，再转为4字节的字符数组，其他的也用类似的处理。在接收端，用相反的操作处理，再解出来，是不是也可以实现上面的这种功能。因为字符数组在网络中传递应该是不会因为编程语言和平台的区别而出现差别的。我不清楚我的这种处理跟序列化和反序列化的操作最终产生的效果有什么区别。仅仅是在通用行上的差别还是有其他更深刻的区别。</div>2020-06-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/7f/bd/6ba7d5a5.jpg" width="30px"><span>wonderNick</span> 👍（0） 💬（1）<div>老师，您认为 rapidjson 和 json for modern C++ 两者的优劣势有哪些呢？
我们项目现在用的 rapidjson ，性能很好，但是易用性比 json for modern C++ 差一点。 正像   json for modern C++ 的名字一样，更现代一些，看起来有些像移动端的序列化工具（比如IOS的 handyjson）</div>2020-06-12</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK5icO2A4K7HYTYfQoagTz7VbtgxfS2ibBqLnKVWwQZgsePibZWFvFJEhPT8BtpQSaFx9IEodyp6c0dw/132" width="30px"><span>Geek_jg3r26</span> 👍（0） 💬（1）<div>objtibec是不是也可以用pb</div>2020-06-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg" width="30px"><span>浑浑噩噩cium</span> 👍（0） 💬（1）<div>还有csv，xml也用的比较多</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" width="30px"><span>范闲</span> 👍（0） 💬（1）<div>序列化和反序列化实际是通信内容的一个标准协议，有点像JVM，不区分平台只要同一套协议就可以互相通信</div>2020-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/54/87/3b1f9de4.jpg" width="30px"><span>Confidant.</span> 👍（0） 💬（1）<div>老师能推荐点pb的资料吗，最好是中文的</div>2020-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg" width="30px"><span>禾桃</span> 👍（0） 💬（1）<div>#1 感觉序列化&#47;反序列化要做的事是，把原有的一堆有实际意义的字节变的更小，更紧凑，又有点加密解密的感觉。memcpy貌似没有完成这两个任务。</div>2020-06-09</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132" width="30px"><span>木瓜777</span> 👍（0） 💬（1）<div>json,pb都使用过！目前项目中后端 我们自己手动序列化json为二进制，然后前端按字节解析，这样虽然比较自由，但比较繁琐！  pb是有作者说的那些问题，需要预定义结构！
我想问下，就序列化效率，还有 传输字节大小而言，messagepack、pb哪种更好？谢谢</div>2020-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/b4/63/59bb487d.jpg" width="30px"><span>eletarior</span> 👍（0） 💬（1）<div>除了json，其他的两种倒是还没用过，另外，用的多的是Apache的Thrift库，用起来感觉和ProtoBuffer差不多；序列化是数据交换时打包的一种方式，在数据量比较大，而且需要和其他语言打交道时使用，本地序列化，发送，接收方接收后，反序列化，读取一气呵成。
如果直接copy内存做数据交换，接收方对数据的解析没有标准，而且容易出错。
</div>2020-06-09</li><br/>
</ul>