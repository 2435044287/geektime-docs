你好，我是陈皓，网名左耳朵耗子。

之前在我们讲的幂等设计中，为了过滤掉已经处理过的请求，其中需要保存处理过的状态，为了把服务做成无状态的，我们引入了第三方的存储。而这一篇中，我们来聊聊服务的状态这个话题。我认为，只有清楚地了解了状态这个事，我们才有可能设计出更好或是更有弹力的系统架构。

所谓“状态”，就是为了保留程序的一些数据或是上下文。比如之前幂等性设计中所说的需要保留每一次请求的状态，或是像用户登录时的Session，我们需要这个Session来判断这个请求的合法性，还有一个业务流程中需要让多个服务组合起来形成一个业务逻辑的运行上下文Context。这些都是所谓的状态。

我们的代码中基本上到处都是这样的状态。

# 无状态的服务 Stateless

一直以来，无状态的服务都被当作分布式服务设计的最佳实践和铁律。因为无状态的服务对于扩展性和运维实在是太方便了。没有状态的服务，可以随意地增加和减少节点，同样可以随意地搬迁。而且，无状态的服务可以大幅度降低代码的复杂度以及Bug数，因为没有状态，所以也没有明显的“副作用”。

基本上来说，无状态的服务和“函数式编程”的思维方式如出一辙。在函数式编程中，一个铁律是，函数是无状态的。换句话说，函数是immutable不变的，所有的函数只描述其逻辑和算法，根本不保存数据，也不会修改输入的数据，而是把计算好的结果返回出去，哪怕要把输入的数据重新拷贝一份并只做少量的修改（关于函数式编程可以参看我在CoolShell上的文章《[函数式编程](https://coolshell.cn/articles/10822.html)》）。
<div><strong>精选留言（26）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/84/04/aceac3b5.jpg" width="30px"><span>流迷的咸菜</span> 👍（2） 💬（1）<div>虽然有状态的服务可以通过sticky session的方式将数据本地化，但是当这个sticky session expire的时候，或者服务处理完成之后，其相关的数据仍然是要同步到数据库中的吧？</div>2018-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a6/90/5295fce8.jpg" width="30px"><span>昵称</span> 👍（1） 💬（1）<div>sixcky session和DHT哪里有详细的介绍，这篇文章里好多名词都不认识</div>2018-04-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/6a/d5/73c75eb3.jpg" width="30px"><span>夜行观星</span> 👍（1） 💬（1）<div>皓哥，这篇是在讲是在讲Service Mesh的思想吗？</div>2018-03-06</li><br/><li><img src="" width="30px"><span>mingshun</span> 👍（70） 💬（3）<div>这是近几年所在的团队维护的其中一个重要系统的过程：最初为提高处理性能和水平扩展性，就从有状态往无状态发展。但随着数据量越来越大时，分布式存储就成了瓶颈，经常因为存储系统同步不及时导致不同节点读到的数据不一致。而后又回到有状态，但不在节点间使用分布式存储，因为数据量实在太大。为了在出现故障能快速恢复，每个节点做成双机热备。每改一次架构都要分好几次在周末深夜做数据迁移，多么痛的领悟啊！
理想情况下，计算密集型系统应该让存储向计算方移动，即做成无状态的；存储密集型系统应该让计算向存储移动，即做成有状态的。而上述架构来回修改的最终体会是，当计算和存储都密集的时候，应该整台机器地加，而且每台机器都要求有高的计算和存储性能。
然而说到底，存储其实又是由独立于CPU之外的一个计算单元来处理，本质似乎又回到了计算。现在设计分布式系统时总是先想着怎么分离计算和存储，最终发现计算和存储又是如此密不可分。
感觉我后半段的表述不太成立，打码久了不写人话的后果啊，望谅解！</div>2018-05-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/05/13/d12a43eb.jpg" width="30px"><span>null</span> 👍（16） 💬（3）<div>单体应用跟微服务应用的区别是单体应用是有状态的,微服务应用的是无状态的;单体应用向微服务应用的发展的一个重要体现就是将应用的状态从应用实例中转移到第三方中间件中.例如会话信息,传统的Java项目是将会话存储在tomcat等servlet容器中对其他的java应用隔离,这样导致的结果是如果想扩展服务的之后只能扩展单台服务器.而微服务能则将会话技术放到redis等nosql中间件中或者直接存到客户端中(jwt),微服务中的所有实例都可读取到
我认为分布式微服务应用还是无状态的比较好,因为现有的有状态分布式应用技术不成熟,gossip协议会导致羊群响应,导致而且如果数据大的情况下宽带会十分巨大.而现有的微服务解决方案依赖第三方中间件,这些中间件天生支持扩展分布式,让专业的工具做专业的事.如果服务要做到有状态的话每个服务中存储的状态数据需要做到一致(不管请求到达那个实例产生的结果一致),这也需要多分数据冗余,这样的话还不如放在第三方中间件中,像redis,mysql集群分布式方案十分丰富而且用的人也多
其实我们可以在有状态跟无状态之间做折中;我们可以参照java线程内存模型的形式,把第三方中间件当作JVM的主内存,微服务实例当作java线程对于主内存的拷贝,每个java线程只会拷贝自己需要访问的数据,微服务实例可以将数据缓存到guava cache或者ecache等进程级的缓存中;当微服务实例需要访问某个值的时候先去进程级缓存中查找,找不到再到集中式缓存中查找;更新某个值的时候,微服务本身先更新值,再将值更新到集中式缓存中,最好时候mq中间件通知其他的微服务实例更新自己进程中的缓存值,当然这里可以在计算更新值的时候避免缓存击穿事件分布式分布式锁技术</div>2020-01-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg" width="30px"><span>Sdylan</span> 👍（6） 💬（3）<div>存在错别字：结点-节点；元数据索引中对应关键-对应关系。本节笔记如下：
## 服务状态
### 什么是状态
状态：保留程序的一些数据或是上下文：
	* 程序调用的结果。
	* 服务组合下的上下文。
	* 服务的配置。
### 服务状态类型
1. 无状态的服务
	* 可以随意扩展或删除节点
	* 依赖第三方储存系统以及自身构建缓存，第三方存储系统：
		* Redis
		* MySQL
		* 高可用强一直：ZK&#47;Etcd
	* 依赖有状态存储服务，存在网络开销；自身构建缓存浪费资源
2. 有状态的服务
* 数据本地化（Data Locality），延时低
* 更高的可用性和更强的一致性
* 特点：请求映射到同一个节点， 出现：Sticky Session 或是 Sticky Connection
* 如何实现Sticky Connection
	* 长链接或一致性hash，出现服务热点问题
	* 做到负载和数据均匀方案
		* 路由节点
			* 元数据索引：映射后端服务实例和请求的对应关系表
			* 路由结点：根据元数据索引来路由，而这个元数据索引表会根据后端服务的压力来重新组织相关的映射
		* 直连，不好动态扩展
		* Gossip 协议，广播节点信息同步元数据
* 案例：Facebook 的 Scuba、 Orleans
* 资料：《Making the Case for Building Scalable Stateful Services in the Modern Era》

3. 有无状态服务的对比
无状态的服务需要我们把数据同步到不同的结点上，而有状态的服务通过 Sticky Session 做数据分片（当然，同步有同步的问题，分片也有分片的问题，这两者没有谁比谁好，都有 trade-off）。</div>2019-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e9/9a/1d9e1d9a.jpg" width="30px"><span>北极点</span> 👍（6） 💬（0）<div>这里的这些方案，总体下来感觉架构上需要超丰富的经验！协调一大帮人来弄这个。现在接触到的系统没有这么复杂！有问题一般一个小点一个小点的优化。读了文章还是感觉很收益！谢谢！</div>2018-03-09</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/VfE7OiboMc7SKwOiczAJDWo3T4WJn0dVW8yPEpVRUFtk6ib0DUicN1eDfpel1UAgp8ia4kqEjXSVXOVHcoZKXhq7k4w/132" width="30px"><span>Geek_Heiko</span> 👍（5） 💬（0）<div>阅读笔记小结:
首先，我们先认识到，一个服务的状态通常是包含: 服务处理所需的元数据、与其它服务组合完成一个业务逻辑的组合上下文和服务的配置。
分布式系统架构中，为了便于系统服务增删和调度，往往要求其服务设计成“无状态”的服务，及类似于函数式编程，其中的服务只管描述其处理逻辑和算法，无需在其中保存上述的&quot;状态&quot;。具体到分布式系统的实现方案是，将这些状态，统一耦合到一个高可用的强一致性的第三方状态存储服务中，这过程主要带来了大量的网络开销、业务处理过程的数据同步及其带来的处理速度降低的问题，且每个服务都需要相对额外地耦合且依赖于该第三方服务接口，对应地，已有的优化方案是底层采用分布式文件系统提高状态的调度和同步速度，无状态的服务添加一些缓存机制。
然而，对于一些数据密集型的应用，无状态服务的无法比拟有状态服务的性能和满足实际需求指标。有状态服务的数据存放在本地，处理延迟低，且其可用性和一致性更强。当从另一方面来说，从整个系统的角度来看，服务间的通信和整个系统的各方面如数据和负载的均衡会带来一定的压力。因为业务层面的数据同步需要该服务将保持长连接，随着一个接一个业务的完成需要接入，该服务将很快成为&quot;热点&quot;，若没有适时的断开，其资源必将消耗殆尽。现今的处理方式主要是引入一个元数据索引和路由节点，将后端服务和服务请求进行映射，以在一定程度上调和后端服务的压力。还有一种处理方式是不引入其他的，让有状态的服务直接充当路由的功能，每次服务节点的启动将配置的元数据读到内存中，然后系统的各个节点统一采用 Gossip 协议以便达到集群内的相关同步。
最后，一个业务及其所在的系统是有其生命周期及其不断地演化着的，其中的服务可以是无状态的，业务及其所在的系统是不能的(不然就失去其存在的意义)。对于这些&quot;状态”的冗余备份和快速调度，我们采用在运行时只要有机会就进行相关的复制，“状态”的同步，我们采用在前面的操作前后分两阶段提交的方案以保持其一致性。最后一点是，使用合适的分布式文件系统是有状态的服务调度的关键。</div>2020-01-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg" width="30px"><span>罗杰.菲の樂</span> 👍（3） 💬（0）<div>突然发现Twitter 的美女工程师 Caitie McCaffrey现在加入微软的Azure了</div>2020-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg" width="30px"><span>slark</span> 👍（3） 💬（0）<div>服务的状态，很简单：有状态、无状态
实际，状态一定都是有的，但服务的状态可以通过服务间的转移，把他们迁移到第三方存储上去。比如Redis、MySQL、Zookeeper&#47;Etcd或者分布式文件系统，通过这样实现了服务的扩缩容和维护便利。但也增加了和第三方系统的耦合，以及请求链路和响应时间。
有状态，通常可以把状态保存在实例的本地，可以保证更高的可用性和更强的一致性。为了让请求落到同一个实例，可能需要采用数据分片的方式，比如用长连接、用hash分片。这样会导致不同节点的请求、数据存储不平衡。所以也通常需要添加路由节点，或者每个实例自己具有路由的功能（相互间需要同步元数据）。同时，在节点奔溃时候，要考虑到如何尽快恢复原始数据，如果有底层分布式文件系统的支持，就会比较便利</div>2020-01-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg" width="30px"><span>番茄炒西红柿</span> 👍（3） 💬（0）<div>问一个问题，因为无状态的服务也要通过状态转移到分布式存储系统。所以是否可以认为分布式存储系统也是有状态的服务</div>2019-12-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg" width="30px"><span>Ryoma</span> 👍（3） 💬（3）<div>文中说 有状态的服务：有更高的可用性
不知道这里应该怎么理解，有状态的服务应该很容易单点故障，可用性怎么会好呢</div>2019-12-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/4c/bd/489ee7c1.jpg" width="30px"><span>星空下</span> 👍（3） 💬（2）<div>两阶段提交和一致性算法讲的有点混</div>2019-10-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/d0/f5/dbd664c4.jpg" width="30px"><span>夏书</span> 👍（3） 💬（0）<div>有状态化拿CPA理论来衡量优点牵强，当我以结果为导向，来辨别有无状态。  如果分片设计了，在一定场景上无副作用。 我是否可以理解为是无状态</div>2019-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a2/5e/3871ff79.jpg" width="30px"><span>迷途书童</span> 👍（2） 💬（0）<div>如果能系统的讲一下有状态的服务适合什么样的场景，无状态的服务适合什么样的场景有完美了</div>2020-06-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg" width="30px"><span>知行合一</span> 👍（2） 💬（0）<div>一般都是无状态的服务，即使有些状态也是需要在服务启动或者访问的过程中自动加载，可以视为无状态，这也是依赖于各种分布式存储和中间件的结果。</div>2020-01-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg" width="30px"><span>edisonhuang</span> 👍（2） 💬（0）<div>服务按照状态来分有无状态服务和有状态服务。
无状态服务易于水平扩展，没有副作用，是比较符合函数式编程的理念。但是现实中的真实场景往往是有状态的，因此做到无状态服务就需要把相应状态数据转移到数据服务层来同步，会增大系统的时延和服务同步的复杂性。
相对的是有状态的服务，有状态的服务数据和处理逻辑会保存在同一台机同一个进程，数据加载满足局部性原理，减少了网络调度的消耗，服务响应变快。但也会带来负载难均衡的问题，服务运维扩展也不容易。
</div>2019-07-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg" width="30px"><span>Geek_fb3db2</span> 👍（2） 💬（0）<div>讲了蛮多的无状态和有状态服务优缺点，但是总体来说无状态服务设计非常复杂，感觉需要非常高的系统架构，那么实际使用中，无状态使用多还是有状态的呢</div>2018-12-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg" width="30px"><span>文刂 氵共 超</span> 👍（1） 💬（0）<div>学习笔记  https:&#47;&#47;mubu.com&#47;colla&#47;4ShlioLRIAM</div>2019-12-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cc/45/73a0f7f8.jpg" width="30px"><span>道</span> 👍（1） 💬（0）<div>期待工作流引擎实现细节</div>2018-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/84/04/aceac3b5.jpg" width="30px"><span>流迷的咸菜</span> 👍（1） 💬（0）<div>文中提到，同步有同步的问题，分片也有分片的问题。同步的话主要是数据一致性和效率问题。那么分片的话，请问，主要问题是数据在其他片区上，需要远程获取数据，和对其他片区数据的写问题吗？</div>2018-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg" width="30px"><span>MClink</span> 👍（0） 💬（0）<div>在设计一个内部平台的时候。我们采用的 FE-BFF（nodejs)-GO 的架构方式。在GO中提供的接口都是无状态的，对于需要明确操作用户的，GO提供用户编码参数来识别用户。所有的状态校验都是通过BFF层实现。GO在Redis里面存储登录态。BFF层间接通过GO校验登录态，并转为用户编码调用GO的接口。我想请问大家这种架构是否合理。有没有更好的架构方式。</div>2023-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（0） 💬（0）<div>之前专栏里面提到过 status 和 state 的差别，我觉的比较好的解释是

status =  how are you ? good &#47; bad
state = what are you doing ? resting &#47; working

无状态服务对于扩展和运维有好处。

如果做非分布式的系统，那么是不是有状态服务更合适一些？或者是采用了微服务架构之后，无状态服务更易于开发和维护。

之前看过一个基于 ZFS 分布式文件系统的 SSD 盘阵，通过分块读写的方式，可以达到每秒 24 GB 的速度，感觉也挺厉害。</div>2023-03-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg" width="30px"><span>梅子黄时雨</span> 👍（0） 💬（0）<div>学习了。</div>2022-10-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg" width="30px"><span>方勇(gopher)</span> 👍（0） 💬（0）<div>大部分服务都是无状态的，所以我们依赖的中间件稳定性就要求比较高。</div>2021-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ee/64/55adb692.jpg" width="30px"><span>听风的锈</span> 👍（0） 💬（0）<div>工作中的有状态服务 就是数据只在内存 不做持久化。比如一场斗地主比赛 过程，程序挂了数据丢失再来一场。 本讲的有状态服务 要求数据还是要持久化，分片进行访问。</div>2021-08-19</li><br/>
</ul>