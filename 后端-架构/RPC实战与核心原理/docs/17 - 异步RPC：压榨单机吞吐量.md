你好，我是何小锋。从今天开始，我们就正式进入高级篇了。

在上个篇章，我们学习了RPC框架的基础架构和一系列治理功能，以及一些与集群管理相关的高级功能，如服务发现、健康检查、路由策略、负载均衡、优雅启停机等等。

有了这些知识储备，你就已经对RPC框架有了较为充分的认识。但如果你想要更深入地了解RPC，更好地使用RPC，你就必须从RPC框架的整体性能上去考虑问题了。你得知道如何去提升RPC框架的性能、稳定性、安全性、吞吐量，以及如何在分布式的场景下快速定位问题等等，这些都是我们在高级篇中重点要讲解的内容。难度有一定提升，希望你能坚持学习呀！

那么今天我们就先来讲讲，RPC框架是如何压榨单机吞吐量的。

## 如何提升单机吞吐量？

在我运营RPC的过程中，“如何提升吞吐量”是我与业务团队经常讨论的问题。

记得之前业务团队反馈过这样一个问题：我们的TPS始终上不去，压测的时候CPU压到40%～50%就再也压不上去了，TPS也不会提高，问我们这里有没有什么解决方案可以提升业务的吞吐量？

之后我是看了下他们服务的业务逻辑，发现他们的业务逻辑在执行较为耗时的业务逻辑的基础上，又同步调用了好几个其它的服务。由于这几个服务的耗时较长，才导致这个服务的业务逻辑耗时也长，CPU大部分的时间都在等待，并没有得到充分地利用，因此CPU的利用率和服务的吞吐量当然上不去了。
<div><strong>精选留言（25）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg" width="30px"><span>楼下小黑哥</span> 👍（48） 💬（3）<div>RPC 这里远程方法调用方式，大致可以分成四种方式：

- sync 默认方式，但是这只是『方法』内部同步，实际上 RPC 框架内部还是异步处理。
- future 方式，RPC 消费者得到 future，自行决定何时获取返回结果
- callback 方式，RPC 调用端不需要同步处理响应结果，可以直接返回。最后返回结果将会在回调线程异步处理
- oneway 方式，调用端发送请求之后不需要接受响应

其中 Dubbo 2.7 之后的版本，使用 CompletableFuture 提升异步的处理的能力，支持以上四种方式。


</div>2020-04-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/b5/a8/427a7b6d.jpg" width="30px"><span>石佩</span> 👍（4） 💬（3）<div>使用异步的时候返回的速度变快了，但是后台所需要的线程数会变少么？，线程池我理解应该是该被打满还是被打满</div>2020-03-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/10/75/ff76024c.jpg" width="30px"><span>那个谁</span> 👍（1） 💬（2）<div>rpc框架是作用于调用方服务方两端？实际上是在服务端有service, 客户端有client？然后客户端发起异步rpc调用，是说客户端本身不等待返回继续处理自身业务，而对服务端来讲，并不知道客户端是不是异步，然后服务端也是正常处理自己的业务逻辑。如果也是异步，那返回的结果是在服务端框架，然后服务端的rpc框架等完成后，返回给客户端？网络传输是不区分异步不异步，还是要等服务端执行完成，拿到正常结果后序列化到网络返回给调用方，是这么理解吗？</div>2020-03-30</li><br/><li><img src="" width="30px"><span>嘻嘻</span> 👍（0） 💬（1）<div>服务端异步感觉意义不大，拆分再多的线程池，最终要打满的还是会有一个线程池被打满，除非做线程池隔离。不知道理解对不对？</div>2020-04-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/aa/5e/9be28107.jpg" width="30px"><span>Josey</span> 👍（0） 💬（4）<div>老师你上面说到的如果“业务线程池的线程数配置到 200”，线程池被打满了，如果单存增加线程数量有用吗？200个线程都处理不了的情况下，配置到300或者500不是只会增加cpu上下文切换的时间吗？</div>2020-03-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/b4/62/771bed4b.jpg" width="30px"><span>vuiolpg</span> 👍（24） 💬（1）<div>我觉得作者有一部分的描述会有点误导新人，就是CPU 大部分的时间都在等待，并没有得到充分地利用，因此 CPU 的利用率和服务的吞吐量当然上不去了这段话，其实线程处于等待状态时是不占用cpu资源的，所以更准确的描述应该是浪费了宝贵的线程资源，大量线程处于等待状态，可能（不是一定）导致cpu利用率低。</div>2020-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4c/8a/d75626ec.jpg" width="30px"><span>landon30</span> 👍（13） 💬（0）<div>异步的最佳解决方案是coroutine</div>2020-05-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg" width="30px"><span>JDY</span> 👍（5） 💬（1）<div>老师说的是java版的rpc设计，我现在也知道了最好要用异步的方式来进行调用，但是c++的怎么实现呢？</div>2020-04-15</li><br/><li><img src="" width="30px"><span>Geek_09d497</span> 👍（4） 💬（2）<div>异步虽然能提高性能，但是遇到有的业务有先后顺序，如果所有请求异步，那如何保证时序呢</div>2020-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/40/da/304a566e.jpg" width="30px"><span>rainj2013</span> 👍（4） 💬（2）<div>我们直接用mq来做的通信，实现纯异步的rpc</div>2020-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg" width="30px"><span>高源</span> 👍（4） 💬（1）<div>新的知识点，学习了老师讲的非常好，如果举个小的demo就更好了，主要调试程序理解知识点，点赞</div>2020-03-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8a/e3/11fd3b72.jpg" width="30px"><span>胡杨</span> 👍（2） 💬（0）<div>RPC的服务提供方为了提高吞吐量，采用异步处理业务逻辑，这个我能理解。
文中说自定义线程池去异步处理业务逻辑，如果业务逻辑处理很慢，会把线程池打满，这个我也能理解。
但作者的意思是，为了让业务线程池尽快释放，可以采用CompletableFuture去异步处理，那业务逻辑慢的时候,CompletableFuture的线程池也是会被打满啊。用CompletableFuture异步处理，与我们自己用线程池去处理，我的理解是，用CompletableFuture可以降低一些异步编程的复杂度，但在性能效果方面有区别吗？</div>2021-11-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/14/08/ac323169.jpg" width="30px"><span>Forsaken</span> 👍（2） 💬（0）<div>利用任务编排来提高性能</div>2021-06-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg" width="30px"><span>莫珣</span> 👍（1） 💬（0）<div>我一直不太明白异步调用的代码要怎么写。比如文章中举的例子，调用端逻辑需要通过几个RPC才能实现自己的业务逻辑，但第一个RPC没拿到响应数据，就没办法执行后续的业务代码，那这样不就得同步调用了。</div>2022-09-15</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep66fdwo3ebSicKjf0iacAx4C2tZOthDDD4bSJqib1iauFBK6EoMSWUBp4UbbN2BQlib7mFR3hQD6MUwew/132" width="30px"><span>chai</span> 👍（1） 💬（0）<div>go语言支持异步调用比较简单，新启动一个goroutine就行了</div>2021-04-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fe/f9/f3e3fc17.jpg" width="30px"><span>海阔天空</span> 👍（0） 💬（0）<div>一个java程序员，在学习了go之后，感觉之前修炼的异步技能，都白瞎了，哈哈</div>2023-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6d/8a/0f53c600.jpg" width="30px"><span>Palmer</span> 👍（0） 💬（0）<div>老师您好！我之前在学习gRPC时了解到Streaming功能，就是回调方式的一种实现，但发现服务端哪怕单线程也无法保证请求的顺序（Netty IO模型造成）。比如调用端一次发送ABC，服务端可能会处理BAC。
请问老师，这种业务上有顺序要求的场景，如何在保证顺序处理的前提下使用异步来提升性能呢？谢谢！</div>2022-08-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/e1/5a/d2081f1c.jpg" width="30px"><span>徐敏</span> 👍（0） 💬（0）<div>用future不用协程，直接不会写代码。</div>2022-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/86/dc/be1b17d8.jpg" width="30px"><span>Geek_648c53</span> 👍（0） 💬（0）<div>有个疑惑，如果调用方需要多次调用服务，而且服务的多次调用有逻辑顺序的要求，且相互依赖，这样就导致即使异步处理，调用者也需要等待服务处理完毕才可以，有这样的需求的话，异步的用途也起不到太大的作用（不知道我理解的对不对）</div>2022-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg" width="30px"><span>核桃</span> 👍（0） 💬（0）<div>全部使用异步进行调用，这里也会带来一个隐藏的问题，上下文切换。当服务请求很多的时候，虽然异步可以接受更多的请求。但是也意味着会有大量的上下文切换，这个问题也是致命的。因此一定要区分，哪些业务是可以异步，哪些业务是不需要异步的。否则得不偿失了。</div>2022-02-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg" width="30px"><span>姑射仙人</span> 👍（0） 💬（0）<div>老师，“调用端在收到服务端发送过来的响应之后”，在异步请求下，谁来发送这个响应？业务逻辑完成之后再调用这个 CompletableFuture 对象的 complete 方法，完成异步通知。这个complete 方法会触发响应吗？触发响应是要发起请求到调用端的吧。</div>2021-05-19</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132" width="30px"><span>dog_brother</span> 👍（0） 💬（1）<div>c++的异步库，大家有啥推荐的么？</div>2021-04-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg" width="30px"><span>惘 闻</span> 👍（0） 💬（0）<div>最重要的是因为CompletableFuture比Future多了complete回调方法对吗?这样才可以实现异步回调的响应</div>2021-02-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg" width="30px"><span>凯文小猪</span> 👍（0） 💬（0）<div>结果注入future这句话不是很懂？有具体的例子或者说明吗</div>2020-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（0） 💬（0）<div>学习曲线确实陡峭了，小结一下：
压榨单机吞吐量的秘诀是异步化，针对RPC框架异步化分成调用端异步化和服务端异步化。
调用端本身就是异步化的，毕竟通过网络发生完请求消息，后面就是小黑盒了，此时可以选择不让RPC调用端框架拿服务端的响应消息，让调用端应用来选择什么时候拿。这样调用端可以发送更多的请求消息，提高吞吐量。
服务端异步化，核心在于重分利用单机服务端的资源，避免CPU闲置，业务处理线程处于等待状态。
不过😁具体怎么玩，必须玩一下，否则道理讲出来老农民都懂但是具体咋实现，是一问题？</div>2020-05-16</li><br/>
</ul>