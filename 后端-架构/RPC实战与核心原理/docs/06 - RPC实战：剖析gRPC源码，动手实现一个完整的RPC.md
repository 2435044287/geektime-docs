你好，我是何小锋。上一讲我分享了动态代理，其作用总结起来就是一句话：“我们可以通过动态代理技术，屏蔽 RPC 调用的细节，从而让使用者能够面向接口编程。”

到今天为止，我们已经把 RPC 通信过程中要用到的所有基础知识都讲了一遍，但这些内容多属于理论。**这一讲我们就来实战一下，看看具体落实到代码上，我们应该怎么实现一个 RPC 框架？**

为了能让咱们快速达成共识，我选择剖析 gRPC 源码（源码地址：[https://github.com/grpc/grpc-java](https://github.com/grpc/grpc-java)）。通过分析 gRPC 的通信过程，我们可以清楚地知道在 gRPC 里面这些知识点是怎么落地到具体代码上的。

gRPC 是由 Google 开发并且开源的一款高性能、跨语言的 RPC 框架，当前支持 C、Java 和 Go 等语言，当前 Java 版本最新 Release 版为 1.27.0。gRPC 有很多特点，比如跨语言，通信协议是基于标准的 HTTP/2 设计的，序列化支持 PB（Protocol Buffer）和 JSON，整个调用示例如下图所示：

![](https://static001.geekbang.org/resource/image/86/0d/8671942cd89feea3a2544d3530da450d.jpg?wh=3183%2A1769 "gRPC调用示例图")

如果你想快速地了解一个全新框架的工作原理，我个人认为最快的方式就是从使用示例开始，所以现在我们就以最简单的 HelloWord 为例开始了解。

在这个例子里面，我们会定义一个 say 方法，调用方通过 gRPC 调用服务提供方，然后服务提供方会返回一个字符串给调用方。
<div><strong>精选留言（21）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/0f/bf/ee93c4cf.jpg" width="30px"><span>雨霖铃声声慢</span> 👍（68） 💬（4）<div>InputStream封装了底层传输的字节缓冲区实现，它通常是一组通过指针连接起来的内存块的集合，这些内存块由网络的零拷贝获取的。由于不能保证能够从内存块中获取一个byte[]，我们不能传递一个简单的byte[]或byte[][]，并且可能需要一个目标byte[]来从缓冲区中获取数据。
另外byte[]的缺点是需要从缓冲区中复制一个大的、连续的数据，而实际上没有什么方法可以使它执行得更好。当使用压缩时，我们也不知道消息未压缩的长度，它是动态解压缩的。</div>2020-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/04/51/da465a93.jpg" width="30px"><span>超威丶</span> 👍（9） 💬（1）<div>难道http2的核心实现不就是基于流实现？</div>2020-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg" width="30px"><span>忆水寒</span> 👍（7） 💬（1）<div>老师，有个疑问。按道理客户端发起一次rpc调用，通过序列化、网络传输、服务端处理再响应，这期间有时间差的。上面客户端代码除非是阻塞的，否则不可能立马得到结果吧。</div>2020-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg" width="30px"><span>飞翔</span> 👍（3） 💬（5）<div>老师 有说法是内部调用用rpc 外部用http 这是为什么呀</div>2020-03-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/48/f3/65c7e3ef.jpg" width="30px"><span>cricket1981</span> 👍（2） 💬（1）<div>以流的方式处理请求数据，适合请求数据数据量大情况。好比Sax和Dom区别。</div>2020-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（1） 💬（1）<div>我们讲到，在 gRPC 调用的时候，我们有一个关键步骤就是把对象转成可传输的二进制，但是在 gRPC 里面，我们并没有直接转成二进制数组，而是返回一个 InputStream，你知道这样做的好处是什么吗？

这个不知道哎😂
猜测是为性能故，看评论区的讨论，猜测是正确的，不过细节还是不太清楚，需要后补一下。

Inputstream——避免二次拷贝（序列化＋encode）——更高的性能。</div>2020-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg" width="30px"><span>密码123456</span> 👍（1） 💬（1）<div>为什么能避免二次拷贝？</div>2020-04-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg" width="30px"><span>eason2017</span> 👍（1） 💬（2）<div>老师好，可以把 为客户端和服务器端生成消息对象和 RPC 基础代码 的命令提供出来吗？谢谢。</div>2020-03-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg" width="30px"><span>蚂蚁内推+v</span> 👍（0） 💬（1）<div>这样跟HTTP2有什么区别呢</div>2020-03-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/89/04/c1474869.jpg" width="30px"><span>tulip</span> 👍（28） 💬（2）<div>老师可以出一期go 的嘛</div>2020-03-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg" width="30px"><span>新世界</span> 👍（15） 💬（0）<div>老师能否把代码提交到github上，我们可以下载下来跑一跑，看一看</div>2020-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg" width="30px"><span>楼下小黑哥</span> 👍（10） 💬（1）<div>网上搜索资料查到，分享一下：
A stream also has the advantage that you don&#39;t have to have all bytes in memory at the same time, which is convenient if the size of the data is large and can easily be handled in small chunks.</div>2020-03-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg" width="30px"><span>核桃</span> 👍（6） 💬（0）<div>这里说一下对inpustream的理解。首先要理解，当网卡接收到数据之后是存放到缓冲区的，这里其实已经分配过空间了。而上层应用想拿到这些数据，可以再次分配一段空间，然后把数据从缓冲区复制到这里，但是这样就多了一次复制了。而为了解决这个问题，inputstream本质上就是一段指针，指向了缓冲区的数据，那样可以直接使用这段地址的数据。不管用什么语言实现，本质思想都是类似的。</div>2022-02-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg" width="30px"><span>四喜</span> 👍（6） 💬（0）<div>分享一下Python的Tutorial：

gRPC Basics - Python：https:&#47;&#47;grpc.io&#47;docs&#47;tutorials&#47;basic&#47;python&#47;

gRPC Python Quick Start：https:&#47;&#47;grpc.io&#47;docs&#47;quickstart&#47;python&#47;</div>2020-03-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/24/ba/99/da85915f.jpg" width="30px"><span>Hzº</span> 👍（3） 💬（0）<div>感觉对Java不熟悉的同学，不太友好</div>2022-05-27</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5hhywBujyCPMYgZNQzGTrWw00flbwD07Fg8OTLnJPz9fJtO0IEYUZ7cjVpgNArPRZ8ibVqm0cSWPA/132" width="30px"><span>Geek_8b32e2</span> 👍（1） 💬（0）<div>这不就是grpc-java的helloword吗，源码剖析在哪里？这个和标题不符合啊
</div>2024-06-10</li><br/><li><img src="" width="30px"><span>Geek_757cbc</span> 👍（0） 💬（0）<div>static class HelloServiceImpl 报错，去掉static调试成功</div>2022-10-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/7a/22/45307c91.jpg" width="30px"><span>墨白</span> 👍（0） 💬（0）<div>老师httpclient底层也是基于socket封装，为什么没有基于FileChannelimp零拷贝的实现</div>2021-10-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0c/ad/d1ab1995.jpg" width="30px"><span>Di Yu</span> 👍（0） 💬（1）<div>gRPC看起来没有用到动态代理吗？在调用端代码里边我们手动的建立了channel，然后手动的call blockingStub.say(request)。这是为了更好的性能吧？如果要用动态代理，那我们会把建立channel等事情放到代理类里边，这样调用端代码就简化一些了，这样理解对吗？</div>2020-08-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg" width="30px"><span>Jackey</span> 👍（0） 💬（0）<div>精彩</div>2020-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg" width="30px"><span>高源</span> 👍（0） 💬（1）<div>我猜的是网络字节序问题吧😊</div>2020-03-02</li><br/>
</ul>