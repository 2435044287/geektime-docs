在专栏的第三个模块，我们学习了Tomcat连接器组件的设计，**其中最重要的是各种I/O模型及其实现**。而I/O模型跟操作系统密切相关，要彻底理解这些原理，我们首先需要弄清楚什么是进程和线程，什么是虚拟内存和物理内存，什么是用户空间和内核空间，线程的阻塞到底意味着什么，内核又是如何唤醒用户线程的等等这些问题。可以说掌握这些底层的知识，对于你学习Tomcat和Jetty的原理，乃至其他各种后端架构都至关重要，这些知识可以说是后端开发的“基石”。

在专栏的留言中我也发现很多同学反馈对这些底层的概念很模糊，那今天作为模块的答疑篇，我就来跟你聊聊这些问题。

## 进程和线程

我们先从Linux的进程谈起，操作系统要运行一个可执行程序，首先要将程序文件加载到内存，然后CPU去读取和执行程序指令，而一个进程就是“一次程序的运行过程”，内核会给每一个进程创建一个名为`task_struct`的数据结构，而内核也是一段程序，系统启动时就被加载到内存中了。

进程在运行过程中要访问内存，而物理内存是有限的，比如16GB，那怎么把有限的内存分给不同的进程使用呢？跟CPU的分时共享一样，内存也是共享的，Linux给每个进程虚拟出一块很大的地址空间，比如32位机器上进程的虚拟内存地址空间是4GB，从0x00000000到0xFFFFFFFF。但这4GB并不是真实的物理内存，而是进程访问到了某个虚拟地址，如果这个地址还没有对应的物理内存页，就会产生缺页中断，分配物理内存，MMU（内存管理单元）会将虚拟地址与物理内存页的映射关系保存在页表中，再次访问这个虚拟地址，就能找到相应的物理内存页。每个进程的这4GB虚拟地址空间分布如下图所示：
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg" width="30px"><span>帽子丨影</span> 👍（42） 💬（1）<div>老师好，既然用户态运行时也会占用cpu，内核态又可以访问整个虚拟空间，为什么不让cpu一直处在内核态呢，这样就没有切换带来损耗了</div>2019-09-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e2/86/90041355.jpg" width="30px"><span>一塌糊涂</span> 👍（32） 💬（3）<div>老师问个问题，用户态切换到内核态，使用的是虚拟空间内核地址？这时用户线程会挂起执行内核线程吗？这是两个线程吗？</div>2019-07-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/b5/d4/e58e39f0.jpg" width="30px"><span>Geek_0quh3e</span> 👍（15） 💬（1）<div>虚拟内存是一个联系的地址空间，该地址空间由不一定连续的物理内存组成。  这样理解对吗？</div>2019-07-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" width="30px"><span>Liam</span> 👍（15） 💬（1）<div>如果是通过mmap读数据，流程是怎样的呢？

1 如果没有数据，是否会阻塞？
2 不需要拷贝数据？意思是用户进程可以直接读mmap，不需要拷贝到堆吗？
</div>2019-06-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg" width="30px"><span>nightmare</span> 👍（12） 💬（1）<div>老师今天讲了线程和进程，进程和线程都是统一在内核空间建立task_truct，根据代码是否有系统调用在用户态和内核态来做上下文切换，然后还讲了read的系统调用过程以及进程的虚拟内存和物理内存的机制，有一点没明白，是每个进程都会有一个虚拟内核空间吗？然后进程的虚拟内核空间映射到系统管理的内核空间上？</div>2019-06-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg" width="30px"><span>妥协</span> 👍（10） 💬（1）<div>之前有讲到过，jvm用到的内存空间，在本文中介绍的进程的地址空间划分中，是属于那一部分？</div>2019-07-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg" width="30px"><span>长脖子树</span> 👍（9） 💬（1）<div>看了作者的文章又去看了 copy-on-write 和 MappedByteBuffer 了解又加深了一层 哈哈</div>2019-08-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg" width="30px"><span>飞翔</span> 👍（8） 💬（2）<div>用户态和用户空间是啥关系？</div>2019-06-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/11/6b/8034959a.jpg" width="30px"><span>迎风劲草</span> 👍（7） 💬（1）<div>老师，task_struct 具体是什么结构，都存储了什么？</div>2019-07-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e8/4b/57fa0e34.jpg" width="30px"><span>brianway</span> 👍（6） 💬（1）<div>“线程有自己的task_struct结构体和运行栈区，但是线程的其他资源都是跟父进程共用”，这句话怎么理解。线程的task_struct结构体和运行栈区在图中哪个部分？

是从进程的内核空间里面分配出来的，还是用户空间里分配出来的？具体哪个部分的内存？
</div>2019-07-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg" width="30px"><span>梁中华</span> 👍（5） 💬（1）<div>文中混合使用“可运行队列”和“运行队列”，这两者应该是同一个队列吧。另外关于线程唤醒部分我有一个理解，老师看看对否：当前线程因IO等待而进入&quot;阻塞状态(Blocked)&quot;,同时进入线程进入等待队列。让IO操作ready后，内核唤醒等待中的线程，线程状态变成&quot;可运行状态(Runnable)&quot;,同时该线程进入可运行队列，等待CPU调度后进入运行状态(Running)。</div>2019-07-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（4） 💬（1）<div>感谢老师，万分感谢。上次有个问题我不明白，老师还帮我查阅源码确认了。李老师，还有http那个老师是最最负责的真的万分感谢。
向老师，我要把计算机组成原理和操作系统自己看一遍看不懂就看两遍。</div>2019-06-29</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/iaV35C64GbQ9Zaos6U3r9zFJPZ7hcXQqlQbkOm8PxmkktsnJicJaDfKNPRsqAnYP4qqaUMHX8x95CrueszjjEW4g/132" width="30px"><span>xiaolin777</span> 👍（3） 💬（1）<div>老师,您说的task_struct是指进程控制块吗？（刚才还没打完就点了保存，以为是保存草稿，没想到直接提交了，后台能删除吗）</div>2019-08-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg" width="30px"><span>学无涯</span> 👍（3） 💬（1）<div>1、文中开始说：“task_struct中保存了打开的文件、创建的socket以及CPU运行的上下文&quot;。后面又说&quot;线程有自己的task_struct“。那最后说的“和父进程共用的资源：创建的socket。打开的文件等”这些是怎么共享呀，socket和打开的文件都是在task_struct中保存的，线程有自己独立的task_struct，还需要共享吗？
2、task_struct为什么不用数组呀，数组不是更节省空间吗，而且随机访问这个特性也支持CPU随机调度（猜的，从多线程的不确定性感觉应该是随机调度），是考虑到这个数组有可能很大和频繁扩容的问题才采用双向链表吗？
以上问题，请老师指点一下！</div>2019-08-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg" width="30px"><span>蚂蚁内推+v</span> 👍（3） 💬（1）<div>唤醒时，内核调用的回调函数是指硬件中断程序么</div>2019-07-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg" width="30px"><span>妥协</span> 👍（3） 💬（1）<div>您是不是指的数据区和堆区？数据区和栈区不是连续的呀</div>2019-07-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg" width="30px"><span>一道阳光</span> 👍（3） 💬（1）<div>老师，每节课后的思考题什么时侯也答疑下</div>2019-06-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg" width="30px"><span>一道阳光</span> 👍（2） 💬（1）<div>老师，虚拟内存空间中的本地内存呢？之前提到过：本地内存作为中转。</div>2019-06-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg" width="30px"><span>yang</span> 👍（1） 💬（1）<div>老师 从来没人跟我说过基础要看啥书 我都是东一榔头 西一棒槌 想求老师告知一两本基石的书。 我在网络专栏也提了同样的问题，希望你们有一位老师能回答我的问题。如果重复了我就去重，把要看书单压到枕头底下。 (c方面只考过c++二级) </div>2019-08-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg" width="30px"><span>东方奇骥</span> 👍（13） 💬（0）<div>答疑干货还挺多的，操作系统一直是自己的弱项，最近也在学习，然后发现极客时间专栏里牛逼的老师操作系统基础都很好。</div>2019-06-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg" width="30px"><span>靠人品去赢</span> 👍（4） 💬（0）<div>进程和线程：进程的本质就是“一个程序运行的过程”，而线程可以看做是一个小进程因为他也有进程的task_struct这些东西，但是他是跟父进程公用资源的。
阻塞的本质：就是移出运行队列到等待队列，条件好了内核通知把数据写进去用户态，就又进入到运行队列等待CPU时间片。
老师这本质也归纳的太好了吧。</div>2019-10-16</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/fy6KTCIk6JPGdOYbvsXJ4h1zq8a6P6sHiau0t2hBxxZfSeE2ymJmWsnb7YzxUO3byr1n30UoYD2XrXDwlrQa6lQ/132" width="30px"><span>Ericens</span> 👍（2） 💬（2）<div>李老师，请教个关于协程与线程的疑问。比如，a协程调用socket. read(),此时数据没有准备好，则继续调度b协程。

把协程换成线程，上面这个过程哪个更加轻量？协程还是线程？
我理解这个过程涉及的过程如下，都一样。
1.都有系统调用read()，从用户态切换到了内核态，
2.都有上下文切换。(不同协程的寄存器，和不同线程的寄存器)
3. 都要执行任务调度。协程调度或者线程调度。

那协程到底轻量在哪？</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e8/58/ecb493dc.jpg" width="30px"><span>ming</span> 👍（1） 💬（0）<div>老师您好，
内核将数据从内核空间拷贝到用户空间的时候，线程已经是运行状态了了吧？并不是拷贝到用户空间后才从阻塞到运行? 不知道我说错没</div>2021-02-23</li><br/><li><img src="" width="30px"><span>Geek_00271d</span> 👍（0） 💬（0）<div>既然用户态下无法访问内核空间，是如何实现零拷贝的呢？</div>2022-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg" width="30px"><span>良辰美景</span> 👍（0） 💬（0）<div>进程和线程在内核中都被抽象为Task来管理，每个Task都有自己的TaskStruct
同一进程下的线程父TaskId相同，共享进程的fd、context等信息。</div>2021-10-24</li><br/><li><img src="" width="30px"><span>Geek_5d1643</span> 👍（0） 💬（0）<div>(可)运行队列是全局队列，等待队列感觉不是全局队列，这里老师最好能引出 wait_queue_header ，这个 header 散布到很多的内核数据结构里，所以，我认为这个不是全局队列，不知道老师，怎么看呢，能多介绍下吗？</div>2021-09-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/ff/7e/1321bcb9.jpg" width="30px"><span>慧暐</span> 👍（0） 💬（0）<div>这一篇酣畅淋漓</div>2021-03-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ae/9d/791d0f5e.jpg" width="30px"><span>南秋同学</span> 👍（0） 💬（0）<div>老师讲得非常的易懂，看了Socket Read过程，个人感觉Java的AQS是不是参考了这个过程，非常类似。</div>2021-01-20</li><br/><li><img src="" width="30px"><span>Geek5350</span> 👍（0） 💬（0）<div>用户态的虚拟内存空间也是多个进程共享的吧？</div>2020-11-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/20/14/89fbdcb7.jpg" width="30px"><span>M.N.G.</span> 👍（0） 💬（0）<div>请问cpu由用户态切换到内核态算是一次上下文切换吗</div>2020-11-03</li><br/>
</ul>