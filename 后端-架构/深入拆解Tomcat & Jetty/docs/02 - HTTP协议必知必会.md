在开始学习Web容器之前，我想先问你一个问题：HTTP和HTML有什么区别？

为什么我会问这个问题？你可以把它当作一个入门测试，检测一下自己的对HTTP协议的理解。因为Tomcat和Jetty本身就是一个“HTTP服务器 + Servlet容器”，如果你想深入理解Tomcat和Jetty的工作原理，我认为理解HTTP协议的工作原理是学习的基础。

如果你对这个问题还稍有迟疑，那么请跟我一起来回顾一下HTTP协议吧。

## HTTP的本质

HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP/IP协议来传递数据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端和服务器之间的通信格式。

下面我通过一个例子来告诉你HTTP的本质是什么。

假如浏览器需要从远程HTTP服务器获取一个HTML文本，在这个过程中，浏览器实际上要做两件事情。

- 与服务器建立Socket连接。
- 生成**请求数据**并通过Socket发送出去。

第一步比较容易理解，浏览器从地址栏获取用户输入的网址和端口，去连接远端的服务器，这样就能通信了。

我们重点来看第二步，这个请求数据到底长什么样呢？都请求些什么内容呢？或者换句话说，浏览器需要告诉服务端什么信息呢？
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg" width="30px"><span>吃饭饭</span> 👍（93） 💬（7）<div>我一直不太理解什么是无状态，restful经常听说是无状态的，是一个概念吗？求解答</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg" width="30px"><span>阿斯蒂芬</span> 👍（188） 💬（5）<div>Http的无状态我理解是指不同请求间协议内容无相关性，即本次请求与上次请求没有内容的依赖关系，本次响应也只针对本次请求的数据，至于服务器应用程序为用户保存的状态是属于应用层，与协议是无关的。
keep-alive表示tcp的连接可以复用，指的是利用已有的传输通道进行http协议内容的传输，省去创建&#47;关闭连接的开销达到提升性能的效果。应用程序其实一般不关心这次Http请求的TCP传输细节，只关心Http协议的内容，因此只要复用tcp连接时做好必要的数据重置，是不算有状态的。</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg" width="30px"><span>而立斋</span> 👍（75） 💬（3）<div>无状态的协议，使用cookie、session等机制实现有状态的的web。
无状态是指协议对于事务处理没有记忆功能，对同一个url请求没有上下文关系，每次的请求都是独立的，服务器中没有保存客户端的状态。HTTP协议长连接、短连接实质上是TCP协议的长连接、短连接。长连接省去了较多的TCP建立、关闭操作，减少了浪费，节约时间；短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。
那为什么HTTP协议会被设计成无状态的呢？http最初设计成无状态的是因为只是用来浏览静态文件的，无状态协议已经足够，也没什么其他的负担。随着web的发展，它需要变得有状态，但是不是就要修改http协议使之有状态呢？是不需要的。因为我们经常长时间逗留在某一个网页，然后才进入到另一个网页，如果在这两个页面之间维持状态，代价是很高的。其次，历史让http无状态，但是现在对http提出了新的要求，按照软件领域的通常做法是，保留历史经验，在http协议上再加上一层实现我们的目的。所以引入了cookie、session等机制来实现这种有状态的连接。
</div>2019-05-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg" width="30px"><span>yang</span> 👍（68） 💬（3）<div>http1.0: 买一个信封只能传送一个来回的信。
http1.1: keep–alive:买一个信封可以重复使用，但前提是得等到服务端把这个信封送回来。

</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d1/fd/1cdfef42.jpg" width="30px"><span>刘为红</span> 👍（62） 💬（5）<div>sessionid是服务端生成的，服务端通过set-cookie放在http的响应头里，然后浏览器写到cookie里，后续每次请求就会自动带上来了，这点感觉讲得不是很清楚</div>2019-05-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/4c/5c/25850d97.jpg" width="30px"><span>微信小助手</span> 👍（40） 💬（3）<div>HTTP的无状态性与共用TCP连接发送多个请求之间没有冲突，
这些请求之间相对独立，唯一的关系可能只有发送的先后顺序关系。
此外，HTTP&#47;1.1中的长连接依然没有解决 head of line blocking 的问题，
后面的连接必须等待前面的返回了才能够发送，
这个问题直到HTTP&#47;2.0采取二进制分帧编码方式才彻底解决。</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e6/eb/708c2788.jpg" width="30px"><span>逍遥哥哥</span> 👍（39） 💬（4）<div>老师，您好，现在的web容器都支持将session存储在第三方中间件（如redis）中，为什么很多公司喜欢绕过容器，直接在应用中将会话数据存入中间件中？</div>2019-05-14</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/IgjIXs9jjpODTPaOLrms0XOhJ8pxMcaZgtgBrPG6deqsKXv1sPIqkg0faL6X0rtFicJn5Wf7QXTickjYWpmF0V8A/132" width="30px"><span>Geek_28b75e</span> 👍（34） 💬（2）<div>老师，我们经常说的cookie跨域问题中，跨域是什么概念呢</div>2019-05-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg" width="30px"><span>今夜秋风和</span> 👍（18） 💬（1）<div>服务端怎么检测这个tcp链接什么时候可以销毁释放？如果一个连接里面处理一个长事物，其他的请求会不会排队等待</div>2019-05-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/85/3b/cfdc8bf2.jpg" width="30px"><span>Royal</span> 👍（18） 💬（2）<div>您好！上面提到的引入session是因为cookie存在客户端，有安全隐患；但是session id也是通过cookie由客户端发送到服务端，同样有安全隐患啊？</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f5/c4/f2d7ce76.jpg" width="30px"><span>有所思</span> 👍（17） 💬（2）<div>用token机制呢</div>2019-08-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg" width="30px"><span>八百</span> 👍（8） 💬（1）<div>老师我有二个问题
1.如果没请求中没有jsessionid ,每次发起http请求是否都会生成session，如果每次请求都生成session，那么是不是可以作为一个攻击的手段啊，让服务器存在大量session，导致oom
2.如果我从别人的浏览器中拿到jsessionid，把它放在我自己的请求头中，是不是在服务端对应同一个session，那是不是就可以窃取人家信息了。。</div>2019-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg" width="30px"><span>Joker</span> 👍（6） 💬（1）<div>老师，我这样进行比喻您看看合不合适，原来的http老师，我这样进行比喻您看看合不合适。原来的http&#47;1.0的时期，如果把每次发送http数据包都看成一次送信的过程的话，那么就是每次发送都会新叫一个送信员（也就是新建一个TCP连接）。
http&#47;1.1的长链接就相当于给了你和服务器和客户端有了专属的随时待命的送信员，你就免去了以前每次都要寻找送信员的过程。
而http 的无状态我认为就是代表：每次寄信都是用的新的信封。额，这个和评论区上面的那个同学的观点有些差异，还请老师详细说说，谢谢了。
像cookie这些信息就像在信封表面的那些发信人的地址这些信息。
虽然设置长连接开启是在应用层的http协议，但是真正起作用的是在传输层的TCP协议。</div>2019-05-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ba/33/2b562c9b.jpg" width="30px"><span>五先生</span> 👍（5） 💬（1）<div>keepalive建立的通道：是基于什么来建立的呢？也就是什么情况下会是两个通道？一次会话吗？</div>2019-05-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/17/2b/e0e6722f.jpg" width="30px"><span>on the way</span> 👍（5） 💬（1）<div>那么 Session 是怎么和请求对应起来的呢？答案是通过Cookie，那cookie被禁用了怎么办</div>2019-05-20</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqamOZrh0vajowVuEXcS8RWTvgg75fE56ibNnV8iaIOMib6olHvoML6F7YzHRaba6swQHq0P5Hk3Wbicw/132" width="30px"><span>Geek_9b24cd</span> 👍（5） 💬（2）<div>老师你好，我在Java中用HttpRequest向其他服务器发送http请求时为了节约创建连接的开销加入了长链接，然后请求就一直超时，关闭长链接之后就能正常调用了，可能是什么原因呢？</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/5b/65/c3ea6630.jpg" width="30px"><span>暮色听雨声</span> 👍（5） 💬（2）<div>HTTP 的特点是无状态的，多个请求之间是没有关系的，这是不矛盾了么？老师我对这句话不理解呀！ 怎么就矛盾了呀。多个HTTP请求之间本来就没有关系呀，关系跟状态怎么就会矛盾呢？</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg" width="30px"><span>行者</span> 👍（4） 💬（1）<div>老师，之后会讲到HTTP 2.0吗？</div>2019-06-02</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132" width="30px"><span>Geek_ebda96</span> 👍（4） 💬（1）<div>接着 Tomcat 把这个 Request 对象交给 Web 应用去处理，处理完后得到一个 Response 对象，Tomcat 会把这个 Response 对象转成 HTTP 格式的响应数据并发送给浏览器。

老师tomact是如何与web应用建立关系的，serverlet么，tomact本身会去找实现serverlet的方法，然后再找到对应的处理handler？</div>2019-05-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/ac/15/935acedb.jpg" width="30px"><span>iusugar</span> 👍（3） 💬（1）<div>老师，您好，在HTTP的本质那一块，您说HTTP协议是浏览器和服务器之间通信的协议，我个人觉得服务器和服务器之间通信是不是也可以用HTTP？移动端和服务端通信也可以用HTTP？ 个人愚见，希望老师给我解惑。谢谢。</div>2019-07-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c2/cc/ca22bb7c.jpg" width="30px"><span>蓝士钦</span> 👍（3） 💬（1）<div>HTTP&#47;1.1中，响应头加了Connection:keep-alive。如果有很多个客户端都保持这样的TCP长连接，这样保持长连接会耗尽服务器资源吗？</div>2019-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4f/a7/f7124e0f.jpg" width="30px"><span>李坤</span> 👍（3） 💬（1）<div>我看文中讲到http协议不涉及数据包传输。但是下面讲到会把请求包装成http格式的数据包传输，怎么理解呢？</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/19/73/f0bca514.jpg" width="30px"><span>肖长路</span> 👍（3） 💬（1）<div>还有就是，个人理解，不知道对不对！求教了！所谓的无状态就是在每次寄信回信，都没有在信封上标明邮寄人的信息标识，所以，对于服务器来说，每次请求都会看做是一封新的信件！但是，因为实际应用中，有时又必须实现每次请求区分出是否是同一人邮寄的！因为信封人家已经做好了，不容许你更改了，所以，只能在信的内容上来实现无状态变成可区分状态！也就出现了，cookie，session，而讨论区里面，说到的REST风格等等，其实都是在这个信的内容上做文章，信封永远还是那个信封，不知道是不是这个意思！</div>2019-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e7/4a/4dfb565a.jpg" width="30px"><span>凌霄</span> 👍（3） 💬（1）<div>sessionid这种是不是少了禁用cookie，会在url连接后面加上sessionid。</div>2019-05-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/19/73/f0bca514.jpg" width="30px"><span>肖长路</span> 👍（2） 💬（1）<div>我看了一下上面的讨论，感觉有点明白！所谓的长连接就是换汤不换药，每次传输都是依赖同一个连接（信封），但是，具体内容每次都会变化（信），那么有一个问题，就是所谓的连接超时，是这个长连接有一个固定的存在时间段呢！还是每次信息交互从传输开始到传输响应完成的时间段？那么，如果答案是第一种的话，就有问题了，在这个连接时间段内肯定会出现，内容发完，没有响应就已经到时间而断开此次连接！如果是第二个答案的话，也会有问题，就是，那就是只要每次传输不会超过时间，那么连接就会一直保持而不会中断，那么，假如多个连接出现，每个连接都这样一直保持自己的连接而不中断，岂不是肯定会出现有后续连接无法进入连接队列中的情况吗？感觉自己有点懵！</div>2019-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ca/e1/d8537537.jpg" width="30px"><span>梁😜</span> 👍（2） 💬（1）<div>老师您好，我一直觉得REST架构风格普遍适用，能举例说明一下不得不在服务端保存Session的情况吗？</div>2019-05-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/2f/82/f39673b8.jpg" width="30px"><span>轩</span> 👍（2） 💬（1）<div>HTTP1.1的keep-alive，从TCP&#47;IP架构上来说，是传输层以下的alive，这个alive的连接相当于一个工具，支撑起应用层，应用层需要发送请求就把这个工具拿过来用，所以HTTP的无状态和keep-alive不矛盾是这样理解吗</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/68/08/8fd3b83e.jpg" width="30px"><span>月城冥</span> 👍（2） 💬（1）<div>接我的上一条留言，connection:keep-alive是告诉tcp在单次请求完成后不要关闭连接，下次再请求时依然使用之前的连接，是依靠tcp协议的特点实现的，和http没关系。http是应用层协议重点说明接收到的数据要如何解析，本身并不关心之前的请求是什么样，只要根据协议理解本次请求发过来的东西是什么就好。后来因为程序功能需要多个http请求间也能完成相互依赖的操作，就有了cookie和session。即使没有cookie和session，对使用http协议解读请求数据也是没有任何影响的。长连接和http的无状态说的应该是不同层面上的东西，所以说这两者之间是不矛盾的。不知道这样理解是否正确？</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/68/08/8fd3b83e.jpg" width="30px"><span>月城冥</span> 👍（2） 💬（1）<div>我将来“有状态”理解为每步操作需要依赖之前操作的执行结果。tcp是传输层协议，它是有状态的（这里不是很确定是否可以这样说），</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/21/c5/1ebc0de6.jpg" width="30px"><span>贲佳振</span> 👍（2） 💬（1）<div>session是面向连接的概念ma</div>2019-05-14</li><br/>
</ul>