你好，我是徐昊，今天我们来继续学习AI时代的软件工程。

上一节课，我们展示了直接使用大语言模型（Large Language Model，LLM）辅助进行软件开发的例子，我们看到虽然在速度上LLM有惊人的提高，但是质量堪忧。而且在与LLM一起开发的时候，我们的关注点更多集中在测试上，**通过测试提炼需要给予LLM的反馈，而不是编码。**

可能有同学会说，**那是因为你擅长测试驱动开发（Test Driven Development，TDD），有路径依赖**。那么今天这节课，我们就从根本上讲一讲，使用LLM辅助软件开发的核心思路。

## 从任务划分开始

我们都知道，LLM存在技术限制，每一次LLM只能处理有限数量的token以及产生有限数量token的结果。因而LLM能够理解的上下文规模，以及能够生成的应用规模都是有限的。对于大型系统，我们无法一次性将上下文传递给LLM，也无法从LLM中一次性获取整个应用。

那么使用LLM辅助软件交付的关键就在于**将需求分解成足够小的任务，然后将这个任务转化为LLM的提示词**，交由LLM处理，最后我们再将LLM的生成结果组合成生产或测试代码。

![](https://static001.geekbang.org/resource/image/e3/78/e3d80d0bc473767fe42851a1df582a78.jpg?wh=1475x940)

**那么如何把任务划分成LLM易于处理的形式，就成为了使用LLM辅助软件开发的关键。而对于任务的划分，通常需要考虑两个维度，即软件的架构**与**测试策略**。
<div><strong>精选留言（2）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg" width="30px"><span>术子米德</span> 👍（1） 💬（1）<div>🤔☕️🤔☕️🤔
【R】限制：LLM每次能处理的输入与输出token数量。
关键：从架构设计和测试策略两个维度，将需求分解到足够小的任务。
LLM：任务分解 + 测试代码 + 生产代码。
架构：指导每日工作的任务划分。
测试：TDD + PP with LLM。
PP = Pair Programming
【.I.】LLM的Context Token数量，似乎是它的缺点，看到那个谁已经整得很大，眼看着能把整个代码仓扔进去，貌似很好的样子。可是，我倒认为，这样的限制，实际上可以利用起来，发挥出局部性的聚焦优势。无论我在多大的代码仓里干活，我实际要做的事情，越是在局部，越是能够做得干净利落，越是跟其它耦合，那就拖泥带水踩坑前行。
【.I.】架构，这个词写出来，总有点看似高级又不明所言感。实际上，还不是手头有怎样的兵，就会演化出怎样的架构，无论写在纸上还是落进代码仓里。如今，LLM作为新兵入队，自然会变成影响演化的力量，差别在于，LLM凭自己的生命力，见空就座，还是听话就座，我猜测是前者，而且我相信我的猜测是对的，LLM的力量在于，只要坐下来，就会黏住。
【Q】团队是否也有Clear、Complica、Complex的认知状态？如果有的话，怎么能判断出来当下团队整体处于什么样的认知状态？
—  by 术子米德@2024年4月12日</div>2024-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg" width="30px"><span>范飞扬</span> 👍（0） 💬（0）<div>原文
====
对于扮演测试 Driver 的 LLM 而言，它需要知道测试策略的知识以及测试技术栈的知识。

思考
====
这里老师少说了一点：测试 Driver 也需要架构的知识。因为在 20 讲，老师的prompt就是这么写的[1]。

注释：
[1] 20讲 的 prompt 如下：
架构描述
=======
(略）

功能需求
=======
{functionalities} 

任务
====
上面功能需求描述的场景，在 Persistent 层中需要哪些组件（目标组件）；
列出需求描述的场景使用到目标组件的功能（目标功能）；
列出目标功能需要测试的场景。描述场景，并给出相关的测试数据。
</div>2024-04-23</li><br/>
</ul>