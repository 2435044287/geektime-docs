上回讲到，为了让所有的动物都能参加赛马，Java 7引入了invokedynamic机制，允许调用任意类的“赛跑”方法。不过，我们并没有讲解invokedynamic，而是深入地探讨了它所依赖的方法句柄。

今天，我便来正式地介绍invokedynamic指令，讲讲它是如何生成调用点，并且允许应用程序自己决定链接至哪一个方法中的。

## invokedynamic指令

invokedynamic是Java 7引入的一条新指令，用以支持动态语言的方法调用。具体来说，它将调用点（CallSite）抽象成一个Java类，并且将原本由Java虚拟机控制的方法调用以及方法链接暴露给了应用程序。在运行过程中，每一条invokedynamic指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。

在第一次执行invokedynamic指令时，Java虚拟机会调用该指令所对应的启动方法（BootStrap Method），来生成前面提到的调用点，并且将之绑定至该invokedynamic指令中。在之后的运行过程中，Java虚拟机则会直接调用绑定的调用点所链接的方法句柄。

在字节码中，启动方法是用方法句柄来指定的。这个方法句柄指向一个返回类型为调用点的静态方法。该方法必须接收三个固定的参数，分别为一个Lookup类实例，一个用来指代目标方法名字的字符串，以及该调用点能够链接的方法句柄的类型。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg" width="30px"><span>Shine</span> 👍（27） 💬（1）<div>一直没理解“逃逸分析”啥意思？</div>2018-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/80/bf/3041138b.jpg" width="30px"><span>　素丶　　</span> 👍（21） 💬（3）<div>https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;26389041
https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;30936412
可以和 Shijie 大大的两篇文章配合着看。</div>2018-11-07</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4Tosj3tAYvdgDfa32FAu85ibEicxhtibU4ibdm3YAgvTWwukycMlVfPwea9sL2bFSdBeymWI7iaIbg0g/132" width="30px"><span>karl</span> 👍（20） 💬（1）<div>看了两遍 勉强有个概念了 
还是基础不够 看不懂啊</div>2018-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/04/9a/f2c0a206.jpg" width="30px"><span>ext4</span> 👍（17） 💬（1）<div>我知道Java对Lambda有个规定：“The variable used in Lambda should be final or effectively final&quot;，也就是说Lambda表达式捕获的变量必须是final或等同于final的。而文中您又讲到：“对于捕获了变量的Lambda，每次invokedynamic都需要新建适配器类实例，以防止他们发生变化”。JVM之所以这么做，是因为这种final的要求仅限于Java source层面，在bytecode层面是是无法保证的。我理解的对吗？</div>2018-08-11</li><br/><li><img src="" width="30px"><span>Scott</span> 👍（4） 💬（1）<div>老师你好，我有两个问题，1是我看了几个有invokedynmaic指令的文件，都是invokedynamic #31,  0这种形式，似乎后面这个0没有什么作用，网上invokedynamic的解说也大多过时，我使用的是1.8.0_181版本。2. v10版本和v11版本性能的差距我猜想是v10版本不能正确的内联方法吧？虽然mh是final的，但是字节码层面已经丢失这个信息了。</div>2018-08-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg" width="30px"><span>小橙橙</span> 👍（2） 💬（1）<div>其实有个地方一直没有想透，为什么要学习字节码，学习字节码对我们日常开发有什么作用吗，老师能否给指点迷津一下？</div>2018-08-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/57/0f/1f229bf5.jpg" width="30px"><span>Void_seT</span> 👍（0） 💬（1）<div>单态内联缓存的实现代码段，bootstrap方法的实现有问题，没有return一个CallSite类型返回值。另外，这篇有点难度了，看了三遍，勉强理解。</div>2018-08-11</li><br/><li><img src="" width="30px"><span>lantern</span> 👍（4） 💬（1）<div>用invokedynamic实现lambda发生了什么是看懂了，但没有完全想明白这么做的必要性，这样做相比于编译时解lambda语法糖生成一个匿名类有什么好处呢
是因为对于不捕获局部变量的lambda不用反复new对象吗，那么对于需要捕获局部变量的情况invokedynamic的实现方式还有什么其他的好处吗</div>2020-08-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/01/50/9ac4905e.jpg" width="30px"><span>Kfreer</span> 👍（4） 💬（1）<div>如果该 Lambda 表达式捕获了其他变量，那么每次执行该 invokedynamic 指令，我们都要更新这些捕获了的变化。
问题：捕获的变量必须是final，为什么还会变呢，为什么会线程不安全呢？</div>2019-02-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/25/91/46600294.jpg" width="30px"><span>猴哥一一 cium</span> 👍（3） 💬（0）<div>看到大家都不懂，我就放心了 😁</div>2023-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg" width="30px"><span>小鳄鱼</span> 👍（3） 💬（2）<div>老师，看来上一篇和这篇，又两个问题：
1. 尽管逃逸分析能够去除这些额外的新建实例开销，但是它也不是时时奏效。那么什么情况下不奏效呢？
2. 什么情况下编译器会将句柄识别成常量？除了本文中将MethodHandler定义为常量外，在其他什么情况下能识别为常量呢</div>2018-11-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3f/b7/0d8b5431.jpg" width="30px"><span>snakorse</span> 👍（2） 💬（0）<div>老师，请教个问题：java为什么采用在jvm上通过invokedynamic方式来实现lambda，而不直接通过在编译阶段直接生成和替换代码的方式实现？</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg" width="30px"><span>ppyh</span> 👍（1） 💬（0）<div>有一点不太明白，invokeddynamic为什么要用methodHandle来实现。</div>2021-08-23</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibr1EW9cGq53YX08FybkdD9MPxkR9swIBjo3icrV0tLU7Kgp0TmrQibbichAlGg0WJo0QR1fzIHTTGg/132" width="30px"><span>zjiash</span> 👍（0） 💬（0）<div>V11可以达到和直接调用近似的执行效率，但是V10不可以，应该是方法没有内联。另外，V9如果不使用静态常量，而是在V8基础上使用常量，形如final MethodHandle mh = l.findStatic(Test.class, &quot;target&quot;, t); 执行性能也会比较差。这样和V10类似，不知道为什么这2种情况没有进行内联？</div>2023-10-27</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er9Wgp3Yiby2q79pcibXFv4oPfVVCFDsq1cOh8vP7tegaqpzoeHdIWicBVWuYjG1Hs5UGAgvl00ua14w/132" width="30px"><span>Geek_a7016f</span> 👍（0） 💬（0）<div>老师能提供一些前置基础资料吗？文章感觉有点难度。</div>2022-08-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/33/37/910b7bec.jpg" width="30px"><span>逆流的鱼</span> 👍（0） 💬（0）<div>看不懂</div>2022-07-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/95/6e/6f20ea3b.jpg" width="30px"><span>Hyacinth</span> 👍（0） 💬（0）<div>基础太差 看不懂
</div>2022-06-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg" width="30px"><span>李二木</span> 👍（0） 💬（0）<div>文中 “ i-&gt;i2 和 i-&gt;ix ” 描述有问题，乘号不见了。</div>2022-04-15</li><br/><li><img src="" width="30px"><span>竹林木</span> 👍（0） 💬（0）<div>没有JVM基础根本看不懂啊</div>2022-02-01</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/QrAfzjy5NbAGeptpDAiaQqgfLnlW7JADawOBKJjojvTB1yicl1fIUwgAO7JLiakYB4ZJOAXYXxlJlcuD0mYBYsq4g/132" width="30px"><span>Geek_5eca72</span> 👍（0） 💬（1）<div>我太菜了 我放弃了  : (</div>2021-12-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg" width="30px"><span>ppyh</span> 👍（0） 💬（0）<div>前面的反射调用也不是final的啊，为什么能够被内联呢？</div>2021-08-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg" width="30px"><span>ppyh</span> 👍（0） 💬（0）<div>有深度</div>2021-08-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg" width="30px"><span>滴答丶滴</span> 👍（0） 💬（1）<div>既然捕获型Lambda表达式能借助即时编译器中的逃逸分析，来优化
那为什么上边还要建议使用非捕获的Lambda表达式。
这两句点矛盾吧</div>2021-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg" width="30px"><span>LQS  KF</span> 👍（0） 💬（0）<div>最后两个版本，个人理解应该都会造成逃逸优化失效。v10版本是外界可以直接方法MethodHandle属性逸出，v11版本则是getTarget()方法也会造成逸出。</div>2021-02-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg" width="30px"><span>剑八</span> 👍（0） 💬（0）<div>invokeDynamic指令，出现是为了解决像lambada这样需要有很多不同lambada实现的场景
如果用传统编绎生成类及方法，则编绎时间会很长
invokeDynamic在lambada没有变量值的情况下，只生成一个call site，并且后面不同的表达式都对应一个方法链接。这样相对来说性能会好点</div>2020-06-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/61/c2/1da88a93.jpg" width="30px"><span>今天</span> 👍（0） 💬（0）<div>已经购买，期待后续文章</div>2020-03-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/60/a1/45ffdca3.jpg" width="30px"><span>静心</span> 👍（0） 💬（0）<div>看后还是云里雾里的，可能是关于字节码的基础有点薄弱的缘故。
有几个问题想请教一下老师：
1、bootstrap方法是由编译器生成的？还是自己编写的？
2、boostrap返回的调用点所链接的方法句柄指向的是要调用的最终目标方法吗？
3、能对方法句柄做一个更详细的解释吗？

谢谢！</div>2020-03-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/e4/73/74dce191.jpg" width="30px"><span>鼠里鼠气</span> 👍（0） 💬（0）<div>invokedynamic是用来支持动态类型语言的，而不是把java语言变成动态类型语言，只是在java语言的方法调用上做了改进，以前是将方法分派固化在虚拟机上，现在可以动态的确定目标方法。不知道我说得对不对？还望大神指点一下</div>2019-12-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg" width="30px"><span>KW💤</span> 👍（0） 💬（0）<div>我想问下MonomorphicInlineCache这个例子，为什么能说“调用点方法句柄类型匹配”？
&quot;invoke&quot;的methodType是MethodType.methodType(void.class, Object.class)
“race”的methodType是 MethodType.methodType(void.class)。
还有callsite的用处是什么，我感觉只是将MethodHandle包了一层返回而已，为什么要多这一层</div>2019-07-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/4a/34/1faac99b.jpg" width="30px"><span>夕林语</span> 👍（0） 💬（1）<div>v10和v11的区别仅仅是v11的内部类继承了ConstantCallSite，ConstantCallSite是不可被更改链接的调用点，是不是说明v11的内部类被内联了？从而可以达到和直接调用近似的执行效率</div>2019-04-17</li><br/>
</ul>