你好，我是王磊，你也可以叫我Ivan。

我们在11、12两讲已经深入分析了读写冲突时的控制技术，这项技术的核心是在实现目标隔离级别的基础上，最大程度地提升读写并发能力。但是，读写冲突只是事务冲突的部分情况，更多时候我们要面对的是写写冲突，甚至后者还要更重要些。

你可能经常会听到这类说法，“某某网站的架构非常牛，能抗住海量并发”“某某网站很弱，搞个促销，让大家去抢红包，结果活动刚开始2分钟系统就挂了”。其实，要想让系统支持海量并发，很重要的基础就是数据库的并发处理能力，而这里面最重要的就是对写写冲突的并发控制。因为并发控制如此重要，所以很多经典教材都会花费大量篇幅来探讨这个问题，进而系统性地介绍并发控制技术。在这个技术体系中，虽然有多种不同的划分方式，但最为大家熟知就是悲观协议和乐观协议两大类。

TiDB和CockroachDB的流行一度让大家对于乐观协议这个概念印象深刻。但是，经过几年的实践，两款产品都将默认的并发控制机制改回了悲观协议。他们为什么做了这个改变呢？我们这一讲，专门来探讨什么是乐观控制协议，以及为什么TiDB和CockroachDB不再把它作为默认选项。

## 并发控制技术的分类

首先，无论是学术界还是工业界，都倾向于将并发控制分为是悲观协议和乐观协议两大类。但是，这个界限在哪，其实各有各的解释。
<div><strong>精选留言（5）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg" width="30px"><span>扩散性百万咸面包</span> 👍（11） 💬（1）<div>老师感觉这里没说清楚：
TiDB在2PC prewrite阶段会给每一行加锁，这个锁是局部性的，怎么理解局部性？意思是说这个加锁只是这个事务的单方面行为，而没有通过数据库的锁管理器等组件吗？因为我看到TiDB是会观察所有加锁请求是否成功的，感觉这好像已经算是做全局性的有效验证了？要怎样加锁才是全局性的有效验证呢？</div>2020-09-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/63/e4c28138.jpg" width="30px"><span>春风</span> 👍（5） 💬（1）<div>老师，TiDB全局性验证是否是增加了一轮共识算法的时间</div>2020-09-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg" width="30px"><span>扩散性百万咸面包</span> 👍（2） 💬（1）<div>一个非常典型的例子就是 select for update。这是一个显式的加锁操作，或者说是显式的方式进行有效性确认，广义的乐观协议都不提供严格的 RVW，所以也就无法支持这个操作。
这句话没懂，广义的乐观协议不是支持加锁吗（比如TiDB对每一行修改前加锁）？还是说像TiDB这样的，它的加锁不是显式的，只能在percolator 2PC中加锁，所以不支持这种显式加锁的。</div>2020-09-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg" width="30px"><span>Peter Yu</span> 👍（1） 💬（0）<div>乐观协议（RVW）和悲观协议（VRW）是不是分别理解为DVC（do、validate、commit）和VDC（validate、do、commit）更合适。因为这里的R太让人费解，也容易误解
对于乐观协议，因为多数情况只要执行业务逻辑（do），然后直接提交（commit）即可，虽然涉及validate，因为没有冲突，所以没有rollback，所以validate的损耗可以忽略。
对于悲观协议，先要validate，已发现冲突就加锁，其他事务进不来。本事务完成业务逻辑（do）和提交（commit）后再释放锁。
更白话一点：
乐观协议就是管你会不会冲突，我直接开干，遇到冲突再说，冲突了就回滚。虽然回滚的成本高，但是总体回滚的次数不多，综合来看这部分损耗忽略不计。
悲观协议就是我预计只要一开干就很可能会资源冲突，用乐观协议的做事方式来，会有不计其数的回滚，此时还不如排队一个个来做。当做的时候，先获取锁，获取到，干完活，在提交成果物，最后释放锁。
不知这样理解可不可以，忘老师指教</div>2022-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ea/32/1fd102ec.jpg" width="30px"><span>真名不叫黄金</span> 👍（0） 💬（0）<div>老师，你好，有一个问题想请教一下：
Spanner 在文档中称自己的事务是基于悲观锁的，但是其实它也是将 Writes 缓存住的，在 commit 时一次性获取锁、完成两阶段提交，它在执行 DML 时并没有检测冲突，Spanner 在提交时采用伤停等待策略，实践中确实可能会带来冲突时很多事务的大量 abort 和 retry。
按照老师文中的标准，Spanner 其实是一种乐观事务对吗？
</div>2020-09-09</li><br/>
</ul>