你好，我是王磊，你也可以叫我Ivan。

通过上一讲的学习，你已经知道使用两阶段提交协议（2PC）可以保证分布式事务的原子性，但是，2PC的性能始终是一个绕不过去的坎儿。

那么，它到底有多慢呢？

我们来看一组具体数据。2013年的MySQL技术大会上（Percona Live MySQL C&amp;E 2013），Randy Wigginton等人在一场名为“Distributed Transactions in MySQL”的演讲中公布了一组XA事务与单机事务的对比数据。XA协议是2PC在数据库领域的具体实现，而MySQL（InnoDB存储引擎）正好就支持XA协议。我把这组数据转换为下面的折线图，这样看起来会更加直观些。

![](https://static001.geekbang.org/resource/image/72/ya/7227f5f6b32f6d9bb4cafefa96ac8yya.jpg?wh=2700%2A1481)

其中，横坐标是并发线程数量，纵坐标是事务延迟，以毫秒为单位；蓝色的折线表示单机事务，红色的折线式表示跨两个节点的XA事务。我们可以清晰地看到，无论并发数量如何，XA事务的延迟时间总是在单机事务的10倍以上。

这绝对是一个巨大的性能差距，所以这个演讲最终的建议是“不要使用分布式事务”。

很明显，今天，任何计划使用分布式数据库的企业，都不可能接受10倍于单体数据库的事务延迟。如果仍旧存在这样大的差距，那分布式数据库也必然是无法生存的，所以它们一定是做了某些优化。
<div><strong>精选留言（22）</strong></div><ul>
<li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0Qwib3PcoRRxTZSoxAdJ1hELibJeoEqSKP6Ksyu0e7MrGickk1COuv6oQ1w9W2kqM8gUg0Oj057UBw/132" width="30px"><span>UTC+00:00</span> 👍（18） 💬（2）<div>目前听下来，感觉分布式系统的主要优化方法就是攒批+异步(事后补偿)。</div>2020-08-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/63/e4c28138.jpg" width="30px"><span>春风</span> 👍（18） 💬（4）<div>老师，如果在异步commit之前，客户端又发起查询，查到的数据是怎样的</div>2020-08-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/d5/b1/1007b5d2.jpg" width="30px"><span>星之柱</span> 👍（11） 💬（1）<div>并行提交这块看的不是很明白，是指prepare阶段即写数据，又将标记设置为staging吗，然后再读的时候来校验staging是否是大多数？</div>2020-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg" width="30px"><span>平风造雨</span> 👍（8） 💬（1）<div>如果客户端没有在一定的时间内得到所有意向写的反馈（不知道反馈是成功还是失败），要如何处理？</div>2020-09-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f2/66/b16f9ca9.jpg" width="30px"><span>南国</span> 👍（7） 💬（1）<div>老师，我的上一条留言有点小小的问题，就是应该是第二阶段的优化，也就是并行提交可能考虑到了BASE，因为异步提交后，不做其他措施的话可能出现数据不一致的问题，不知道对于并行提交上一条留言说法还对不对。

还有老师，在Pipeline中事务状态的落盘操作理解为准备阶段每一个写操作的落盘，事务状态的确定理解为每一个写操作的确定，还是不同事务之间状态的确定同步完成呢？这里感觉有脑子有点乱。


</div>2020-09-01</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132" width="30px"><span>有铭</span> 👍（3） 💬（1）<div>如果异步线程没有任何补偿和回滚操作，那它在check状态时如果发现状态有异常时不做处理吗</div>2020-09-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f2/66/b16f9ca9.jpg" width="30px"><span>南国</span> 👍（3） 💬（2）<div>第二种优化方法感觉就比较贴近于BASE了，因为效率放弃强一致性而选择最终一致性，这个最终一致性是系统角度的一致性，可以采取像zk一样的方法支持用户角度强一致性，也就是读前先写得到最新的事务号，读取节点被同步前阻塞就可以了；或者就直接维护一个较弱的一致性模型，当然这都是异步线程做的事情了。到头来还是效率和一致性的取舍，所以感觉不同的系统中这个异步线程的实现就至关重要了</div>2020-09-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3e/e9/116f1dee.jpg" width="30px"><span>wy</span> 👍（1） 💬（1）<div>并行提交那个思路有点像悲观锁切换到乐观锁的思路。prepare阶段就像加锁阶段，以往的做法是先prepare，锁住资源再commit，而优化的手段就像乐观锁，先并行执行，有冲突再返回错误</div>2021-01-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg" width="30px"><span>花晨少年</span> 👍（0） 💬（1）<div>缓存写提交的耗时为什么不是一轮共识的时间呢，而是两轮呢？不是提交时把多个写操作和提交操作一起并行执行吗？</div>2021-06-14</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ahZfubU68aBgJFNPib1rbFXM4lDAnUVNhUAzhMjLZBW1GS7Sb7uFPHRSuBdS6liaUibicfRURBpQIhFJWxt70l3W1A/132" width="30px"><span>Jenvid</span> 👍（0） 💬（1）<div>目前看下来，感觉分布式系统的主要优化方法就是攒批+异步(事后补偿)。</div>2021-04-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1a/8b/41acc7fa.jpg" width="30px"><span>Leo</span> 👍（0） 💬（1）<div>老师您好，请教下，tidb的悲观事务是不是可以近期等于3*Lc，在乐观事务基础上加一次并行的加锁(也近近似一次raft共识算法)</div>2020-12-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/fd/af/ca57c38b.jpg" width="30px"><span>贺</span> 👍（0） 💬（1）<div>老师，关于 tidb 缓存写提交的资料可以提供一些吗？想获得更多它的技术细节，我在搜索引擎搜到的资料好像不多，不知道是不是我搜索的问题。</div>2020-11-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg" width="30px"><span>扩散性百万咸面包</span> 👍（0） 💬（2）<div>老师，根据DDIA的说法，事务中途的写入不算入2PC的prepare阶段，prepare阶段是提交的时候才用的。也就是说prepare阶段好像只是一个消息，协调者来询问资源所有者能否提交。而文中说的写入要耗时一轮共识算法，好像都归类于prepare阶段了，应该还是事务正常写入阶段吧？</div>2020-09-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/61/61/677e8f92.jpg" width="30px"><span>xianhai</span> 👍（0） 💬（1）<div>并行提交后事务失败，由异步行程维护状态，我怎么觉得这种设计像tcc？它在应用层面处理事务失败后的维护工作吗？</div>2020-09-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/63/e4c28138.jpg" width="30px"><span>春风</span> 👍（0） 💬（1）<div>老师，FoundationDB也是分布式数据库吧</div>2020-09-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/49/fc/5627215c.jpg" width="30px"><span>小何</span> 👍（1） 💬（1）<div>请问老师能不能解释一下，“可以说，TiDB 的“缓存写提交”方式已经不是完全意义上的交互事务了。”这里交互事务是指的什么呢？前文好像没有出现过这个说法。</div>2021-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/b4/b4/9aaa2a37.jpg" width="30px"><span>黄弟</span> 👍（0） 💬（0）<div>老师为啥对oceanbase的相关实现介绍的比较少了？</div>2021-12-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg" width="30px"><span>槑·先生</span> 👍（0） 💬（0）<div>事务记录里面的 Writes: []Key{&quot;A&quot;, &quot;C&quot;, ...} 部分是否得支持追加写的方式？事务的写操作虽然是pipeline的方式到来的，时间间隔很短，但仍然不是以一批的方式写下去的，所以这里应该是追加写的吧。</div>2021-04-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b9/a5/c16157b6.jpg" width="30px"><span>Young</span> 👍（0） 💬（0）<div>请问spanner在2PC有优化么？希望详细讲讲</div>2020-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg" width="30px"><span>扩散性百万咸面包</span> 👍（0） 💬（0）<div>我没有表述清楚问题，我再叙述一遍：DDIA上认为2PC是在事务COMMIT的时候再开始执行，这个时候prepare阶段只是协调者向资源所有者确认能否提交（简单的消息确认）。但是我发现现当代的分布式数据库，以及老师文章中所讲到的优化方法，认为2PC在事务BEGIN之后就进入了prepare阶段，发生的所有写入都属于prepare阶段。我个人认为是后者好理解一些，也更高效一些。因为每个写入如果都成功，那么我们协调者就没必要再prepare阶段询问其他节点，避免堵塞。</div>2020-09-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg" width="30px"><span>piboye</span> 👍（0） 💬（0）<div>stage和prpare一块并发太妙了。我只想到prepare并发和合并写，这样还是要两次共识算法的延迟</div>2020-09-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/49/f1/aa23d7c4.jpg" width="30px"><span>郑大侠</span> 👍（0） 💬（1）<div>并行提交这种极致的优化稍微难理解了些，
很好奇这种优化下事务隔离级别怎么实现的？
事务冲突检测会不会很麻烦</div>2020-09-01</li><br/>
</ul>