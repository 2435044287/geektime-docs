Java语言在设计之初就引入了线程的概念，以充分利用现代处理器的计算能力，这既带来了强大、灵活的多线程机制，也带来了线程安全等令人混淆的问题，而Java内存模型（Java Memory Model，JMM）为我们提供了一个在纷乱之中达成一致的指导准则。

今天我要问你的问题是，Java内存模型中的happen-before是什么？

## 典型回答

Happen-before关系，是Java内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。

它的具体表现形式，包括但远不止是我们直觉中的synchronized、volatile、lock操作顺序等方面，例如：

- 线程内执行的每个操作，都保证happen-before后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。
- 对于volatile变量，对它的写操作，保证happen-before在随后对该变量的读取操作。
- 对于一个锁的解锁操作，保证happen-before加锁操作。
- 对象构建完成，保证happen-before于finalizer的开始动作。
- 甚至是类似线程内部操作的完成，保证happen-before其他Thread.join()的线程等。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg" width="30px"><span>clz1341521</span> 👍（34） 💬（6）<div>杨老师，请教一个问题，望答复。
volatile boolean和atomicboolean 一样是原子性的吗？</div>2018-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/5e/de/4e7ec66d.jpg" width="30px"><span>蠢蠢欲动的腹肌</span> 👍（10） 💬（1）<div>在网上看了下让双检锁生效的方法，除了用volatile修饰变量外，还有其他两种方式
1、用final 修饰变量
2、用本地线程的方式修复，即在创建对象时存取本地线程（final的），在get的时候再从本地取
</div>2018-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e2/47/e910afec.jpg" width="30px"><span>刘杰</span> 👍（1） 💬（1）<div>您又说到了单例模式中的那个其他线程访问到未初始完成对象的问题，忍不住再问下，是否可以先用一个局部变量初始化对象，再把局部变量赋值给类成员？这样可以解决吗？</div>2018-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg" width="30px"><span>3W1H</span> 👍（1） 💬（1）<div>老师的例子里面的thread a,b的逻辑是在一个方法里面吗？</div>2018-07-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a5/40/ad00a484.jpg" width="30px"><span>- -</span> 👍（64） 💬（2）<div>个人觉得happens-before原则最难理解的就是和时间次序上的关系，就比如volatile变量的写操作happens-before其后的读操作，之前很难理解“其后”的含义，一直认为既然是先发生的操作，结果肯定对后续的操作可见啊，以至于认为这个原则是不是多余的。结合了jmm内存模型来看的话就很好理解了，一个操作完成，其结果只是在线程内可见的，在结果写回主存并被其他线程读取前，即使其他线程操作靠后，也无法看见其操作结果。所以才会有volatile、锁等一系列可见性原则的约束</div>2018-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/dc/6a/b5478b65.jpg" width="30px"><span>Ab</span> 👍（23） 💬（0）<div>jmm可以从两个方面理解，一是抽象内存结构，jmm把内存结构抽象成主内存和线程本地内存两种，在计算时，从主内存中加载数据，在本地内存计算，然后在刷新到主内存，但这种模型有明显的一致性问题，二是jmm可以理解我一组保住内存可见性及成正确性的规范，因为这种模型存在明显的一致性问题，同时，由于java编译器指令重排序优化和cpu乱序执行优化的存在，使问题变得更加复杂，所以jmm基于内存屏障提供了类似sa if serial以及happens before的保障。从使用者的角度理解，jmm平衡了jvm工程师以及cpu工程师在性能上的需求和java程序员在简单性上的渴望，所以jmm在保证正确性的同时会最大限度的放宽对指令重排和乱序执行的限制。对于java程序员，jmm提供了如volatile和synchronized这样的顶层机制为程序员提供简单的编程模型。（参考老师的文章及java并发编程艺术 理解）</div>2018-07-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg" width="30px"><span>李二木</span> 👍（14） 💬（1）<div>刚看完文章，在看了下《深入JAVA虚拟机》的java内存模型章节，又加深点印象。这本书真不能像小说一样读！</div>2018-07-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg" width="30px"><span>张三</span> 👍（9） 💬（0）<div>volitaile的意义在于禁用缓存</div>2020-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/dc/6a/b5478b65.jpg" width="30px"><span>Ab</span> 👍（9） 💬（0）<div>jmm可以从两个方面理解，第一个方面是jmm规范了一个抽象的内存结构，jmm运行时内存进行简化抽象得到了主内存和本地内存两块内存区域，在线程运行时，从主内存中加载数据到本地内存，在本地内存中完成计算后，在刷新到主内存。第二个方面是jmm可以理解我一组保证数据内存可见性和程序正确性的规则，由于这种内存模型存在很明显的数据一致性问题，再加上编译器的指令重排序和cpu乱序执行优化，使问题更加复杂了，而jmm就是通过类似内存屏障等手段保证了内存可见性问题以及在多线程环境下乱序优化和指令重排序带来的线程安全性问题。从使用者的角度理解，jmm实际上平衡了java程序员对简单性的渴望和jvm工程师cpu工程师对性能的追求的平衡，面向底层时，jmm在保证正确性的同时最大限度的放宽了对指令重排序和乱序执行优化的限制，面向上层jmm通过内存屏障实现了volatile和synchronized等内存语意，使程序员可以简单方便的应用这些特性来保证程序的程序的正确性。
</div>2018-07-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/18/34/c082419c.jpg" width="30px"><span>风轨</span> 👍（8） 💬（0）<div>先看了两遍，始终处于懵逼的状态，后来去把《深入理解java虚拟机》相关部分仔细阅读一下，再回来看终于看懂了！</div>2018-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（3） 💬（1）<div>我之前翻译过JSR-133 Cookbook, 是中英文对照版的，英文不好的同学可以对照看看。
https:&#47;&#47;yellowstar5.cn&#47;direct&#47;The%20JSR-133%20Cookbook-chinese.html
</div>2021-01-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg" width="30px"><span>clz1341521</span> 👍（2） 💬（0）<div>1,验证出 “可见性问题”,这个很容复现
2,验证出“cpu指令优化重排”导致的如 双检锁 中对象未初始化完毕，即被使用问题。这个对象构造要慢，才容易复现
</div>2018-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/2c/61/bede8a20.jpg" width="30px"><span>S</span> 👍（1） 💬（2）<div>杨老师，请教个问题：
在说volatile可见性举的两个例子中，针对第一个，为什么在死循环中添加了一个System.out就会使死循环退出？这个System.out为啥会起到作用</div>2020-02-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（1） 💬（0）<div>配合深入理解Java虚拟机第12章食用，效果更佳</div>2019-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg" width="30px"><span>冰激凌的眼泪</span> 👍（1） 💬（1）<div>单线程内的happens before和优化后的有序性不冲突吗？这里的happens before是指的高级语言语句级还是cpu指令级呢？</div>2019-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/b6/f2/c78f79e1.jpg" width="30px"><span>超级玩家</span> 👍（1） 💬（1）<div>杨大大，final除了不可变的作用，也能在一定程度上可以起到线程安全的作用？final是通过什么方式来做到线程安全的作用的？</div>2018-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/0e/a1/717e2768.jpg" width="30px"><span>磊吐槽</span> 👍（1） 💬（1）<div>老师🙋‍♂️我有个问题：
有一个全局的ConcurrentHashMap&lt;String,Set&lt;Foo&gt;&gt;
Key是Foo的一个字符串属性
然后有一个方法
通过Foo.getStr() 以此为key判断是否存在map 中如果不存在就创建一个set添加到map
现在这个方法并发情况下第一次创建Set时会出现替换Set的问题，我想如何通过volitile解决？原谅学生愚钝.</div>2018-07-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cb/92/cfc1cfd3.jpg" width="30px"><span>贝氏倭狐猴</span> 👍（0） 💬（0）<div>线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。这个不一定吧，操作对象不相同就不一定，可能会发生指令重排。</div>2023-04-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg" width="30px"><span>剑八</span> 👍（0） 💬（0）<div>jmm就是java内存模型规范，解决问题-
让程序员不需要特别关心底层cpu架构对于并发的影响。
jmm抽象了共享内存与工作内存，包含了一系列规则，如happen befor，只要遵循这个规范就可以解决多线程并发问题</div>2021-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cb/92/cfc1cfd3.jpg" width="30px"><span>贝氏倭狐猴</span> 👍（0） 💬（0）<div>&quot;你可以简单理解为，把本地变量等数据从内存加载到缓存、寄存器，然后运算结束写回主内存。&quot;这句话有点疑问，因为从汇编指令来说，处理器也是可以接受主存作为单个操作数的。难道JVM的操作都是把主存拷入寄存器之后再操作，不用主存当成单个操作符的汇编指令？</div>2021-08-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/24/21/90b748a2.jpg" width="30px"><span>不归橙</span> 👍（0） 💬（1）<div>二刷，感觉对“克制住对“秘籍”的诱惑”的描述不是很理解，老师可以举个例子吗？</div>2021-08-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/5d/35/b1eb964a.jpg" width="30px"><span>🐟🐙🐬🐆🦌🦍🐑🦃</span> 👍（0） 💬（0）<div>老师，线程在自己的工作内存中读写变量，变量是通过read load操作从主内存到工作内存的，在read原子操作说把变量从主内存读取到工作内存，以便随后的load操作，而load原子操作定为把从主内存read的变量load 工作内存的变量副本，这里read和load如何理解，实际上不就是吧内存的变量放入CPU高速缓存么，怎么就有2个操作，read和load</div>2021-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg" width="30px"><span>余松</span> 👍（0） 💬（0）<div>请问内存屏障和CPU fence指令是一个概念吗？看了好几篇文档，没有把两者区分开来。</div>2021-03-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（0） 💬（0）<div>为什么需要JMM？
不同CPU架构提供不同的内存屏障指令和内存一致性模型（主要由硬件工程师实现）；为了对上层隐藏各种CPU架构的不同，Doug Lea基于此又提出了JVM层面的LoadLoad，StoreStore等内存屏障（由JVM实现者实现）；然后JVM实现者则提供统一的Java内存模型（比如Java语言规范 第八版 17章）；然后我们这些普通的Java开发者就在这统一的Java内存模型上写跨平台的应用。
</div>2021-01-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/76/48/5ab89daa.jpg" width="30px"><span>护爽使者</span> 👍（0） 💬（0）<div>volatile 保证可见性，volatile 的 happens-before 怎么理解？</div>2020-03-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg" width="30px"><span>王盛武</span> 👍（0） 💬（0）<div>老师讲了JSR133里的1个规则, volatile</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/26/78/ed0252c2.jpg" width="30px"><span>ddddd🐳</span> 👍（0） 💬（0）<div>关于volatile的这句描述-“对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。”，我始终不理解，写了很多demo测试，也没弄清楚，老师能给个简单的demo code吗？；</div>2019-10-31</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKcGBqEZQKHjq3XaSZRLmxrCykMEotI0yKWX7RbbPZh6xTdmNRsum2YxtHv33zHGFdVqxic1pIEn8Q/132" width="30px"><span>yzh</span> 👍（0） 💬（0）<div>老是，具体有什么工具可以验证JMM的所有执行可能</div>2019-08-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a4/bc/02596f1a.jpg" width="30px"><span>浪尖</span> 👍（0） 💬（1）<div>读操作插入的屏障，不都是在volatile读之后吗？</div>2019-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ea/6a/e4443e5e.jpg" width="30px"><span>谢涛</span> 👍（0） 💬（0）<div>茅塞顿开了，赞</div>2019-06-06</li><br/>
</ul>