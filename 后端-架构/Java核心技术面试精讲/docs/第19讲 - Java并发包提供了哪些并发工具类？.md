通过前面的学习，我们一起回顾了线程、锁等各种并发编程的基本元素，也逐步涉及了Java并发包中的部分内容，相信经过前面的热身，我们能够更快地理解Java并发包。

今天我要问你的问题是，Java并发包提供了哪些并发工具类？

## 典型回答

我们通常所说的并发包也就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：

- 提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作，比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。
- 各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。
- 各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、 SynchronousQueue或针对特定场景的PriorityBlockingQueue等。
- 强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/77/60/a44c90c5.jpg" width="30px"><span>013</span> 👍（99） 💬（2）<div>1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：
CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。
2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</div>2018-11-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/00/85/21e1a720.jpg" width="30px"><span>Daydayup</span> 👍（43） 💬（6）<div>CountDownLatch最近还真用上了。我的需求是每个对象一个线程，分别在每个线程里计算各自的数据，最终等到所有线程计算完毕，我还需要将每个有共通的对象进行合并，所以用它很合适。</div>2018-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/7e/dd/e4e6718a.jpg" width="30px"><span>扫地僧的功夫梦</span> 👍（15） 💬（4）<div>17讲的问题，留言有点晚，老师可能不会看，想得到老师的回复：调用notify()&#47;notifyAll()方法后线程是处于阻塞状态吧，因为线程还没获取到锁。</div>2018-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/791d0f5e.jpg" width="30px"><span>忍者无敌1995</span> 👍（13） 💬（4）<div>最近有用到countDownLatch，一个批量更新接口，采用多线程提高处理速度，全部处理完将结果封装返回给app端</div>2018-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/38/ba6a106f.jpg" width="30px"><span>Phoenix</span> 👍（7） 💬（1）<div>经过老师的讲解，我对CountDownLatch的使用场景是这样理解的：
1：A线程的执行，依赖与B线程或C线程等等其他多个线程任务的执行结果来触发A线程任务执行事件</div>2018-11-11</li><br/><li><img src="" width="30px"><span>zjh</span> 👍（2） 💬（1）<div>感觉再分布式的情况下，单体应用中需要多个线程并行的情况可能会被分散在多个应用里面，可能很少会用到CountDownLatch和cyclicbarrier，semaphore倒是比较适合用在分布式的场景下，用来做一些限流。

</div>2018-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1a/12/71cbb5ec.jpg" width="30px"><span>xinxin💛</span> 👍（1） 💬（1）<div>老师为什么我用ConcurrentHashMap执行remove操作的时候cpu总是跳得很高，hashmap就还好没那么夸张。。现在为了线程安全还是用ConcurrentHashMap，但执行remove操作的线程一多经常就卡死了。</div>2018-07-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg" width="30px"><span>jacy</span> 👍（1） 💬（1）<div>感觉CountDownLatch有点像c++中的条件锁，想问一下老师，可否给点从c++转java的建议。</div>2018-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/59/62/954065d4.jpg" width="30px"><span>步＊亮</span> 👍（0） 💬（1）<div>SemaphoreWorker类应该为static</div>2018-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/2a/41/bd6da351.jpg" width="30px"><span>天秤座的选择</span> 👍（53） 💬（6）<div>做android的，一个页面有A,B,C三个网络请求，其中请求C需要请求A和请求B的返回数据作为参数，用过CountdownLatch解决。</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg" width="30px"><span>Jerry银银</span> 👍（30） 💬（0）<div>对于Java 并发包提供了哪些并发工具类，我是这么理解的：
1. 执行任务，需要对应的执行框架（Executors）；
2. 多个任务被同时执行时，需要协调，这就需要Lock、闭锁、栅栏、信号量、阻塞队列；
3. Java程序中充满了对象，在并发场景中当然避免不了遇到同种类型的N个对象，而对象需要被存储，这需要高效的线程安全的容器类</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c9/a4/f5341299.jpg" width="30px"><span>夏天🔆</span> 👍（16） 💬（0）<div>以前使用coutdownlatch进行并发异常的模拟，来修改bug，具体是在发生异常的错误堆栈上进行await，在某些条件处或触发点进行coutdown，来尽可能模拟触发异常时的场景，很多可以必现，修改之后没有问题，才算解决一个并发异常</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/98/ac/c2c4fd82.jpg" width="30px"><span>如风</span> 👍（9） 💬（0）<div>在写爬虫时，使用过 Semaphore ，来控制最多爬同一个域名下的 url 数量。</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg" width="30px"><span>石头狮子</span> 👍（8） 💬（0）<div>列举实践中两个应用并发工具的场景:
1. 请求熔断器，使用 Semaphore 熔断某些请求线程，待系统恢复以后再逐步释放信号量。
2. Worker 搜索停止标志。使用 countdownlatch 标记 Worker 找到的结果个数，达到结果后其他线程不再继续执行。</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg" width="30px"><span>feifei</span> 👍（7） 💬（0）<div>我的使用经验，在进行高并发的测试时，我会使用countdownlatch,将所有的工作线程在开始时等待，然后在统一的开始，这样就可以避免创建线程所需的时间开销，更好的模拟高并发</div>2018-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg" width="30px"><span>THROW</span> 👍（6） 💬（1）<div>ArrayBlockingQueue使用了两个condition来分别控制put和take的阻塞与唤醒，但是我在想好像只用一个condition也可以，因为put和take只会有一个是处于阻塞等待状态。所以设计成两个condition 的原因是什么呢？只是为了提高可读性么？</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f1/70/a64d9498.jpg" width="30px"><span>三个石头</span> 👍（6） 💬（2）<div>你用的Semaphore第二个例子，构造函数中为啥为0,信号量不是非负整数吗？</div>2018-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/65/69/efb57b83.jpg" width="30px"><span>Leiy</span> 👍（5） 💬（1）<div>对于CopyOnWriteArrayList，适用于读多写少的场景，这个比较好理解，但是在实际使用时候，读写比占多少时候，可以使用？心里还是没数，这个怎么去衡量？</div>2018-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg" width="30px"><span>天王</span> 👍（3） 💬（0）<div>19 java并发包提供了哪些工具类 1 Java.util.concurrent及其子包，包含了java的各种并发工具类 1.1 提供了比synchronized更高级的同步结构 ，包括CountDownLatch，CyclicBarrier，Semaphore，可以实现更加丰富的线程操作 1.2  各种线程安全的容器 ConcurrentHashMap，ConcurrentSkipListMap，线程安全的数组 CopyOnWriteArrayList 1.3 各种并发队列BlockingQueue实现 ，比如ArrayBlockingQueue，SynchronousQueue或针对特定场景的PriorityBlockingQueue，1.4 强大的executor框架，可以创建不同类型的线程池和调度任务，不用自己创建。2 并发类的实际应用 CountDownLatch 允许一个或者多个线程等待某些操作完成，CyclicBarrier，允许多个线程等待达到某个屏障 ，Semphore java版本的信号量实现，2.1 Semphore通过限制一定数量的多个permit的方式，来达到限制统一资源访问的目的，Semphore是通过acquire和release，如果初始值设置为1，则1个线程通过acquire进入互斥状态，2.2 CountDownLatch和CyclicBarrier区别 CountDownLatch是不可以被重置的，CuclicBarrier可以被重置，CountDownLatch的基本操作组合是countdown&#47;await，调用 await的线程阻塞等待countDown足够的次数，不管一个还是多个线程，足够的次数即可。CyclicBarrier的组合就是await，当所有的伙伴都调用完了await，才会继续进行任务，并进行重置。CyclicBarrier 侧重的是线程，典型应用场景是等待比并发线程结束。Cyclic反应的是线程并发运行时的协调</div>2020-01-03</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（3） 💬（0）<div>semaphore主要是集中处理acquire&#47;release，控制进入关键区域的访问者个数。
典型用法一，semaphore初始化为5,表示可以有 5位访问者可以进入关键区域，每位访问者调用acquire获得进入关键区域的资格，也就是进入或等待。进入关键区的访问者访问者调用release，释放一个准入资格，其他等待中的一个访问者会被唤醒获准进入关键区域。
典型用法二，semaphore初始化为0,表示获取访问资格的访问者一开始处于等待状态，然后通过release(5)批量释放访问者进入关键区域 ，然后检查关键区域是否为空，再确定是否放下一批访问者进入。
</div>2019-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/7e/dd/e4e6718a.jpg" width="30px"><span>扫地僧的功夫梦</span> 👍（3） 💬（2）<div>谢谢老师的回复，还是notify()&#47;notifyAll()问题，我想说的是被唤醒的线程再重新获取锁之前应该是阻塞状态吧。</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/48/de/bebd1bf6.jpg" width="30px"><span>SugarZh</span> 👍（2） 💬（0）<div>CountDownLatch其实有点类似go语言中的WaitGroup，都是等待所有线程都执行完，才会执行后续动作</div>2020-12-12</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/QYKSUV20DMgBHAPLfgngdw4N8FHRCSBLCJueVRu9Ya1Ba2x4icx70zoVVFOZtG1K6TkHj5CFbuztQhRFyCjWXHQ/132" width="30px"><span>zaab</span> 👍（1） 💬（0）<div>CopyOnWriteArrayList使用的时候需要注意， 如果使用普通的for循环， 多线程的情况下， 在for循环的时候很可能会被读到修改的数据， 使用迭代器则不会有这种问题。
迭代器部分源码：
 public Iterator&lt;E&gt; iterator() {
        return new COWIterator&lt;E&gt;(getArray(), 0);
    }
</div>2019-11-11</li><br/><li><img src="" width="30px"><span>木头疙瘩</span> 👍（1） 💬（2）<div>Java初级选手有一个小白的问题请教老师，关于文中提到的CopyOnWriteArrayList的add方法，既然方法中已经通过synchronized加锁了（我看了下源码，使用的是ReentrankLock加的锁，可能跟老师版本不同），那为何不能直接操作原数组还要copy一份新数组出来呢，希望老师能看到，谢谢~</div>2019-04-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（1） 💬（1）<div>一般用CountDownLatch来提高接口访问速度，不知道这样符不符合规范😂😂😂</div>2019-04-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/09/1b/8665aa89.jpg" width="30px"><span>……</span> 👍（1） 💬（0）<div>CyclicBarrier结合FixedThreadPool使用，如果屏障点多与线程池线程数，将会出现问题。</div>2019-02-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg" width="30px"><span>clz1341521</span> 👍（1） 💬（0）<div>我的应用场景是异步发送一定数量的http消息，主线程等待 所有发送完毕，获取所有的发送成功数</div>2018-08-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg" width="30px"><span>杨逸林</span> 👍（1） 💬（0）<div>大佬，我在我的博客上可以引用一些你写的ConcurrentHashMap的内容吗</div>2018-08-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg" width="30px"><span>Jerry银银</span> 👍（1） 💬（0）<div>客户端开发中遇到的并发场景会不会有点少？如果对并发领域有浓厚的兴趣，可以尝试超哪个方向转型（又或许不需要转型，只需要找一个方向来进行实践）？

老师课后留的问题，我在工作中没有遇到过。我在JAVA并发编程实践中了解到的一种场景是：需要测试N个线程并发执行某个任务时需要的时间。</div>2018-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/37/38/f1/7f65979c.jpg" width="30px"><span>Gen幸福旅程iuS</span> 👍（0） 💬（0）<div>copyonwrite 写的时候因为有锁，如果不进行拷贝，不是也可以保证线程安全吗？为什么非要拷贝新的对象呢？</div>2023-05-23</li><br/>
</ul>