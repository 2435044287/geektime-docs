今天，我将从内存管理的角度，进一步探索Java虚拟机（JVM）。垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。

今天我要问你的问题是，谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？

## 典型回答

通常可以把JVM内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个JVM进程唯一的。

首先，**程序计数器**（PC，Program Counter Register）。在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。

第二，**Java虚拟机栈**（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/d6/8d/7db04ad3.jpg" width="30px"><span>I am a psycho</span> 👍（310） 💬（3）<div>如果仅从jvm的角度来看，要看下新生代和老年代的垃圾回收机制是什么。如果新生代是serial，会默认使用copying算法，利用两块eden和survivor来进行处理。但是默认当遇到超大对象时，会直接将超大对象放置到老年代中，而不用走正常对象的存活次数记录。因为要放置的是一个byte数组，那么必然需要申请连续的空间，当空间不足时，会进行gc操作。这里又需要看老年代的gc机制是哪一种。如果是serial old，那么会采用mark compat，会进行整理，从而整理出连续空间，如果还不够，说明是老年代的空间不够，所谓的堆内存大于100m是新+老共同的结果。如果采用的是cms(concurrent mark sweep)，那么只会标记清理，并不会压缩，所以内存会碎片化，同时可能出现浮游垃圾。如果是cms的话，即使老年代的空间大于100m，也会出现没有连续的空间供该对象使用。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9b/2f/b7a3625e.jpg" width="30px"><span>Len</span> 👍（44） 💬（1）<div>从不同的垃圾收集器角度来看：

首先，数组的分配是需要连续的内存空间的（据说，有个别非主流JVM支持大数组用不连续的内存空间分配🤔）。所以：

1）对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。

进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。

2）对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。

当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。

</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg" width="30px"><span>夏洛克的救赎</span> 👍（20） 💬（1）<div>Tomcat运行中突然出现java.lang.OutOfMemoryError: PermGen space有什么工具可以排查原因吗？</div>2019-01-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" width="30px"><span>任鹏斌</span> 👍（19） 💬（1）<div>老师既然元数据区也存在溢出，那么为什么要用元数据区替换永久代呢，有什么好处吗？</div>2018-08-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/09/bb/b88b3ad6.jpg" width="30px"><span>markin</span> 👍（17） 💬（1）<div>老师，能否跟我们介绍一下您平时获取资料的渠道。比如apache的一些开源项目，官网上就有很丰富的文档。但是我们获取jvm相关文档的渠道少之又少，无非就是博客或者书籍，这些都比较繁杂，并且可能参杂着很多难以识别的错误观点。授人以鱼不如授人以渔，先谢谢老师了。</div>2018-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/17/81/b7b07da7.jpg" width="30px"><span>爱吃芒果的董先森</span> 👍（12） 💬（1）<div>因为给数组分配的是连续地址，而显示的是总的地址，不管是不是连续的。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f3/9f/3e4e8d46.jpg" width="30px"><span>tyson</span> 👍（10） 💬（1）<div>堆内存100M 包含了新生代(eden+s0+1)和老年代，大对象一般分配在老年代，那么最有可能在分配过程中老年代的空间不足。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/87/57/645159ee.jpg" width="30px"><span>鹅米豆发</span> 👍（9） 💬（1）<div>可能一，新生代没有足够的连续空间，且不能直接在老年代分配。比如E+S0+S1&gt;100MB，但E&lt;100MB，S0&lt;100MB。
可能二，大对象直接进入老年代，但老年代也没有足够的连续空间。参数+XX:PretenureSizeThreshold。
可能三，线程数量太多，导致物理内存不足。
可能四，直接内存使用太多，导致物理内存不足。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg" width="30px"><span>李二木</span> 👍（4） 💬（1）<div>老师，关于这篇文章留的问题你可以给个你的答案吗？</div>2018-07-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg" width="30px"><span>代码狂徒</span> 👍（3） 💬（1）<div>老师，您是说方法区就是有永久代？那也就是说方法区在jdk8中已经不存在了？元数据区跟方法区有什么区别呢？那您的图是jdk7的图，有8得图吗？求解</div>2018-07-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg" width="30px"><span>一个坏人</span> 👍（2） 💬（1）<div>老师好，请教一个问题。JMM 模型中 各种内存分区 是逻辑分区的。JVM会根据参数计算每一块分区的起始地址、结束地址？如果会，什么时候执行这一操作呢？每一块区域有规定的顺序么？</div>2018-07-18</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/cjXFnTa1znSAGgibxB8ERicodQQRHzsp5hCfUcMM5tcJ111Wb4RDhxWURkcm9Sj3Go9Hba2qzsibaJicI8DUeQgrqQ/132" width="30px"><span>boom</span> 👍（2） 💬（1）<div>小白请教一个不相关的问题～java 内存模型跟 jvm内存模型的区别与联系是啥呢～</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/18/79/4ef1c0f5.jpg" width="30px"><span>未完的歌</span> 👍（2） 💬（1）<div>有可能是内存碎片化问题，或者是大对象的内存分配策略问题。
需要了解一下积极垃圾收集算法，例如Mark Sweep就会造成内存碎片化问题，另外内存分配策略也是一个关注点。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/32/dc/d89af1a6.jpg" width="30px"><span>Geek_6m7v5y</span> 👍（1） 💬（1）<div>老师，你好。看了文章后查一些资料。都有这段话：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 这里说的本地内存是不是和你文中说的直接内存是一个概念？</div>2018-11-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/0c/49/d71e939d.jpg" width="30px"><span>三口先生</span> 👍（1） 💬（1）<div>堆内存比例设置不合理</div>2018-07-03</li><br/><li><img src="" width="30px"><span>yotsuba1022</span> 👍（1） 💬（1）<div>關於課後練習, 由於Heap是有分代的, 所以可能當前的100M已經超過eden area的大小了, 所以儘管heap size比100M要大, 還是會無法分配內存. 這樣理解對嗎？</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/02/6f/301b1381.jpg" width="30px"><span>Roysatm</span> 👍（0） 💬（2）<div>问一个其他问题，如果开启了逃逸分析，栈上分配会不会造成栈溢出</div>2019-02-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1e/ad/ccdc7868.jpg" width="30px"><span>一凡</span> 👍（0） 💬（1）<div>老师，请问后续的章节里有对lambda的讲解么，这方面看网上的资料实在是很难理解</div>2018-07-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg" width="30px"><span>李二木</span> 👍（0） 💬（1）<div>我觉得是新生代的空间不足，因为新生代的实际可用大小占新生代总大小的90%，这是由于新生代有Eden+s1+s0组织，实际只用了eden + 1 个s</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/10/57/2738687f.jpg" width="30px"><span>A张邦卓</span> 👍（0） 💬（1）<div>堆中没有100M的连续地址了</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/da/c4/270db3ad.jpg" width="30px"><span>ZoQ-tans</span> 👍（0） 💬（1）<div>后续会到java内存模型吗？之前看了一下jsr133感觉晦涩难懂。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg" width="30px"><span>石头狮子</span> 👍（20） 💬（0）<div>1，新生代大小过小。无法分配足够的内存。同时也老年代过小，导致提升失败。这时系统认为没有足够的空间存放该100M数据。
2，栈可以抽象的看成计算资源。堆看成存储资源。计算资源不共享，不会发生线程安全问题。堆资源共享，
容易发生线程安全问题。
3，JAVA 封装了不同系统的线程模型，结果是在 java 内部有实现了一个通用的 java线程库。所以就需要用户内存来保存线程信息。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/19/78/54005251.jpg" width="30px"><span>鸡肉饭饭</span> 👍（12） 💬（0）<div>我们拿JDK7来说，有可能的原因是JVM的剩余内存有100M，但是它是分在不同年龄代的内存区域。

因此应当单独的去查看每一块eden，survivor，old的大小，(通过SurvivorRatio知道s和e的比例大小，通过MaxNewSize知道young和old的比例)看看这三块区域是否有超过100M的内存大小。如果没有，就是因为没有一个区域能够再存储一个100M的对象。

如果有，就可以通过工具查看下，每一块e s o每一块区域剩下的内存空间，如果没有一块内存大小超过100M，便是因为这个原因导致数组分配失败。</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d9/8b/76c27279.jpg" width="30px"><span>师志强</span> 👍（3） 💬（1）<div>100m的byte数组，一个byte对应一个引用，这样需要100m个的引用，所以需要的栈空间也不会低于100m,而对象的引用是在栈中分配的，(栈和堆加起来估计不低于200m)况且还是数组，对应的那么多引用还需要分配连续的内存空间，堆空间够的话，个人认为可能是栈空间不足造成的</div>2018-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f4/62/13b54c68.jpg" width="30px"><span>Steven⁰⁰⁸</span> 👍（2） 💬（0）<div>数组是连续分配的，gc表明有多余100m，但有可能满足不了连续100m的空间，故会报OOME</div>2018-07-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg" width="30px"><span>御风</span> 👍（1） 💬（0）<div>数组需要一段连续的内存空间，而链表不需要，前者更可能引发OOM</div>2021-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg" width="30px"><span>叫啥不行</span> 👍（1） 💬（1）<div>用的jdk1.8，无论开启还是关闭逃逸分析，使用jmap，对象数量少的时候，堆里面对象数量跟我创建的数量一样。
创建对象多的时候，关闭逃逸分析堆内存对象与创建的一样，但是开启后，堆内对象数量就变得很少了，这个是因为什么，有没有大佬能解答一下，谢谢。</div>2019-12-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8a/5f/c60d0ffe.jpg" width="30px"><span>硅谷居士</span> 👍（1） 💬（0）<div>老年代碎片化了。需要查看老年代的内存使用状况，对于 CMS 可以间接地看是否打开了每次 CMS GC 以后就立刻做一次碎片整理的开关。</div>2019-03-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/02/9d/902cd381.jpg" width="30px"><span>刘p辉</span> 👍（1） 💬（0）<div>1.首先堆内存是分代的，总的内存超过100M，不能保证新生代，老年代都有足够的内存。
2.为对象，数组分配内存需要连续的内存空间，有可能堆的总内存远超过要分配内存大小，但是在即使进行过垃圾回收（标记整理）后还是不存在足够的连续内存空间就会OOM。</div>2018-07-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f9/f6/108eae01.jpg" width="30px"><span>Geek_135148</span> 👍（1） 💬（0）<div>请问compressed class space区域怎么理解？是metasapce的一部分吗？如果是的话，有些采集工具为何会把它占的大小单独显示出来呢？而不直接显示metaspace的大小呢</div>2018-07-29</li><br/>
</ul>