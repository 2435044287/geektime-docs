上节课，我带你了解了缓存的定义、分类以及不足，你现在应该对缓存有了初步的认知。从今天开始，我将带你了解一下使用缓存的正确姿势，比如缓存的读写策略是什么样的，如何做到缓存的高可用以及如何应对缓存穿透。通过了解这些内容，你会对缓存的使用有深刻的认识，这样在实际工作中就可以在缓存使用上游刃有余了。

今天，我们先讲讲缓存的读写策略。你可能觉得缓存的读写很简单，只需要优先读缓存，缓存不命中就从数据库查询，查询到了就回种缓存。实际上，针对不同的业务场景，缓存的读写策略也是不同的。

而我们在选择策略时也需要考虑诸多的因素，比如说，缓存中是否有可能被写入脏数据，策略的读写性能如何，是否存在缓存命中率下降的情况等等。接下来，我就以标准的“缓存+数据库”的场景为例，带你剖析经典的缓存读写策略以及它们适用的场景。这样一来，你就可以在日常的工作中根据不同的场景选择不同的读写策略。

## Cache Aside（旁路缓存）策略

我们来考虑一种最简单的业务场景，比方说在你的电商系统中有一个用户表，表中只有ID和年龄两个字段，缓存中我们以ID为Key存储用户的年龄信息。那么当我们要把ID为1的用户的年龄从19变更为20，要如何做呢？
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg" width="30px"><span>小可</span> 👍（40） 💬（10）<div>工作中老师说的这几种缓存策略基本都用到了，特别是统计接口响应时间那个例子和我们的场景一样。管理平台统计一百多个节点的上报到队列中的数据，原来是按消费一批统计完直接批量入库，数据量太大(每秒两三千)，压力全在数据库，系统也比较卡，并且如果入库不及时就会数据积压，后续都跟不上。现在是消费统计和入库分开，消费统计先放缓存，每分钟再将缓存同步到数据库，同步成功再提交消费offset，目前看还算稳定。</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" width="30px"><span>任鹏斌</span> 👍（53） 💬（8）<div>读到这里突然想到一个开源项目https:&#47;&#47;github.com&#47;apache&#47;ignite，内存数据库，结合了关系型数据库和缓存的优点，如果只当缓存使用的话，可以自动加载和写入关系型数据库中的数据。完美解决一致性问题。但是好像国内使用的人不多。</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/a9/3ace68b6.jpg" width="30px"><span>岁寒</span> 👍（33） 💬（1）<div>缓存一定会引入不一致的。。</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg" width="30px"><span>无形</span> 👍（21） 💬（15）<div>文中提到的第一个第一个缓存和数据不一致的问题，我认为这个问题的原因是，多个客户端更新缓存和数据库之间是无序的、并发的操作，这样必然导致数据不一致的问题，因此我们采用了监听binlog的方式，把Binlog扔到消息队列中，由一个leader来消费，负责更新缓存，保证了写缓存操作之间的顺序性，保证了缓存的准确性，避免了频繁读库。</div>2019-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg" width="30px"><span>长期规划</span> 👍（16） 💬（1）<div>老师，我理解WriteBack策略相当于缓存和缓冲区合二为一了，对吧。据我所知，MySQL的buffer pool使用了WriteBack策略，但为了防止系统崩溃后数据丢失，MySQL使用了WAL（Write-Ahead Logging）机制，写先日志。好像WAL在HBase等系统也在用</div>2019-10-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/7b/ea/a64f7822.jpg" width="30px"><span>yc</span> 👍（14） 💬（2）<div>write back策略读请求时“如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中”，是不是写错了，如果缓存不是脏的，直接从缓存返回即可，为什么还要从后端记载数据到缓存然后返回？我看留言很多人都有同样的疑问，请老师解释一下，谢谢。</div>2019-10-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg" width="30px"><span>Geek_zbvt62</span> 👍（13） 💬（3）<div>Cache Aside对缓存命中率两种解决方案中的1,可能是我没看懂，感觉没解决问题啊？
这里说在“更新数据时也更新缓存”，我理解就是先更新DB再更新缓存，这样除非在更新DB之前加分布式锁，否则在更新DB之后加分布式锁，再更新缓存，依然较高可能出现不一致的情况。
实际中我们确实用在更新缓存时用分布式锁或本地锁，只不过是发现缓存为空而去读DB时，为了解决穿透问题。
纯个人见解，除了cache aside，另外两种更贴近底层系统开发而不是商业应用开发。因为我们大多数人做的系统，都是低速存储都是数据库，是有复杂的业务逻辑约束的，比如唯一性等，不是那种简单的page&#47;cpu cahce。我们经常的写操作一般都要借助数据库来检验这些约束并且在出错之后返回给用户。而如果直接与缓存打交道，且不论有些缓存的实现并不保证数据可靠性，也不能依靠缓存检验这些约束。
其实现在很多系统用的一种缓存模式是类似CQRS，写直接修改DB，异步更新到缓存，读只从缓存读数据。适合对数据不一致窗口可以容忍的场景。</div>2019-10-16</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132" width="30px"><span>程序水果宝</span> 👍（7） 💬（2）<div>使用写回策略，如果在缓存更新到数据库之前设备掉电了，那这样数据岂不是丢失了，请问这是怎么解决的呢，通过主备机制吗，缓存数据写两份？</div>2019-10-22</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLv9HJIW4OACkjlwOQJ9cU7HzvaDFYkACWCib2lzOMef9ZiaGDTVFqjPicpVK5KDRbBRVGGHrMHQO1Rw/132" width="30px"><span>fdconan</span> 👍（6） 💬（1）<div>Cache Aside（旁路缓存）策略，对于读多写少场景，当一个写操作更新db后同时删除缓存。然后多个读就会回源，这不会造成db压力么？</div>2019-10-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/db/64/f9628492.jpg" width="30px"><span>七号叽</span> 👍（6） 💬（10）<div>老师你好，请问一下write back策略为什么读请求时是“如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中”，而不是直接返回？谢谢</div>2019-10-16</li><br/><li><img src="" width="30px"><span>Geek_49305e</span> 👍（5） 💬（5）<div>老师，1. 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。   这个解决方案应该有些不严谨的地方，如有A，B两个线程，A先更新数据库的值为20，而后A获取到更新缓存的分布式的锁，但未释放锁，此时B更新数据库的值为21，更新后尝试获取锁，此时获取锁一定会失败，抛出异常，终止更新缓存。 最后缓存中的数据为A更新的的值20</div>2019-10-18</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132" width="30px"><span>饭团</span> 👍（5） 💬（4）<div>老师问您一个问题！其实如果是使用.Cache Aside方式的话。在写的时候时候因为更新数据后，删除了缓存。在高并发情况下。那么可能会出现以下情况：
主从同步的情况下，从库没来得及同步。大量的读请求返回的是从库的旧数据。而这个时候读的数据会被动写入缓存。那就存在很大的问题！这种应该怎么处理！如果是这样的话？是不是只能依靠分布式锁来实现了！
</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/23/c1/54ef6885.jpg" width="30px"><span>MoonGod</span> 👍（3） 💬（4）<div>老师请问一个问题，在cache aside策略中，如果先更新数据库，再删除缓存。这样如果读请求访问量很大，会短时间出现大量请求穿透到数据库，这里有好的办法优化吗？</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（2） 💬（1）<div>小结一下：
1：用缓存目的是为了提速，之所以能提速关键在于使用内存来存储，不过内存的特点是掉电后时会丢数据，所以，一份数据会放在DB和缓存两个地方，那么对于变化频繁的数据就会存在数据不一致的问题，缓存最适合的是静态资源或变化低频的资源
2：后面这个那个策略，都是为了解决变化频繁的数据的数据一致性问题的，在解决缓存一致性问题时会引入别的问题，比如：性能问题，复杂度问题。
3：具体怎么权衡看业务场景，不过数据一致性问题在分布式环境中是很经典和头疼的问题，因为缓存数据会引入，别的情况也会引入，比如：主从延迟</div>2020-04-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg" width="30px"><span>长期规划</span> 👍（2） 💬（1）<div>老师，写穿策略中先写缓存再同步DB，此过程若是多线程，需要加锁吧，如果不加，也存在写覆盖问题</div>2019-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg" width="30px"><span>长期规划</span> 👍（2） 💬（2）<div>Cache Aside在更新频繁时的两种解决策略应该是很经典的CAP问题吧，要保证C就要一定程度上牺牲A，反之亦然。看哪个更重要</div>2019-12-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/28/0d/558f6141.jpg" width="30px"><span>你净瞎说～</span> 👍（2） 💬（3）<div>脏是针对缓存块来说的吧？缓存也有脏不脏吗？</div>2019-10-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg" width="30px"><span>拒绝</span> 👍（2） 💬（1）<div>老师你好，请问一下write back策略为什么读请求时是“如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中”，而不是直接返回？，这里您说： 否则缓存块就可能永远是脏的了。
对此表示疑惑，既然不是脏数据，难道不是直接返回就好了？</div>2019-10-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/56/06/ea49b29d.jpg" width="30px"><span>小洛</span> 👍（1） 💬（3）<div>Cache Aside 写策略  先更新数据库后删除缓存，假设缓存不空为20    A线程去更新数据库为21，还没有及时删除缓存，这时候B线程去读取缓存就读到旧的数据20了，如果B线程读取到旧的数据后去做核心业务操作，例如金额操作就会出问题了，但是如果对A线程的整个操作“先更新数据库，再删除缓存”进行加锁，保证B线程读取到一定是A线程设置的新值，但是写多读少的场景下又对写入性能有影响，看来还是要结合业务场景来选择合适的技术解决方案。一句话缓存不简单。谢谢老师的分享！</div>2020-02-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/78/54/eee87a6b.jpg" width="30px"><span>吴冬</span> 👍（1） 💬（3）<div>老师应该实战和理论很厉害，但好像没能很好的表达出来。从头看到这个位置，给我的感觉有点平淡，亮点不多。希望老师能更好的将实力展现出来</div>2020-01-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg" width="30px"><span>小喵喵</span> 👍（1） 💬（1）<div>Read Through&#47;Write Through...策略的示意图是不是画错了？
缓存命中？否----------&gt;读缓存--------------&gt;数据库加载数据到缓存
缓存都没有命中，再去读缓存也无法命中啊。中间步骤（读缓存）是不是多余的呢？</div>2019-10-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg" width="30px"><span>Keith</span> 👍（1） 💬（4）<div>你好, 关于Write Back策略:
1. Write Back只是说明写的策略, 没有说明读的策略吧?
2. 关于&quot;我们在读到缓存数据后,...,如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。&quot;, 如果遇到连续的读操作, 缓存中的数据一直都是&quot;不是脏的&quot;, 并且每次读操作都要&quot;由缓存组件将后端存储中的数据加载到缓存中&quot;, 这样不是增加了缓存与存储之间的读次数吗? </div>2019-10-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/c5/1f/8e9ee163.jpg" width="30px"><span>良记</span> 👍（1） 💬（1）<div>今天的文章想请教老师2个问题：
1、Read &#47; Write Through里边如果用了No-write allocate策略，是不是就是和Cache Aside一样了？
2、类似今天这种例子后期会用代码写出来吗？</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg" width="30px"><span>GaGi</span> 👍（0） 💬（1）<div>对&quot;Write Back&quot;策略，我的理解是，这个策略应对的是写多的场景，但是这个策略会有丢数据的风险；
有什么可以落地可以解决丢数据的风险呢？</div>2020-04-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/73/ce/23bd3997.jpg" width="30px"><span>Wiggins</span> 👍（0） 💬（1）<div>老师你好 看了文章很久以后 其实发现write through策略其实更是让业务无感知 那想请问下 有什么好的write through的中间件么</div>2020-03-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/3a/28/cf707831.jpg" width="30px"><span>与狼共舞</span> 👍（0） 💬（1）<div>第一种比较常见，Write Back（写回）策略这个MySQL应该是用的这个思路，Read&#47;Write Through（读穿 &#47; 写穿）策略这个暂时没用到。</div>2020-03-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/69/af/ceb4450c.jpg" width="30px"><span>Asha</span> 👍（0） 💬（1）<div>老师你好 这个文章很好的解释了缓存和数据库的一致性问题 那缓存一般都是主从结构的 怎么保证从库和主库的一致性呢</div>2020-02-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg" width="30px"><span>ezekiel</span> 👍（0） 💬（1）<div>老师您好！

缓存的过期时间，这个一般怎么把握？

主要考虑哪些方面？能否举个例子？</div>2020-01-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg" width="30px"><span>空知</span> 👍（0） 💬（1）<div>write back回写入脏数据时候也是随机同步写入的,只有触发写入 且之前标记为脏才去写一条数据,性能不会比 write through快多少啊</div>2020-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg" width="30px"><span>Geek_b617bf</span> 👍（0） 💬（1）<div>我们是直接读缓存，缓存不过期，后台定时任务异步刷新mysql的数据到缓存中。前端不写只读，最大限度的提高qps</div>2019-12-26</li><br/>
</ul>