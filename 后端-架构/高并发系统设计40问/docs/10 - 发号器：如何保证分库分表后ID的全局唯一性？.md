你好，我是唐扬。

在前面两节课程中，我带你了解了分布式存储两个核心问题：数据冗余和数据分片，以及在传统关系型数据库中是如何解决的。当我们面临高并发的查询数据请求时，可以使用主从读写分离的方式，部署多个从库分摊读压力；当存储的数据量达到瓶颈时，我们可以将数据分片存储在多个节点上，降低单个存储节点的存储压力，此时我们的架构变成了下面这个样子：

![](https://static001.geekbang.org/resource/image/14/f5/14dc3467723db359347551c24819c3f5.jpg?wh=1142%2A882)

你可以看到，我们通过分库分表和主从读写分离的方式解决了数据库的扩展性问题，但是在09讲我也提到过，数据库在分库分表之后，我们在使用数据库时存在的许多限制，比方说查询的时候必须带着分区键；一些聚合类的查询（像是count()）性能较差，需要考虑使用计数器等其它的解决方案，其实分库分表还有一个问题我在[09讲](https://time.geekbang.org/column/article/145480)中没有提到，就是主键的全局唯一性的问题。本节课，我将带你一起来了解，在分库分表后如何生成全局唯一的数据库主键。

不过，在探究这个问题之前，你需要对“使用什么字段作为主键”这个问题有所了解，这样才能为我们后续探究如何生成全局唯一的主键做好铺垫。

## 数据库的主键要如何选择？

数据库中的每一条记录都需要有一个唯一的标识，依据数据库的第二范式，数据库中每一个表中都需要有一个唯一的主键，其他数据元素和主键一一对应。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg" width="30px"><span>阿杜</span> 👍（23） 💬（1）<div>不仅仅是分库分表后的数据库，很多业务场景都需要分布式发号器，使用snowflake是个很好的选择，不过一般都是用的snowflake雪花算法，实现上会有所差异，比如机器位数和序号位数的选取就不同，1+41位时间戳+10机器区间位+12号递增或随机的数字，类似这种。uuid长度过长，也不递增，使用受限。不过snowflake算法有个问题就是服务器时间回拨的问题，就是时间可能不准，这个时候不能停止发号，我觉得可以采取的方式是：每个服务器存储最新的一个maxNewId，起个线程监控服务器时间是否正确，不正确就从maxNewId递增1获取，同事调准服务器时间，直到服务器时间正确。</div>2019-12-20</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132" width="30px"><span>程序水果宝</span> 👍（19） 💬（5）<div>老师说如果我们发现系统时钟不准，就可以让发号器暂时拒绝发号，直到时钟准确为止。我们的程序本身就是运行在系统中的，如何来判断系统中的时间是否准确呢？</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/10/e8/172b5915.jpg" width="30px"><span>张珂</span> 👍（8） 💬（2）<div>老师好，想了解部署一套snowflake，性能怎么样？还有一个问题是，发号器虽然可以保证递增发号，但写入数据库时（假设有两个事务要写同一个表），那对于底层B+树也不一定顺序写入，无法利用磁盘顺序写的性能优化吧？</div>2020-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg" width="30px"><span>小喵喵</span> 👍（7） 💬（3）<div>但是当数据库分库分表后，使用自增字段就无法保证 ID 的全局唯一性了？
1.使用数据库的自增，设置起始值和步长不一样，不是一样可以实现吗？
2.预估每天的数据量，预先生成ID存入缓存（比如Redis）里面，然后去取，这种方法也简单？
</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/62/81/ad80f427.jpg" width="30px"><span>Lane</span> 👍（5） 💬（3）<div>老师我有疑问：中间的机器ID，同一毫秒内，3号机器先注册了一个用户，1号机器再注册一个用户。这样的话也不是顺序的了。</div>2020-01-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg" width="30px"><span>长期规划</span> 👍（5） 💬（1）<div>老师，序列号占12位，对应序列号最大值4096，如果一毫秒内请求生成唯一键的次数大于此值怎么办呢？我能想到的办法是当生成的序列号达到4096时，延时1毫秒，再生成。实际中，是这样处理吗？</div>2019-10-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/91/51/234f9a73.jpg" width="30px"><span>王肖武</span> 👍（5） 💬（5）<div>snowflake不能保证单调递增吧？首先，服务器的时钟可能有快有慢；其次，同一时刻，机器号大的机器生成的ID总是大于机器号小的机器，但他的请求可能是先到达了数据库。个人观点：主键还是要用数据库的自增id，另外再加个全局唯一的code作为业务主键。</div>2019-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg" width="30px"><span>stg609</span> 👍（5） 💬（3）<div>假设通过容器化来部署发号器，且同时会有多个发号器容器运行，那这个 worker Id 如何生成。容器自身的 id 是一串很长的16进制，无法转换为 worker id 吧？难道也需要引入 zookeeper 吗？有没有其他简单可行的方案？</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/4b/f3/8b9df836.jpg" width="30px"><span>jimmy</span> 👍（5） 💬（1）<div>snowflake方案中 现在一般公司都有容器虚拟化，所以每个实例都有自己的实例ID，以此作为唯一ID即可，另外保险起见在服务启动的时候可以向其他启动的服务发送check请求，确保ID全局唯一，这样可以不引入zk，让系统更简单些～</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg" width="30px"><span>helloworld</span> 👍（4） 💬（2）<div>老师，有相关的示例代码不？我的理解是每一个毫秒将下41时间戳加1，10位的机器不变，12的序列号先随机生成一个数字，然后再在这个基础上生成这一毫秒所需要的全局id的数量。不知道我理解的对不对。打卡09.</div>2019-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg" width="30px"><span>gogo</span> 👍（4） 💬（8）<div>标准的snowflake算法最多支持69年，如果项目真的支撑到69年之后，应该怎么处理呢</div>2019-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（4） 💬（2）<div>1.数据库自增的全局唯一键。可以在设计出按一定步进生成id。比如分库为3台，每台的主键id初始值分别为0、1、2自增步进为3。这样也可以唯一。不过数据库作为整个系统的吊车尾。还是别拿它搞事了。
2.如果业务没有id带有实时字段的要求，那么可以用预生成备用的方式。客户端服务每次按一定步进来拉取id集合，并缓存到客户端本地内存。如此也能有效率的提升。（哪怕有实时业务段，也可以将非业务的其他部分生成好，到客户端用时再拼接）</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/39/5b/2c893396.jpg" width="30px"><span>ET go home</span> 👍（4） 💬（1）<div>请问下同一时间位，同一机器，在生成序列号时，是要上锁的吧？</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/02/c1/80e68043.jpg" width="30px"><span>停三秒</span> 👍（3） 💬（1）<div>想知道那个机器ID如何设置，如果节点重启就再分配一个机器ID的话，那10位的机器ID也支撑不了多少次的重启啊</div>2020-03-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6c/06/2ac17d5a.jpg" width="30px"><span>yuan</span> 👍（3） 💬（4）<div>为什么snowflake的第一位一定是0？</div>2019-11-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/77/fd/c6619535.jpg" width="30px"><span>XD</span> 👍（3） 💬（1）<div>如果单纯为了保证分表之后自增主键唯一，在创建数据表的时候，配合auto_increment_offset和auto_increment_increment不就可以实现吗？（当然我不是说在微服务中不需要取号器）</div>2019-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/fa/fd/3a6d013a.jpg" width="30px"><span>朱海昆</span> 👍（3） 💬（1）<div>老师在生产上是如何处理时钟回拨的？看材料leaf是基于zookeeper 记录处理的，是不是还有其他方式？</div>2019-10-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg" width="30px"><span>Keith</span> 👍（3） 💬（2）<div>关于41位的时间戳的可支撑时间问题, 如果时间戳是从0开始计算则约可以支持69年, 但如果以当前时间开始算, 则可用的只有不到20年了(69-(2019-1970))</div>2019-10-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/65/c5/97003360.jpg" width="30px"><span>daydaynobug</span> 👍（2） 💬（1）<div>但是如果真的出现每毫秒只发一个号，不应该是末尾永远是0吗</div>2020-04-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg" width="30px"><span>长期规划</span> 👍（2） 💬（1）<div>老师，如果发号器部在一台机器上，使用多线程，那对于占12位的序号部分，在生成时，要用线程锁吧？</div>2019-10-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg" width="30px"><span>tiny🌾</span> 👍（2） 💬（3）<div>问2个问题
1.为什么第一位要保留不用？
2.如何知道时钟不对，让程序自动拒绝了？</div>2019-10-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg" width="30px"><span>longslee</span> 👍（2） 💬（1）<div>打卡。我们项目遇到一个，是想从浏览器要生成一个全局唯一ID，然后在js处理，最后post到后端记录。现实证明这样做确实有重复，所以，难道我们只能搭建一个序列号生成器服务，每次请求来，或者至少每次JS加载都调用一次，再和上面本地都一起混淆。因为是监控程序，怕序列号生成器影响到前端。</div>2019-10-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d3/6e/281b85aa.jpg" width="30px"><span>永光</span> 👍（2） 💬（1）<div>老师好，
“如果我们发现系统时钟不准，就可以让发号器暂时拒绝发号，直到时钟准确为止。”
1、那不就中断业务了？
2、话说时钟回拨是什么怎么回事呀？我看网上说是硬件层面导致的，但是还是不明白具体是怎么导致的。
3、如果发生回拨，回拨的时间大概是多少呀？
谢谢</div>2019-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/b1/75/60a71bbd.jpg" width="30px"><span>Ankhetsin</span> 👍（2） 💬（1）<div>UidGenerator和leaf-segment是不是推特雪花算法原理？</div>2019-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg" width="30px"><span>Geek_zbvt62</span> 👍（2） 💬（2）<div>id自增的解释中第一条有点牵强。加一列时间字段带来的空间影响太小了吧？用id标识时间顺序不是一个好设计啊。

现在对于雪片算法的时钟回拨问题，其实还是有不少解决方案的，比如专门划分出几位，一旦发现回拨就在这几位上顺次加一，没有必要等，等待带来的影响太大。

最后id偏斜的问题，在分库数量为N的前提下，起始值的随机函数区间范围得是N的倍数才能保证不偏斜（最好就是0到N），这就要求一旦分区数增加，服务还要调整参数</div>2019-10-09</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/RNO4yZyBvic914hewmNNE8iblYDcfv5yGHZ9OnKuCuZXNmGR0F5qV3icKLT2xpMt66GyEpicZVvrmz8A6TIqt92MQg/132" width="30px"><span>啊啊啊哦哦</span> 👍（2） 💬（2）<div>12 位的序列号代表着每个节点每毫秒最多可以生成 4096个ID，假设我生成到4097个会出现什么情况应该不到9999都可以吧。。</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/98/6b/5b9f6a3c.jpg" width="30px"><span>姜大大</span> 👍（1） 💬（1）<div>不同的机房IDC怎么获取？</div>2020-04-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/4e/f937748b.jpg" width="30px"><span>小小程序猿</span> 👍（1） 💬（1）<div>我怎么觉得snowflake就是不自增的呢？大的机器号永远大于小的机器号</div>2020-04-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0b/e2/68daf201.jpg" width="30px"><span>Alex</span> 👍（1） 💬（1）<div>之前代码中只是使用了uuid作为主键，但是像老师说的，不利于使用数据库主键索引，有时间实践一下snowflake算法。</div>2020-03-30</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/jXbwicoDwia7ooDfwBTRyvNYQkefnVwF1CMicMS8FqKfuFAdvVZo2pqc4ic0R9kSdHTIxaE6YyqxwX8BdNGv5PqSIw/132" width="30px"><span>kamida</span> 👍（1） 💬（1）<div>老师 我想问一下为什么发号器的性能可以这么好
假设我们是单机发号器 在同一毫秒内 那十二位的序列号应该被加锁吧 这样的话 同时有两个请求 发号器得一个一个的生成ID

还有一个问题是 所有业务公用一个发号器吗 然后发号器根据不同的请求来设置ID里的业务字段？</div>2020-03-20</li><br/>
</ul>