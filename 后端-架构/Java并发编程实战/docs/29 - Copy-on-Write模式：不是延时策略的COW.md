在上一篇文章中我们讲到Java里String这个类在实现replace()方法的时候，并没有更改原字符串里面value\[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。如果你深入地思考这个方法，你会发现它本质上是一种**Copy-on-Write方法**。所谓Copy-on-Write，经常被缩写为COW或者CoW，顾名思义就是**写时复制**。

不可变对象的写操作往往都是使用Copy-on-Write方法解决的，当然Copy-on-Write的应用领域并不局限于Immutability模式。下面我们先简单介绍一下Copy-on-Write的应用领域，让你对它有个更全面的认识。

## Copy-on-Write模式的应用领域

我们前面在[《20 | 并发容器：都有哪些“坑”需要我们填？》](https://time.geekbang.org/column/article/90201)中介绍过CopyOnWriteArrayList和CopyOnWriteArraySet这两个Copy-on-Write容器，它们背后的设计思想就是Copy-on-Write；通过Copy-on-Write这两个容器实现的读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。

除了Java这个领域，Copy-on-Write在操作系统领域也有广泛的应用。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/e4/d9/d74e4c61.jpg" width="30px"><span>假行僧</span> 👍（132） 💬（15）<div>没有提供CopyOnWriteLinkedList是因为linkedlist的数据结构关系分散到每一个节点里面，对每一个节点的修改都存在竟态条件，需要同步才能保证一致性。arraylist就不一样，数组天然的拥有前驱后继的结构关系，对列表的增删，因为是copy on wirte，所以只需要cas操作数组对象就能够保证线程安全，效率上也能接受，更重要的是避免锁竞争带来的上下文切换消耗。有一点需要注意的是CopyOnWriteArrayList在使用上有数据不完整的时间窗口，要不要考虑需要根据具体场景定夺</div>2019-05-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg" width="30px"><span>欢乐小熊</span> 👍（66） 💬（1）<div>我对课后的思考是这样的, ArrayList 是用是数组实现的, 在内存上时一块连续的区域, 拷贝时效率比较高, 时间复杂度为 O(1)

LinkedList 是链表实现, 其数据是通过指针串联起来的, 并非一块连续的区域, 拷贝时必须要进行遍历操作, 效率比较低, 时间复杂度是 O(n)</div>2019-09-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg" width="30px"><span>夏天</span> 👍（13） 💬（6）<div>王老师，问一个单例模式的问题： 在双重检查加锁的单例模式中 需不需要加 volatile 关键字修饰？ 自己的理解：是需要。但是我在考虑其中的锁是不是存在happen before规则，不用加volatile也能保证可见性？</div>2019-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/44/1d/833b3890.jpg" width="30px"><span>刘infoq</span> 👍（8） 💬（2）<div>服务下线了，如果数据不一致，会不会有请求发到下线了的服务器</div>2019-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg" width="30px"><span>DFighting</span> 👍（6） 💬（1）<div>主要是ArrayList的数据存储是数组，复制可能只需要移动一个内存页或者多个连续的内存空间就可以，而且数组在复制的时候是知道数据集的大小的(动态扩容后也还是数组，只是预先申请了一些未来使用的空间)，而LinkdList底层实现为使用Node&lt;?&gt;链表，存储位置分散且大小不可控，如果使用COW可能会适得其反。这应该也是一种用空间换时间的策略吧。这么来看，除非事先限定了数据的存储区域，不然用COW还是数组方便些吧。</div>2019-09-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg" width="30px"><span>与路同飞</span> 👍（4） 💬（1）<div>redis中的快照rdb复制也是基于COW的</div>2020-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg" width="30px"><span>静水流深</span> 👍（3） 💬（1）<div>大师好不容易写了个CopyOnWriteArrayList，再写一个CopyOnWriteLinkedList 他觉得没必要。他也累：）

</div>2019-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg" width="30px"><span>张三</span> 👍（2） 💬（1）<div>上一篇说包装类型、String 是享元模式，这篇说是Copy-on-Write，是两种模式都有吗？</div>2019-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg" width="30px"><span>1620</span> 👍（1） 💬（1）<div>数组在内存地址是连续的，天然适合copy，链表是分散的。</div>2019-10-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg" width="30px"><span>yang</span> 👍（1） 💬（1）<div>Sting Long … 居然可以和CoW、Lock联系起来!

跟着老师默默修行!

希望这个专栏永远不要停!
能希望能一直看到老师写的专栏!</div>2019-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg" width="30px"><span>cake</span> 👍（0） 💬（1）<div>不是延时策略的COW 老师请问下这个标题怎么 理解呢， cow不就是延时策略么</div>2021-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg" width="30px"><span>张申傲</span> 👍（0） 💬（1）<div>Redis 的 bgsave 过程也采用了 COW 模式：子进程生成 rdb 快照的过程中，如果主进程修改了某份数据，那么这份数据会生成一份副本，子进程会把这个副本写入 rdb 快照中。这样基于 COW 模式，保证了Redis 在生成 rdb 快照的过程中仍然能够提供写服务。</div>2021-03-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/f3/b2/1ce2ae4d.jpg" width="30px"><span>worm</span> 👍（0） 💬（1）<div>增加路由的那个方法感觉好像有问题，每次都会new CopyOnWriteArraySet,但是没有把原来CopyOnWriteArraySet里的值复制进去，只是单独增加了一个新router啊，还是我理解有误</div>2020-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg" width="30px"><span>夜涛</span> 👍（0） 💬（1）<div>LinkedList分配的内存不连续，读写操作性能不高，ArrayList复制一次复制一个地址块，那么LinkedList就要复制N个，还要一个个去找，不适合并发场景</div>2020-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg" width="30px"><span>与路同飞</span> 👍（0） 💬（1）<div>老师好。好多开源项目这样写。我知道是基于COW，Map&lt;String, Object&gt; newMap = new HashMap&lt;&gt;(oldMap.size() + 1);
newMap.putAll(oldMap);
oldMap = newMap。但是为啥不用concurrentHashMap呢</div>2020-09-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg" width="30px"><span>sky</span> 👍（0） 💬（1）<div>有个疑问，对于路由表场景，实时性要求不高，那么用普通的hashset 是会有并发写的问题么？如果是只对写加个锁是不是就可以了，也不用复制元素，读不加锁，性能会差么？</div>2020-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg" width="30px"><span>WL</span> 👍（0） 💬（1）<div>请问一下老师copyonwrite如果与volatile结合使用是不是就可以实现强一致性了？</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg" width="30px"><span>GeekAmI</span> 👍（149） 💬（9）<div>CopyOnWriteLinkedList的链表结构读取效率比较低，就违背了读多写少的设计初衷。</div>2019-05-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg" width="30px"><span>Knight²º¹⁸</span> 👍（50） 💬（5）<div>很多童鞋提到了链表copy的代价，个人觉得这并不是最根本的原因。首先数组无论的新增还是删除copy是避免不了的，因此我们采用copy on write的方式在保证代价相当的前提下保证了并发的安全问题，何乐而不为呢。其次是链表的新增删除压根就不需要复制，就算是在并发场景下采用锁的方式性能损耗都不大，因此也就没必要采用copy的方式了，更何况链表的操作可以采用分段锁、节点锁。所以没有CopyOnWriteLinkedList的主要原因是没有这个必要。</div>2019-05-06</li><br/><li><img src="" width="30px"><span>好牙</span> 👍（21） 💬（0）<div>1.链表本身适合于顺序读和写多的场景，和cop读多写少是违背的。
2.链表可以锁节点，力度已经很小了。
3.链表整体复制的性能比数组差太多。</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg" width="30px"><span>Corner</span> 👍（15） 💬（0）<div>数组的拷贝效率应该比链表高，一维数组是连续分配内存的，所以可以直接复制内存块就能完成拷贝。但是链表元素之间是通过引用建立连接的，所以要遍历整个链表才能完成拷贝。</div>2019-05-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg" width="30px"><span>ban</span> 👍（5） 💬（0）<div>一种是通过更新 Router 的一个状态位来标识，如果这样做，那么所有访问该状态位的地方都需要同步访问，这样很影响性能。

老师好，这句话的意思没怎么看懂，我理解的是route如果下线后更新状态标识，所以每次调用的时候都需要遍历所以route节点，判断每个节点的状态来判断是否下线，所以比较消耗性能的意思吗？所以改成方法二只要下线即删除改route节点，调用的时候不需要判断，只要路由表查到即算都是上线状态。

</div>2019-05-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg" width="30px"><span>Darren</span> 👍（2） 💬（0）<div>LinkedList 在复制时，因为其包含前后节点地址，每个节点需要去创建，成本比较高，所以很少或者没有写时复制的Linked 结构吧</div>2019-05-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg" width="30px"><span>呆瓜</span> 👍（1） 💬（0）<div>数组存储在连续内存,连续内存更有利于CPU加载和缓存,特点是增删慢,读取快;
链表数据结构存储在分散内存,特点是增删快,读取慢;
链表结构的设计初衷就是用于增删频繁,读取少的场景;
CopyOnWrite使用场景:要求读取性能高,读取多,修改少;
二者设计理念相违背,所以存在CopyOnWriteArrayList,而不存在CopyOnWriteLinkedList</div>2021-01-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg" width="30px"><span>Mr.wang</span> 👍（1） 💬（0）<div>ArrayList和LinkedList的区别就是ArrayList底层的数据结构是数组实现，而LinkedList的底层是双端链表实现。两者适宜使用的场景是，ArrayList多用于查询，而LinkedList多用于增加和删除的场景中，CopyAndWrite的使用场景主要是查询大于新增和删除的场景。</div>2020-03-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" width="30px"><span>Monday</span> 👍（1） 💬（0）<div>老师好，请问：如案例，正常情况下一个服务提供方应该提供多个接口，是对应多个Router对象？所以一个服务提供方上&#47;下线，应该会循环调用多次add&#47;remove方法？</div>2019-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg" width="30px"><span>风翱</span> 👍（1） 💬（0）<div>Copy-on-Write方案是适合读多写少的场景，而LinkedList读取的性能不高，这个应该是没有提供CopyOnWriteLinkedList的主要原因。
</div>2019-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/02/42/abb7bfe3.jpg" width="30px"><span>污名侦探</span> 👍（1） 💬（0）<div> 首先CopyOnWriteLinkedList 可以做分段锁，并且性能很高。其次，复制性能没有数组来的快。</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" width="30px"><span>Vincent</span> 👍（1） 💬（0）<div>既然读多写少，说明数据结构变更频率很少。那么数组结构适合这个场景，链表是适合写多的场景</div>2019-05-16</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132" width="30px"><span>周治慧</span> 👍（1） 💬（0）<div>本质就是数组查询块增删慢，链表增删块查询慢。copyandwrite本质就是读多写少即查询多增删少的一个过程所以数组更加合适</div>2019-05-05</li><br/>
</ul>