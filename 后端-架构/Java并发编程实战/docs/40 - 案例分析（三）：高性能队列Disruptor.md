我们在[《20 | 并发容器：都有哪些“坑”需要我们填？》](https://time.geekbang.org/column/article/90201)介绍过Java SDK提供了2个有界队列：ArrayBlockingQueue 和 LinkedBlockingQueue，它们都是基于ReentrantLock实现的，在高并发场景下，锁的效率并不高，那有没有更好的替代品呢？有，今天我们就介绍一种性能更高的有界队列：Disruptor。

**Disruptor是一款高性能的有界内存队列**，目前应用非常广泛，Log4j2、Spring Messaging、HBase、Storm都用到了Disruptor，那Disruptor的性能为什么这么高呢？Disruptor项目团队曾经写过一篇论文，详细解释了其原因，可以总结为如下：

1. 内存分配更加合理，使用RingBuffer数据结构，数组元素在初始化时一次性全部创建，提升缓存命中率；对象循环利用，避免频繁GC。
2. 能够避免伪共享，提升缓存利用率。
3. 采用无锁算法，避免频繁加锁、解锁的性能消耗。
4. 支持批量消费，消费者可以无锁方式消费多个消息。

其中，前三点涉及到的知识比较多，所以今天咱们重点讲解前三点，不过在详细介绍这些知识之前，我们先来聊聊Disruptor如何使用，好让你先对Disruptor有个感官的认识。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/94/1e/973cda79.jpg" width="30px"><span>Juc</span> 👍（56） 💬（2）<div>希望老师解释下，为什么创建元素的时间离散会导致元素的内存地址不是连续的?这些元素不是存在数组中的吗？数组初始化不是已经连续分配内存了吗？</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg" width="30px"><span>万历十五年</span> 👍（23） 💬（1）<div>单机提升性能不外乎是围绕CPU，内存和IO想办法。
CPU: 
1.避免线程切换：单线程，对于多线程进行线程绑定，使用CAS无锁技术
2.利用CPU缓存，还有缓存填充，设计数据结构和算法
内存：
1.多级缓存：应用缓存，第三方缓存，系统缓存
2.数组优于链表
3.避免频繁内存碎片：利用池思想复用对象
解决IO产生的速度差:
1.多路复用
2.队列削峰
3.协程</div>2020-12-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg" width="30px"><span>冰激凌的眼泪</span> 👍（23） 💬（5）<div>前后56个字节保证了目标字段总是独占一个cache line，不受周围变量缓存失效的影响</div>2019-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg" width="30px"><span>惘 闻</span> 👍（18） 💬（2）<div>if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)这个位置的判断原本不明白,看了几遍总算是明白了.    环形队列,生产者从0生产 消费者从0消费.  wrapPoint是指生产了一圈 又达到了 消费者消费的最小的位置   如果此时继续生产,那么消费最少的消费者还未消费的消息将会被生产者覆盖,所以此处要停止.  而 最小消费位置大于生产者当前生产位置的话,说明消费到了生产者还未生产消息的位置,所以等待消息的生产,要停止.</div>2020-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f3/7f/2dd9409b.jpg" width="30px"><span>xinglichea</span> 👍（5） 💬（1）<div>老师，感觉填充的模式不是很靠谱，程序的健壮性要强依赖于CPU的缓存行的实现，打个比如，如果以后CPU缓存行变成了128个字节，那企不要写Disruptor的实现源码，然后原来实现的代码仍然会有伪共享的问题！！！</div>2019-08-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/00/67/e24dd940.jpg" width="30px"><span>那月真美</span> 👍（3） 💬（1）<div>老师，数组内存地址连续，数组里面的引用对象怎么做到连续呢？它不是由生产者产生的吗？何时生产只能由生产者决定，初始化数组的时候怎么一次性初始化数组元素啊？</div>2020-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg" width="30px"><span>张洋</span> 👍（2） 💬（1）<div>1.if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current) 这点开始一直没看懂，之前写过环形队列，每次索引都会重置，就是一直在0-9之间，然后看了下RingBuffer 好像它的索引是一直累加的。这样就好懂多了。
2.关于ArrayBlockQueue 添加的对象是不连续的还是不太明白，数组初始化 不是在内存种开辟出一段连续的内存空间吗？ 还是按照有的同学留言所说的，如果是引用对象不一定是连续的。</div>2020-12-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg" width="30px"><span>荷兰小猪8813</span> 👍（2） 💬（2）<div>ArrayBlockingQueue 的入队和出队操作是用锁来保证互斥的，所以入队和出队不会同时发生。如果允许入队和出队同时发生，那就会导致线程 A 和线程 B 争用同一个缓存行，这样也会导致性能问题。

想问下加锁了就没有缓存干扰了吗！为啥？</div>2019-11-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg" width="30px"><span>码农Kevin亮</span> 👍（1） 💬（1）<div>老师，避免伪共享的逻辑有点困惑：
伪共享逻辑上就是没实现共享，而disruptor用行填充也是没实现共享。那么为什么避免伪共享就能提升性能呢？</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg" width="30px"><span>全麦小面包</span> 👍（0） 💬（1）<div>老师，有个问题哈。Disruptor创建的event不是业务数据类，里面set的东西才是业务需要的。但set对象的创建还是离散的，难道set对象的引用，能和event一起缓存？？java有这种机制吗？</div>2022-07-26</li><br/><li><img src="" width="30px"><span>Geek_8593e5</span> 👍（0） 💬（1）<div>请问下老师，这个队列可以用于替换ArrayBlockingQueue的场景对吧？还有一些什么场景可以用呢？</div>2022-02-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/1c/1b/dceaa378.jpg" width="30px"><span>于是</span> 👍（0） 💬（1）<div>disruptor中的数组结构，如果我放入一个引用对象，这个被引用对象的内存地址已经确定了。是需要拷贝到他创建的那段连续内存中吗？</div>2020-04-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg" width="30px"><span>空知</span> 👍（0） 💬（1）<div>老师问下 
缓存行填充之后，缓存行里加载的不是真实需要的数据 是填充数据  程序局部性会不会不适用了? </div>2019-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（0） 💬（1）<div>厉害了我的哥，尽然看懂了，又学到了谢谢老师</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg" width="30px"><span>LW</span> 👍（12） 💬（0）<div>RingBuffer是一个环形队列？</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg" width="30px"><span>孙志强</span> 👍（10） 💬（8）<div>程序局部性原理的空间局部性是不是cpu分支预测?缓存行一般是64字节,takeIndex那为何前后填充56个字节,大于64了,怎么独占缓存行?</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg" width="30px"><span>晓杰</span> 👍（8） 💬（0）<div>mysql也利用了程序的局部性原理来减少磁盘的io，百度开源的分布式唯一id生成器也使用了RingBuffer，将提前生成的id缓存到RingBuffer中。</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg" width="30px"><span>😜哈哈</span> 👍（6） 💬（2）<div>小米将disruptor用于秒杀场景</div>2020-03-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d3/cb/f8157ad8.jpg" width="30px"><span>爱吃回锅肉的瘦子</span> 👍（4） 💬（0）<div>难度指数提升😔只能得多看几遍</div>2019-06-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg" width="30px"><span>锦</span> 👍（4） 💬（1）<div>disruptor高性能主要是以下几点设计：
1，仅维护一个共享变量(入队索引)，减少锁竞争，并利用填充行技术解决共享变量的伪共享问题。
2，底层使用循环数组作为存储结构，开辟一组连续的内存空间，循环利用减少gc次数，并充分利用了程序局部性原理。
3，入队时支持一次性获取多个索引，然后在当前线程写入数据，减少锁竞争，消费时一样。
不知道我理解的对不对？</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（2） 💬（0）<div>有个地方没看懂，if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)，这个条件里面，为何需要cachedGatingSequence&gt;current这个限制呢？
是当current突破最大值变为0之后，要等到cachedGatingSequence追上来才继续生产吗？</div>2019-08-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg" width="30px"><span>郑晨Cc</span> 👍（2） 💬（0）<div>全他妈的是干货 满足！</div>2019-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg" width="30px"><span>junshuaizhang</span> 👍（1） 💬（0）<div>看到最后，我感觉自己拿了一个假学历</div>2020-07-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg" width="30px"><span>行者</span> 👍（1） 💬（0）<div>关于伪共享，可以参考这篇文章
https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;109874</div>2020-06-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg" width="30px"><span>青铜5 周群力</span> 👍（1） 💬（0）<div>对内存优化部分有质疑:
1申请内存要经过jvm，经过操作系统，经过层层的优化、内存管理，填充缓存行有没有用只靠逻辑推理是推理不出来的吧，有没有数据证明这个技术真的有用?
2.预先申请所有元素对象真的有用吗，因为每个元素引用的数据对象还在离散的内存空间，取数据对象还要访问内存，会发生cache line淘汰。所以有什么数据能证明这个技术有用吗</div>2019-07-31</li><br/><li><img src="http://thirdqq.qlogo.cn/qqapp/101418266/D6DD8CB1004D442B48914656340277F3/100" width="30px"><span>henry</span> 👍（1） 💬（0）<div>我用过apache storm，之前想了解底层原理，在网上查资料说是用到了disruptor, 然后看到网上的资料说它快的原因就是用到了伪共享，但是网上都没有说到点上，就是把伪共享的原理说了一遍。。。看的云里雾里的，看了老师的文章总算是明白了，主要是针对入队和出队索引，让它们分别独占行，不够字节数的补全</div>2019-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg" width="30px"><span>张三</span> 👍（1） 💬（0）<div>打卡！</div>2019-05-30</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132" width="30px"><span>walle斌</span> 👍（0） 💬（0）<div>当时一看Disruptor的时候 第一个感觉是 类似tomcat的对象池技术，空间换时间性能优势，再看 Disruptor更优化 get~</div>2024-12-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/93/d4/dd2ee398.jpg" width="30px"><span>刘凯</span> 👍（0） 💬（2）<div>解决伪共享填充方式和局部性原理感觉是互相矛盾的，Disruptor是怎么平衡这个关系的</div>2023-01-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg" width="30px"><span>大海</span> 👍（0） 💬（0）<div>对于 ”当 CPU 从内存中加载 takeIndex 的时候，会同时将 putIndex 以及 count 都加载进 Cache。“ 文中的这句话我有一个小疑惑，ArrayBlockingQueue 对象初始化之后，takeIndex，putIndex，count 等其他属性的内存地址一定会是相邻的吗？
如果不相邻，这些属性就可能不在同一个 Cache Line 上，伪共享问题可能就出现的没有那么频繁。</div>2022-11-24</li><br/>
</ul>