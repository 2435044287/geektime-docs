很多同学反馈说，工作了挺长时间但是没有机会接触并发编程，实际上我们天天都在写并发程序，只不过并发相关的问题都被类似Tomcat这样的Web服务器以及MySQL这样的数据库解决了。尤其是数据库，在解决并发问题方面，可谓成绩斐然，它的**事务机制非常简单易用**，能甩Java里面的锁、原子类十条街。技术无边界，很显然要借鉴一下。

其实很多编程语言都有从数据库的事务管理中获得灵感，并且总结出了一个新的并发解决方案：**软件事务内存（Software Transactional Memory，简称STM）**。传统的数据库事务，支持4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是大家常说的ACID，STM由于不涉及到持久化，所以只支持ACI。

STM的使用很简单，下面我们以经典的转账操作为例，看看用STM该如何实现。

## 用STM实现转账

我们曾经在[《05 | 一不小心就死锁了，怎么办？》](https://time.geekbang.org/column/article/85001)这篇文章中，讲到了并发转账的例子，示例代码如下。简单地使用 synchronized 将 transfer() 方法变成同步方法并不能解决并发问题，因为还存在死锁问题。
<div><strong>精选留言（26）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/c5/09c2dd48.jpg" width="30px"><span>M$画像</span> 👍（22） 💬（1）<div>希望王老师再出新品，一定支持。</div>2019-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg" width="30px"><span>小文同学</span> 👍（20） 💬（9）<div>谢谢老师推荐STM，我所在的游戏项目一直有对象异步入库的需求，为了使用异步入库，放弃了Spring针对数据库的事务。为此不得不编写大量代码去判断某个操作是否可以执行，希望软件事务内存可以为我的需求提供一个新的解决方案。最近几天开始研究相关源码了，希望可以较好的结合现有项目，有可以发布的成果一定在留言区为大家共享。</div>2019-09-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg" width="30px"><span>helloworld</span> 👍（6） 💬（4）<div>按照老师自己实现的STM程序，根本不存在commit提交失败的时候吧？因为每一次的commit都是新创建一个STMTxn，新创建STMTxn后，inTxnMap和writeMap都是新的。不知道我考虑的对不对？？</div>2019-09-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg" width="30px"><span>黄海峰</span> 👍（2） 💬（1）<div>代码里硬是没看到哪里修改了version。。</div>2019-06-06</li><br/><li><img src="" width="30px"><span>Geek_039a5c</span> 👍（1） 💬（1）<div>代码还有有点小问题。 STM  这个类的代码 花括号写的不对。 </div>2022-02-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/1f/13/4647402a.jpg" width="30px"><span>纷繁的烟火</span> 👍（1） 💬（1）<div>最后段代码的 构造参数里的txn在哪呀 找也找不到</div>2020-01-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/99/4a/bdf26d5c.jpg" width="30px"><span>石头汤</span> 👍（0） 💬（1）<div>是不是 STM.atomic 的 TxnRunnable 的实现必须是幂等的，否则 while 循环那里会产生脏数据？</div>2020-06-11</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132" width="30px"><span>有铭</span> 👍（0） 💬（1）<div>老师，关系数据库也是有死锁的，只是他们往往实现了死锁检测机制，死锁到一定时间就会强制解锁</div>2019-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/8a/cc/da9adc82.jpg" width="30px"><span>小太阳</span> 👍（12） 💬（2）<div>看了三遍，终于看懂了，很妙。原来精华就在这一段：MVCC 可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过变化，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个时候是不可以提交的。Txn负责维护检测快照，TxnRef负责包装数据使之可以接入Txn，作为快照的key。VersionedRef负责包装数据使之有版本。   另外，最后的代码里忘了判断余额是否够用了。😁</div>2020-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg" width="30px"><span>松小鼠</span> 👍（11） 💬（5）<div>我公司用的就是这个解决并发问题的，才知道是这种技术</div>2019-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg" width="30px"><span>DFighting</span> 👍（8） 💬（0）<div>STM的优化有一点是针对大快照的优化吧，因为MySQL对数据库的快照并不是真正存储一份备份数据，类似例子中的map，而是利用version和undolog计算得到的，不然一个100G大小的数据库，每开启一个事物就拷贝一份数据，肯定是不现实的。</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/27/db/c8b35c07.jpg" width="30px"><span>林添</span> 👍（5） 💬（3）<div>照着实现了一遍，确实可以巧妙。
我觉得类STMTxn的get函数可以改进一下：现在get返回的值，只是最初始的值，如果当前事务更改了值，然后再调用get，最好可以返回最新的值；即当前事务的更改，对自己是可见的。
```
    @Override
    public &lt;T&gt; T get(TxnRef&lt;T&gt; ref) {
        if (!inTxnMap.containsKey(ref)) {
            inTxnMap.put(ref, ref.curRef);
        }

        if (writeMap.containsKey(ref)) {
            return (T) writeMap.get(ref);
        }
        else {
            return (T) inTxnMap.get(ref).value;
        }
    }
```</div>2019-08-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/3d/13/275f9698.jpg" width="30px"><span>青菜</span> 👍（1） 💬（0）<div>老师，理解在提交时版本号都是一样的，都是0，即使修改了也没去修改版本号啊，所以不管怎样都能提交</div>2020-08-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（1） 💬（0）<div>哔，打卡，涨知识了</div>2019-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/38/9f/895353ab.jpg" width="30px"><span>黄卫江</span> 👍（0） 💬（0）<div>核心点：inMap记录所有事务内读取过的值，writeMap暂存所有值的新值，由于inMap的key的curRef是不可变的，所以如果有其他事务改过了值就会找到inMap中的curRef和一开始设置的inMap的value不是一个对象（键值对的值永远是一开始写入的对象）</div>2023-05-21</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL23Wicb0gO9RIXrRzpettuEYaSHLicA2LgRz3X7Npiagf1R4aB9bmePt1TY006z63ngKzhEONZvOsfw/132" width="30px"><span>Geek_aa23b7</span> 👍（0） 💬（0）<div>感觉这个原理和cas有点像，都是先尝试更新，然后真正更新的时候根据版本号判断是否被其他线程变更过，没有发生变更过，则更新成功。核心要点就在于正真更新的时候要加锁或者原子操作</div>2022-09-24</li><br/><li><img src="" width="30px"><span>Geek_d1026b</span> 👍（0） 💬（0）<div>老师 完整的代码在哪里可以下载</div>2022-04-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg" width="30px"><span>小黄鸭</span> 👍（0） 💬（0）<div>我终于终于看懂了，老师太厉害了！！</div>2022-01-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg" width="30px"><span>Tomy</span> 👍（0） 💬（1）<div>用@Trasaction不可以吗，我们的项目都是用这个的</div>2021-10-22</li><br/><li><img src="" width="30px"><span>dominiczhu</span> 👍（0） 💬（0）<div>老师您好，我想请问一下，看了之前的转账实现与这个txn转账实现，是不是也会存在着之前提到的问题，例如全部线程都共享了同一把锁，高并发可能扛不住；while()循环也可能导致高cpu消耗之类的。</div>2021-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/08/b8/ac8a778e.jpg" width="30px"><span>我得儿意的笑</span> 👍（0） 💬（0）<div>
&#47;&#47;构造函数，自动生成当前事务ID  STMTxn() {    txnId = txnSeq.incrementAndGet();  }
    StmTxn() {
        this.txnId = StmTxn.txnSeq.incrementAndGet();
    }</div>2021-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg" width="30px"><span>Geek_41d472</span> 👍（0） 💬（1）<div>有没有和我一样懵逼的,版本号怎么看,所有的的版本号都是0啊,是我眼花了吗</div>2020-07-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg" width="30px"><span>悟空</span> 👍（0） 💬（1）<div>老师，private Map&lt;TxnRef, VersionedRef&gt; inTxnMap = new HashMap&lt;&gt;(); 这个是不是应该是静态的。在多个事物中共享，这样一个事物变更了，其他事物才能知晓</div>2019-07-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg" width="30px"><span>Rancood</span> 👍（0） 💬（0）<div>感觉没有前面容易理解了</div>2019-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg" width="30px"><span>张三</span> 👍（0） 💬（0）<div>打卡！这篇高质量！</div>2019-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d3/cb/f8157ad8.jpg" width="30px"><span>爱吃回锅肉的瘦子</span> 👍（0） 💬（0）<div>涨见识了，谢谢老师。</div>2019-06-06</li><br/>
</ul>