实际工作中，我们总会难免和数据库打交道；只要和数据库打交道，就免不了使用数据库连接池。业界知名的数据库连接池有不少，例如c3p0、DBCP、Tomcat JDBC Connection Pool、Druid等，不过最近最火的是HiKariCP。

**HiKariCP号称是业界跑得最快的数据库连接池**，这两年发展得顺风顺水，尤其是Springboot 2.0将其作为**默认数据库连接池**后，江湖一哥的地位已是毋庸置疑了。那它为什么那么快呢？今天咱们就重点聊聊这个话题。

## 什么是数据库连接池

在详细分析HiKariCP高性能之前，我们有必要先简单介绍一下什么是数据库连接池。本质上，数据库连接池和线程池一样，都属于池化资源，作用都是避免重量级资源的频繁创建和销毁，对于数据库连接池来说，也就是避免数据库连接频繁创建和销毁。如下图所示，服务端会在运行期持有一定数量的数据库连接，当需要执行SQL时，并不是直接创建一个数据库连接，而是从连接池中获取一个；当SQL执行完，也并不是将数据库连接真的关掉，而是将其归还到连接池中。

![](https://static001.geekbang.org/resource/image/0b/19/0b106876824e43d11750334e86556519.png?wh=1142%2A511)

数据库连接池示意图

在实际工作中，我们都是使用各种持久化框架来完成数据库的增删改查，基本上不会直接和数据库连接池打交道，为了能让你更好地理解数据库连接池的工作原理，下面的示例代码并没有使用任何框架，而是原生地使用HiKariCP。执行数据库操作基本上是一系列规范化的步骤：
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg" width="30px"><span>空知</span> 👍（67） 💬（3）<div>线程本地的连接会被窃取   
这个我觉得是因为 如果 Tl里面没有空闲的 会去 sharedList查找处于 Not_In_Use的连接 这个连接可能已经在其他TL里面存在了 所以就会出现线程T2从sharedList获取到了 T1存在TL里面存放的没有使用的连接这种情况</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg" width="30px"><span>拯救地球好累</span> 👍（63） 💬（1）<div>支持高性能并发的软件通常首先会关注整体的并发设计模式，并发设计模式将影响整个软件的设计架构，比如RateLimiter并非采用较为复杂的生产者消费者模式，而是用细粒度的互斥锁来实现令牌桶算法；Netty采用了Reactor模式而非阻塞的等待-通知机制的一些实现。对设计模式的考量应当根据实际需求先考虑线程分工，再从避免共享的模式考虑到一些无锁的模式，再到细粒度的锁控制，再到复杂的同步和互斥模式。
从高性能队列和高性能数据连接池中，可以看到，性能的提高通常会从几方面着手（实际场景中应当测试优于猜测，再根据阿姆达尔定律从性能瓶颈处先着手）：并发设计模式；内存分配算法；缓存利用率；GC情况（有GC的语言）；数据结构与算法的效率等。
</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg" width="30px"><span>晓杰</span> 👍（18） 💬（1）<div>同问为什么线程本地的会被其他线程窃取，麻烦老师解释一下</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg" width="30px"><span>Simple life</span> 👍（2） 💬（1）<div>看了第二遍，有个疑问，在一半WEB项目中，每次请求SPRING都新建一个线程服务，所以ThreadLocal中的线程并不能重用，这块性能提升就无效了，都去COW中CAS获取可用线程了，CAS在高并发环境中表现并不好</div>2020-08-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg" width="30px"><span>yang</span> 👍（2） 💬（1）<div>老师， 我看文中提到的是调用requite()释放链接的时候将这个链接添加到本地存储中。
那我想问，如果不是调用requite()方法释放连接的情况下，这个连接第一次被放入threadlocal是什么时候啊？ 是第一次获取连接的时候吗？</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" width="30px"><span>Monday</span> 👍（1） 💬（1）<div>又来打一次卡，配合代码和debug</div>2021-05-22</li><br/><li><img src="" width="30px"><span>poordickey</span> 👍（1） 💬（1）<div>这里讲的是连接池  但是很想知道一个数据库连接从拿到到归还的整个过程细节，从一个连接池拿到一个连接，connect之后，执行了SQL，并close了，归还到线程池之后又是怎么一直和数据库保持连接的呢</div>2021-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg" width="30px"><span>张德</span> 👍（1） 💬（1）<div>强烈建议老师再讲一期  </div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/51/97/936944e6.jpg" width="30px"><span>yellow</span> 👍（0） 💬（1）<div>老师你好，请问释放的连接，如果没有，仅仅被保存到线程本地存储中，为什么不需要同时被重新保存到sharedList中呢？
不重新保存到sharedList中，别的线程还怎么有机会拿得到这个连接呢？</div>2022-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg" width="30px"><span>DFighting</span> 👍（0） 💬（1）<div>注意到了requite()的一个细节优化，自己使用完了线程后并不是直接交还给线程池，而是先问下有没有其他线程等待，如果有，那么直接分配就好，这里就减少了一个线程上下文切换带来的损失。不过这里的threadList应该只是会使用线程池的连接，不可以在这个连接上做一些自己数据的存储，因为如果这样就会给每次连接的归还时执行一次清洗工作，想来也会是一次性能的浪费吧。老师，关于连接池源码怎么看啊，像实践下今天课堂上学到的内容，但是不只如何下手</div>2019-10-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（0） 💬（1）<div>根本看不够，强烈建议老师再来一篇</div>2019-06-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a0/42/88e70d61.jpg" width="30px"><span>阿健</span> 👍（10） 💬（1）<div>同问，为什么说线程本地的连接会被窃取呢？</div>2019-06-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/73/4f/abb7bfe3.jpg" width="30px"><span>沙漠里的骆驼</span> 👍（6） 💬（0）<div>窃取是在获取本地链接失败时，遍历sharelist实现的</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" width="30px"><span>峰</span> 👍（5） 💬（0）<div>想了半天感觉ConcurrentBag应该是池化的一种通用性优化，但好像会有饥饿问题，如果某些线程总是占用连接，那么某些不经常占用连接的就可能一直拿不到连接，硬想的一个缺点，哈哈哈。</div>2019-06-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/dc/e2/a3abd320.jpg" width="30px"><span>Just</span> 👍（3） 💬（0）<div>这个ThreadLocal和JVM内存分配的TLAB（Thread local allocation buffer）还是有点像，先从本地获取，没有的话再去申请</div>2020-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/48/f3/65c7e3ef.jpg" width="30px"><span>cricket1981</span> 👍（2） 💬（2）<div>可以用栈stack来代替list实现逆序关闭S6~S1吗？</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg" width="30px"><span>sky</span> 👍（1） 💬（2）<div>for (int i = list.size() - 1; i &gt;= 0; i--) { final Object entry = list.remove(i);

遍历的同时删除 会报 currentModityException吧

另外没看懂为啥需要handoffQueue, 直接从share 里拿 和 threadLocal 里拿不行么</div>2020-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg" width="30px"><span>Geek_89bbab</span> 👍（1） 💬（0）<div>threadList里面的连接可能也会存在于多个threadList,但是概率相对较小；threadList的连接的remove操作都由本线程来执行，窃取的线程只会把标识设置为已使用，而不会将其从对应的那个threadList移除。可能是为了避免多线程操作同一个队列,而影响性能。所以把移除threadList里的连接的任务交给对应的那个线程。</div>2019-06-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fd/89/cbca1b8e.jpg" width="30px"><span>银时空de梦</span> 👍（1） 💬（1）<div>最后数据库连接都到线程本地池中了</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg" width="30px"><span>天天有吃的</span> 👍（0） 💬（0）<div>打卡，我看到这就不往下细看了，比较重要的内容到41。说一下感受，并发从开始学java就接触了，最大的问题是不系统，比如学了Lock不懂属于哪块下面的，这门课很好的让我把结构梳理一遍， 1.线程基础（Thread..）- 2.并发问题 - 3.原生关键字（volatile syn final..）- 4.并发包（Lock 并发容器..） - 5.案例。
按照这个结构，基本可以把碰到新的内容填进去，或者在此去看源码。</div>2023-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg" width="30px"><span>码小呆</span> 👍（0） 💬（0）<div>请问是如何 保证数组不会越界的呢？</div>2022-07-04</li><br/><li><img src="" width="30px"><span>public</span> 👍（0） 💬（0）<div>删除statement时，为什么不直接调用clear方法清空？</div>2022-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg" width="30px"><span>study的程序员</span> 👍（0） 💬（0）<div>如果会被窃取，requite方法中如果没有等待线程为什么不把连接放入sharedList？</div>2021-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" width="30px"><span>Monday</span> 👍（0） 💬（0）<div>1、老师贴出来的是什么版本的hikariCP，我的版本（com.zaxxer:HikariCP:2.5.1）ConcurrentBag没有handoffQueue属性。
2、另外我想监控hikariCP把执行超时（比如6s）的连接释放掉。已经做出的尝试：
1）通过Mybatis的设置执行超时(defaultStatementTimeout)无效，生产上30个连接全部被耗尽，再有新请求会一直报错“ Connection is not available, request timed out after 30000ms”。

现在正在尝试的做法：
定时任务循环所有数据库连接，判断执行超过6S的连接，将其底层的Connection 关闭。本地测试能关闭，即能释放连接池中已经Hang住的连接，但是“执行超过6s”这个不好判断。

另外附上我的应用边库信息：
1)应用-&gt;Postgresql_120--&gt;MySQL_FDW--&gt;MySQL_5.7
2)上面讲的第1点的失效原因:Postgresql通过MySQL_FDW取MySQL这种场景才设置执行超时失效(直接应用连Postgresql是可以生效的)</div>2021-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg" width="30px"><span>往事随风，顺其自然</span> 👍（0） 💬（1）<div>  bagEntry.setState(STATE_NOT_IN_USE);requilte方法里面写的有点问题吧，这个之前已经设置状态，后面for循环里面判断不等于未使用状态，这个多此一举</div>2019-12-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（0） 💬（1）<div>老师，您好，下面这一段没有看懂：
else if ((i &amp; 0xff) == 0xff) {
      parkNanos(MICROSECONDS.toNanos(10));
 }
为什么需要这样一段呢？</div>2019-08-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg" width="30px"><span>业余草</span> 👍（0） 💬（0）<div>看不上眼的优化，居然带来了巨大的性能提升。</div>2019-07-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg" width="30px"><span>而立斋</span> 👍（0） 💬（0）<div>faststatementlist</div>2019-06-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg" width="30px"><span>张三</span> 👍（0） 💬（0）<div>打卡！</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg" width="30px"><span>龙猫</span> 👍（0） 💬（0）<div>需要多看几遍</div>2019-06-02</li><br/>
</ul>