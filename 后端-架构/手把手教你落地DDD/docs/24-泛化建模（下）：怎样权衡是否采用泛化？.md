你好，我是钟敬。

前两节课，我们重点结合报工时的需求来讨论了关于泛化的问题。在[第22课](https://time.geekbang.org/column/article/625602)，我们为工时项建模的时候使用了泛化；而[第23课](https://time.geekbang.org/column/article/626296)，在为客户项目和内部项目建模时，尽管可以泛化，最终却没有采用泛化。

你可能会有个困惑：前两节课的例子里，是否采用泛化，似乎完全是凭经验和直觉，有没有更多规律可循呢？

事实上，要学会一项技术，不仅要知道什么时候用它，更要知道什么时候不用。泛化虽然很有用，但也是一种容易被过度使用的技术。

是否要采用泛化，有时并没有唯一正确的答案，而是个权衡问题。站在业务的角度，泛化可以让我们通过抽象思维而得到更深刻的领域知识，并且运用得当的话可以使模型更简洁。但另一方面，也正是由于有些抽象，所以有时反而让模型变得费解。而站在开发人员的视角，还需要考虑技术上是否容易实现，是否容易保证代码和模型一致性的问题。

既然是“权衡”，那么必然有一些“艺术”的成分在里面。不过，我们今天还是尽量找出一些规律性的东西，以便你能尽快形成“感觉”。先提示一下，后面有不少示意图，你可以边看文稿边听我说。

## **识别泛化的两个方向**

首先，我们在建模的时候识别泛化的过程，其实有两个不同的方向。

一个方向是先识别出了子类，然后从子类中归纳出共性，形成父类。比如在第22课，我们先识别出**项目**和**子项目**，然后发现这两者都能报工时，也就是说具有能够报工时这个共性，于是识别出了**工时项**这个表示共性的父类。
<div><strong>精选留言（8）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg" width="30px"><span>南山</span> 👍（8） 💬（1）<div>钟老师，请教个问题：像这种采用了泛化的，如何识别聚合根，比如工时管理的聚合根还是工时管理吗？项目管理的还是项目，是这样的吗？</div>2023-02-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg" width="30px"><span>╭(╯ε╰)╮</span> 👍（5） 💬（2）<div>工作中经常遇到的问题：
1 技术上的泛化跟业务上的泛化不能很好的共存，    最常见的案例就是有个AbstractXXX的基（提取公共方法，封装技术实现比如把一类操作消息中间件的代码抽到父类里而产生的），另外有一个业务上归纳出来的父类。
因为不能多继承我的代码要么放弃技术上的抽象选择业务上的父类来继承，导致技术实现相关的代码到处复制粘贴。要么放弃业务上的父类，后果就是领域建模不能落地。

2 业务上的泛化使用技术不好实现（语言不支持多继承，接口不能有属性）
我是做游戏开发的，游戏设计各种天马行空，策划随便给过来一个技能，很可能就把之前版本的代码结构破坏掉，几十层的继承关系并不稀罕，各种散弹式修改和发散式修改。

身边不乏工作十几年的老程序员，但上面两个问题大家好像没有什么好的办法（或者他们习以为常不觉得这是问题），甚至很多屎山就是公司大牛的杰作。</div>2023-02-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg" width="30px"><span>子衿</span> 👍（5） 💬（1）<div>这章其实感觉读起来有点绕，我能不能这样理解一下，就是说泛化是领域模型图中的一个标识而已，要不要使用这个标识，其实只取决一一点，就是是否使用特性值的方式进行实现，如果使用特性值方式进行实现，那么因为没有父子类的概念，就会导致模型和代码不一致，因此就不应该用泛化，而文章其实整体讨论的不是应不应该使用泛化，而是讨论用具体哪种实现方式来实现分类
1. 有不同种类的特性或者不同的操作：使用继承
2. 子类在属性和操作实现方面没有共性，但有相同的操作接口：使用接口实现
3. 仅特性值不同：使用新增属性值的方式</div>2023-02-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/24/0b/8690964e.jpg" width="30px"><span>或许</span> 👍（0） 💬（1）<div>“第三，如果在业务规则、操作接口或操作实现方面有共性和个性，首先考虑在实现上是否可以使用策略模式，如果可以，那么在领域模型中就不必泛化，否则考虑泛化。”
老师您好，上面这句话我没有太理解，希望老师可以抽空解答一下我的疑问：
策略模式定义了一个抽象的算法，以及一组具体的实现。我理解抽象的算法和这组具体的实现，也可以用来表示分类关系，为什么可以用策略实现，就不建议使用泛型呢？</div>2024-07-01</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0RWHypVI6Qprp1ib5cpkX3vINS9ib73m1XIV6Ha4bPOYjVZREd1TS8ejsq0nInVHOTqV5RwAdxJicw/132" width="30px"><span>才华</span> 👍（0） 💬（1）<div>钟老师。请教一个问题，比如广告投放系统中，对于投放资源位，营销目标，推广标的等来说，不同的值决定了后续的业务逻辑判断和属性填充，这种的建议使用泛化还是特性值呢。</div>2023-06-20</li><br/><li><img src="" width="30px"><span>icode</span> 👍（0） 💬（1）<div>领域模型的第三个关系，是不是可以理解成类和子类的关系啊？</div>2023-02-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg" width="30px"><span>6点无痛早起学习的和尚</span> 👍（0） 💬（3）<div>思考题 2：2 个例子，但是感觉第一个例子不应该用泛化，第二个可以用泛化
第一：
- 父类：账户项
- 子类：现金账户、备付金账户、待清算账户、待结算账户等等
共性：都有可用余额、冻结余额、挂靠会计科目等特性值
个性：业务规则不一样，子类的余额方向和交易方向对应出来的余额增减结果是不一样的，但是规则都是同增异减

第二：可以用泛化，但是最后用了策略
- 父类：正向交易
- 子类：支付、充值、提现
共性：业务规则流程相同，先校验参数、再校验是否原单和状态、组装请求外部参数、处理请求外部结果。
个性：每个子类的具体业务规则实现是不一样的。</div>2023-02-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg" width="30px"><span>赵晏龙</span> 👍（0） 💬（1）<div>1、没有进一步的需求，我觉得，不需要，用属性标识也够了。
2、
极客时间专栏、Java专栏&#47;.Net专栏&#47;Go专栏，这一类就不需要泛化，只有共性，没有特性
极客时间用户、企业用户&#47;个人用户，这一类可能就需要泛化，如果企业用户和个人用户某些操作不同的话。

我感觉老师的帮我把知识梳理到底了，更清晰了。</div>2023-02-17</li><br/>
</ul>