你好，我是钟敬。

这节课，我们来学习数据库设计。

前面我们说过，模型驱动设计可以分成两大部分：模型的建立和模型的实现。模型的建立要求模型和业务需求一致，模型的实现要求实现和模型一致。现在，咱们已经建立了领域模型，并且从理论层面对模型驱动设计的概念进行了总结，这些都属于模型的建立。而我们这节课要做的数据库设计，则属于模型的实现。

那么，怎样由领域模型，一步一步地推导出数据库的设计呢？这种方法和以前的方法有什么不同呢？这节课我们就来讨论这两个问题。在这个过程中，我们要着重体会**数据库设计是如何与领域模型保持一致的**。

今天讲的内容，在软件工程中叫做建立**物理数据模型**（physical data model, PDM），主要目的就是对数据表进行设计。具体来说，包括以下几点：

- 建立哪些表；
- 表中有哪些字段；
- 表的主键和外键是什么；
- 字段的数据类型以及约束。

还有一点要说明，虽然我们的例子是用MySQL完成的，但我们讲的是通用原理，所以采用其他数据库引擎的话，道理也是一样的。

我们在领域建模的时候把模型分成了四个模块，下面，我们就一个模块一个模块地进行数据库设计。

![](https://static001.geekbang.org/resource/image/da/c3/da146dd3yy8faefa7494001fa7af89c3.jpg?wh=3733x2260)

## “租户管理”的数据库设计

咱们就从最简单的**租户管理**模块开始吧，下面是这个模块的模型图：  
![](https://static001.geekbang.org/resource/image/f6/a7/f666bf21bcffb52edf2fcd2ac11d37a7.jpg?wh=3733x2260)
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（6） 💬（5）<div>以下内容，仅个人补充，不一定正确。与大家探讨。
1.POJO（Plain Old Java Object） 和 POCO（Plain Old CLR Object）以及 PI（Persistence Ignorance）。在ddd里，持久化对象与具体的持久化实现机制之间应该是隔离的，虽然这可能是过度设计，但思路并没有毛病。所以，可能不需要特别关心。

2. not null 这个事，部分公司dba很可能会强制限制默认都是not null， 用def处理 null场景。 道理大家应该也懂。 数据库存储承载模型关系？第一次见，有新意，就是感觉载体不大稳定（存储随意，与领域模型本就没有1:1的必然性）。

3.表命名，有些公司规范可能要 xxx团队_xxx项目_xxx模块_xxx表名。图省事，因为CDC的时候表可能是打散的（比如，ODPS），这时候需要做去重+定位。（当然，你也可以CDC映射时转名字，就是可能要做多次，毕竟CDC不一定就到一个平台，手工多次重复操作？很容易出问题《墨菲定律》）

课后题:
1.没有业务含义的 id 作为主键?不确定是指主键名叫id，还是指主键值没有业务含义。两个都回答下，前者部分low的orm框架的插件限制（不叫id没法自动生成代码）；后者是从数据库的性能（B+树要维护有序性）和内存空间占用（其他索引叶子节点空间大小）考虑，但事无绝对，例如 单索引 kv场景。（减少一次回表，抵消写时索引树排序， 无其他索引，无叶子节点空间浪费）。
2.避免了数据冗余并不意味着代码能支持重用，遵守与否都不解决核心问题，所以不用太纠结。更何况存储不见得一直都是关系性数据库。把它当成持久化的一种实现手段，大胆干有问题就改就是。过度在意反而可能影响模型设计，毕竟关系性数据库的范式包含性能等一系列考虑并不是很适应代码模型的设计。</div>2023-01-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg" width="30px"><span>╭(╯ε╰)╮</span> 👍（16） 💬（4）<div>自从入行，有四件事阻止了我在技术上的发展

一是数据库范式
二是单元测试
三是领域驱动设计
四是docker

这些东西我甚至比极客时间上的老师接触到的还要早，但是奇妙的事情是我的同事没有一个支持这四个概念，大部分都是持反对态度。同事的“阻挠”让我起了个大早，赶了个晚集。现在看着老师们布道，回想当年同事们看我的眼神，好像我是异教徒，伤感自己生不逢时，好人所恶。自己越是执念越会被社会教育。

随波逐流crud到现在，终于觉得自己熬出头，见到自己曾经执着并放弃的东西又回到了自己的身边。自己没有能力做到的事情看着别人做到，事实挺开心的。

希望老师的课程能让更多的人有所收获。</div>2022-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/80/ec/b6149cbf.jpg" width="30px"><span>老狗</span> 👍（7） 💬（3）<div>问题1: 有以下几个因素： 
首先由业务含义的字段虽然业务上不允许重复，但有些时候会出现意料之外的场景，比如拿学生的名字作为主键就会遇到重名的问题，我父亲就是因为重名问题考虑把我名字里的一个字改了，避免了很多困扰。
其次业务主键一般都为字符型，考虑到数据库优化，有的时候递增主键会带来一些效率
再次业务上的唯一主键有些时候为联合主键，维护起来难度更加提升
再再次，解耦业务需求和技术实现。
问题2: 一致性问题是冗余字段必须要考虑的首要问题，就是冗余字段和冗余来源之间的一致性，另外就是性能问题了
</div>2022-12-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg" width="30px"><span>leesper</span> 👍（5） 💬（2）<div>前面阳了几天休息了一下，今天可以继续学习了，思考题：

1. 用没有业务含义的id作为主键我觉得是一种分离关注点的设计方式；业务是在变化的，今天适合用来做主键的业务字段，未来未必，索性约定俗成用id算了

2. 符合范式的数据库设计是为了写操作的高效（没有冗余就没有重复的写，同时避免疏忽大意造成漏写），适当的冗余是为了读操作的高效（不必join很多张表才能拿到自己想要的数据）。所以做冗余设计的数据主要用来读，而不是写，比如一些历史的交易流水数据什么的，经常变的数据就不适合做这种冗余设计了

钟老师我有个问题请教下：我记得前面几节课说过，员工和项目之间的“项目成员”关系、“工时记录”关系，不都是多对多吗？为啥不用联合主键的方式设计，而仍然采用id呢？</div>2022-12-29</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIERY97h7dmXbtur6rhZWA9Jb3TtSsJh7icDdFjdLmruTXC22qibOVTmW2a04TxMhxqtNJibYL1iaU7yQ/132" width="30px"><span>Geek_8ac303</span> 👍（4） 💬（1）<div>表的主键不使用xx_id而是id，往往是被代码框架约束了，在很多orm模型里，save方法中是按照id不存在就插入，存在就更新
关于违反第三范式，主要还是看表关系和业务需要，如果一个表在搜索的时候可能用到外键表的数据，如果俩个表关联还好，多于俩表，性能会严重下降。在项目初期一般都是冗余字段，来提升搜索和查询数据的性能。业务发展起来有钱有人了，就要考虑搜索引擎了。
但是冗余了字段就要考虑，冗余字段是否会被更新，如果更新了是否要更新冗余字段，在大部分情况下都是些不经常更新的字段才冗余，为了效率，对这种不经常更新的字段就不考虑更新冗余字段</div>2022-12-22</li><br/><li><img src="" width="30px"><span>Geek_c33f40</span> 👍（2） 💬（1）<div>老师您好, 审计字段是否应该显示在领域模型上面? 因为有时候审计字段也是有业务含义的, 例如发起人, 群主. 我觉得分开会更好一些.
一方面领域模型和数据模型映射更加清晰一些.
 一方面避免业务改动导致审议字段逻辑有变, 例如最后更新时间, 对于某些业务来说, 某些关联的变更不会影响到最后更新时间, 但对于审计来说可能对这条记录的任何修改都需要变更更新时间.
缺点是有部分会有重复</div>2023-02-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" width="30px"><span>aoe</span> 👍（2） 💬（2）<div>两个思考题：
1. 规则通俗易懂，一下就能掌握规律；降低认知复杂度；
2. 当冗余字段更新时，要更新所有相关数据，不然可能产生不可思议的 Bug。</div>2022-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（2） 💬（2）<div>有了前面的领域模型的分析和设计，再加上词汇表的加持，数据库设计看上去似乎水到渠成。

create_at、created_by、last_updated_at、last_updated_by 这四个审计字段确实好用。

文中对于外键约束的说法我比较赞同，就是清楚外键的逻辑关系，但是在实施的时候不使用数据库中的外键约束，而采用程序代码来保证。另外就是，可以考虑一定的数据冗余，这样保证查询的效率。

对于思考题：

1. 采用没有业务含义的 id 做主键应该已经是业界标准了吧，有业务含义的字段很难保证始终不会发生变化。另外，就是倾向于使用整型数字做主键，而不是那种很长的 UUID 字符串

2. 在反规范化设计的时候，同样需要清楚哪些部分是冗余；这些数据冗余甚至可以采用一定的步骤进行统一的清洗和更新。</div>2022-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg" width="30px"><span>╭(╯ε╰)╮</span> 👍（2） 💬（1）<div>课后思考题

id这个名字算是一种约定大于配置，看到这个名字大家一眼就能识别出来它是表中的主键，背后的逻辑也会被本能的浮现在脑海里。沟通时，丢给对方一个id无需多言，如果使用有业务含义的字段名，那就不好意思了，大家坐下来互相battle一下，从设计到实现，各种细节扯皮一遍，别嫌麻烦

冗余的数据我个人观点是跟回表息息相关，两方面：一是如果数据库足够高级，我们能轻易得到自己需要的数据自然就不需要冗余；二是软件建模不同，结果数据是否冗余也不同，面向对象设计的好，映射到数据库上自然而然的是符合范式的。不需要花额外的功夫。</div>2022-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg" width="30px"><span>Geek4329</span> 👍（1） 💬（1）<div>老师有个疑问点，数据模型不一定和领域模型完全一致吧，领域模型和数据模型可能是一对多，多对一都有可能</div>2023-10-19</li><br/><li><img src="" width="30px"><span>Geek_a2b9d0</span> 👍（1） 💬（1）<div>如果数据库模型和领域模型一样，那我们还是在面向数据库模型编程</div>2023-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg" width="30px"><span>py</span> 👍（1） 💬（2）<div>1. id无感业务，不会被频繁变更；主键一般设为自增长，业务一般不符合；业务字段可能是string等非int字段，性能不高
2. 充分评估必要性；控制度，非必要不违反 </div>2023-02-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg" width="30px"><span>Michael</span> 👍（1） 💬（1）<div>组织类别这种表示类型的我的实践一般是在代码里创建枚举类型，然后用 varchar 或者自建的枚举类型作为字段类型，但是这里老师用了一张类似字典表的设计，想请教这样的设计的意图是啥？</div>2023-01-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg" width="30px"><span>6点无痛早起学习的和尚</span> 👍（1） 💬（1）<div>一些思考和问题：
1. 如果组织类别是死的，那就可以直接作为一个表的字段去枚举，课中是灵活动态添加的，所以是一个单独的表，员工岗位同理。
2. 工时记录表里的租户 id，是否只是一个扩展字段设计，方便可以直接看到这个工时记录是哪个租户的，因为如果为了最终能查询到租户 id，在工时记录表里不设计租户 id，可以通过项目 id 一步一步去反查到租户 id，因为之前在领域建模设计阶段，工时记录和组织其实没有直接的比例关系。
3. 还需要再继续读一读：与“ER 图法”的区别</div>2023-01-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/56/cd/0add8290.jpg" width="30px"><span>刘学习来学习</span> 👍（0） 💬（1）<div>按照领域模型直接建表的话会不会有这样的问题，领域模型重在业务语义的表达，数据表要考虑性能和扩展，我理解一个模型可能会拆分成n张表来存储，只需要过程中有一个对象可以映射领域模型就行了吧</div>2024-08-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/30/4a/5b1d1018.jpg" width="30px"><span>zhsky</span> 👍（0） 💬（1）<div>1. 领域实体不是由该对象的某个具体业务属性来唯一确定的，有系统随机创建的唯一键标识，更不容易产生误会。


2. 注意数据库性能，冗余字段最好只做展示，不做查询</div>2024-04-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f5/80/baddf03b.jpg" width="30px"><span>zhihai.tu</span> 👍（0） 💬（1）<div>emp表的org_id和org的leader_id是不是应该设计为NOT NULL，因为领域模型中的多重性为1..1</div>2024-03-04</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzrdNibIODKPJRHfL2X8FUkFib9EvNyDKA2b15dV06Uyoy6xx9yv38yUUJPicgTEEyPhQBo4ojsFcVw/132" width="30px"><span>爱喝橙汁的蛋蛋</span> 👍（0） 💬（1）<div>老师，您讲的数据库是关系型数据库，那么对于图数据库呢，比如说如何将DDD映射到Neo4j？</div>2024-02-06</li><br/><li><img src="" width="30px"><span>Geek_a2b9d0</span> 👍（0） 💬（1）<div>为什么有些文章说DDD的数据库库模型不一定和领域模型不一样？</div>2023-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f8/e8/bbd1b66d.jpg" width="30px"><span>🏄🏻米兰的大铁匠🎤🎈</span> 👍（0） 💬（1）<div>为何建议用id而非联合主键： id不但是本表的唯一标识而且从本质上看id代表着“联合关联”关系的标识，每个id代表了一个关系，在数据表现上更能体现主键的作用</div>2023-05-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/df/db/353e5764.jpg" width="30px"><span>杨光</span> 👍（0） 💬（2）<div>钟老师你好， 如何获取课堂的代码呢</div>2023-04-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/85/d0/56602a43.jpg" width="30px"><span>灵活工作</span> 👍（0） 💬（1）<div>org表的org_type_code的类型不是int而应该是char</div>2023-02-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" width="30px"><span>aoe</span> 👍（0） 💬（1）<div>学习笔记（附 MySQL 建表语句）
https:&#47;&#47;wyyl1.com&#47;post&#47;23&#47;03&#47;</div>2023-02-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg" width="30px"><span>Jaising</span> 👍（0） 💬（1）<div>用自己的话翻译一下领域驱动设计对于数据库设计的价值：领域驱动设计改变了表结构设计优先的懒惰思维惯性，领域建模优先保障了数据库设计与领域模型一致，从数据驱动到领域驱动是软件生产方式的变革，为领域模型与软件实现的统一奠定基础。
继续第三篇两千字小笔记（实践出真知拿个小项目练果然好落地）：https:&#47;&#47;juejin.cn&#47;post&#47;7187196960569294885</div>2023-01-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/22/61/580bb3c3.jpg" width="30px"><span>hk</span> 👍（0） 💬（1）<div>老师你好，问下租户表，个人理解一般一个企业注册一个租户，name是表示租户的企业名称吗，如果本身另外有一张公司表或者企业表，是否需要跟这个租户表1对1关联</div>2023-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg" width="30px"><span>阿昕</span> 👍（0） 💬（1）<div>1.非业务含义主键ID，在格式能够保证是long类型，在迭代上保留了灵活性；
2.需要注意数据变化之后，冗余字段保存的还是历史值；</div>2023-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg" width="30px"><span>Jaising</span> 👍（0） 💬（1）<div>钟老师有提到基于云的应用不主张建立真正的外键，这个是不是可以扩大一点说，不论是否基于云，现代企业软件都不鼓励建立外键，甚至直接禁止join查询，我能想到的几点原因是sql扩展性复用性没有代码实现关联来的强，尤其是业务变动比较大的时候数据库改造成本很高，还会碰到小表驱动大表索引不合理增加设计与实现复杂度，遇到跨库join的mysql等一众关系型数据库都并不擅长，sql对于OO的破坏DDD是怎么应对的？</div>2023-01-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg" width="30px"><span>龙腾</span> 👍（0） 💬（1）<div>1、从数据库性能的考虑。主键一般设置为递增，以防止修改时的页分裂；主键一般设置为数值类型，占用空间少，可以使索引树层级减小。而业务id可能并不具有这种特性。
2、如果冗余字段存在与2个表中，需要考虑这个字段是否会在其主表中更新，如果主表中更新该字段，则需要更新这个冗余字段，如果冗余字段出现在很多表中，更新将变的复杂。如果冗余字段只存在于1张表中（没有将两个领域表拆分），删除记录将会导致冗余字段的丢失，《数据库系统设计、实现与管理(6)》中主要针对后一种情况分为了插入异常、删除异常、修改异常。</div>2023-01-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b1/98/11b22d79.jpg" width="30px"><span>絆</span> 👍（0） 💬（1）<div>老师对于冗余, 我个人理解为应该区分实体和值对象的区别, 看似一样的属性如果是值对象, 冗余是必要的, 创建新实体时冗余已经是新实体的一部分, 不属于以前的实体对象, 这个时候我认为是必要的.</div>2022-12-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg" width="30px"><span>赵晏龙</span> 👍（0） 💬（2）<div>由于ORM框架存在，我不会直接到数据库的设计，而是先做class设计，由ORM直接code first得到表。

但究其根本，其实像使用虚拟外键一类的方法解耦的做法，其实都是类似的。</div>2022-12-22</li><br/>
</ul>