你好，我是李玥。

我们在《[21 | RocketMQ Producer源码分析：消息生产的实现过程](https://time.geekbang.org/column/article/135120)》这节课中，讲解RocketMQ的生产者启动流程时提到过，生产者只要配置一个接入地址，就可以访问整个集群，并不需要客户端配置每个Broker的地址。RocketMQ会自动根据要访问的主题名称和队列序号，找到对应的Broker地址。如果Broker发生宕机，客户端还会自动切换到新的Broker节点上，这些对于用户代码来说都是透明的。

这些功能都是由NameServer协调Broker和客户端共同实现的，其中NameServer的作用是最关键的。

展开来讲，不仅仅是RocketMQ，任何一个弹性分布式集群，都需要一个类似于NameServer服务，来帮助访问集群的客户端寻找集群中的节点，这个服务一般称为NamingService。比如，像Dubbo这种RPC框架，它的注册中心就承担了NamingService的职责。在Flink中，则是JobManager承担了NamingService的职责。

也就是说，这种使用NamingService服务来协调集群的设计，在分布式集群的架构设计中，是一种非常通用的方法。你在学习这节课之后，不仅要掌握RocketMQ的NameServer是如何实现的，还要能总结出通用的NamingService的设计思想，并能应用于其他分布式系统的设计中。
<div><strong>精选留言（28）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg" width="30px"><span>业余草</span> 👍（14） 💬（2）<div>线上环境突发消息延迟2个小时，该如何尽快解决？以及后期如何避免这类问题？说说你的思路和经验！</div>2019-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9c/9b/eec0d41f.jpg" width="30px"><span>康师傅</span> 👍（10） 💬（1）<div>对于rocketmq和kafka而言，都有自己的“注册中心”，但对于rabbitmq而言，它的集群允许你连接到集群中的任何一台进行生产消费，即便队列master所在节点并不是你连接的这台，rabbitmq内部会帮你进行中转，但这会有一个很大的弊端，就是节点间会有较大的流量并且不可控，并且整体的性能会受影响

想请问下，这种时候，是否有较好的优化方式？
想到的一个办法是，自行做一个NameServer，按队列进行注册分流，生产者消费者先与NameServer交互得到真实的节点ip，然后直接连接到队列master所在节点进行生产消费</div>2019-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg" width="30px"><span>我已经设置了昵称</span> 👍（8） 💬（1）<div>老师，我们生产环境。同一个group，多台机器消费同一个topic消息，遇到了某几个实例消费的分区延迟特别高，导致消息堆积的情况。但另外几个实例消费的分区并没有堆积。这通过扩容consumer也没法解决。而且很难排查，有什么好的方式吗</div>2019-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg" width="30px"><span>饭粒</span> 👍（3） 💬（1）<div>请问下老师，如果 nameserver 有节点重启了或是新加了一个节点，恢复内存中的路由数据过程是通过 broker 的心跳上报路由信息重新注册一遍吗？</div>2019-11-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg" width="30px"><span>Better me</span> 👍（3） 💬（2）<div>NamingService集群有点像去中心化的结构设计，每个节点保存所有数据，很好的保证了节点的可用性，但每个节点之间不互相通信，很难确保节点间的数据一致性。想问下老师主题(和其中队列)在broker节点的分布情况是怎样的</div>2019-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cf/b5/d1ec6a7d.jpg" width="30px"><span>Stalary</span> 👍（2） 💬（1）<div>老师，我想问一下，如果起了很多个NameServer，都保持长连接的话是不是开销会较大呢，为什么没有采用订阅发布的模式去更新broker呢，是因为即时性吗</div>2019-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/a0/08/065b3cf5.jpg" width="30px"><span>Yippee</span> 👍（0） 💬（1）<div>想问下老师文中讲的代码是基于 RocketMQ 的哪个版本啊，我在 4.5.1 和 4.7.0 中找不到 RouteInfoManager 等类</div>2020-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg" width="30px"><span>丁小明</span> 👍（0） 💬（1）<div>老师你好，有个疑问就是如果客户端链接的那个nameserver不可用了怎么办呢，如果broker也恰好有变动，那这些客户端是不是也都不可用了。且无法自动恢复</div>2020-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg" width="30px"><span>fomy</span> 👍（0） 💬（1）<div>假如其中一台NameServer挂了，客户端会自动切换到其他的吗？</div>2020-02-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg" width="30px"><span>我已经设置了昵称</span> 👍（0） 💬（1）<div>nameServer本身某几个实例挂了，会怎么处理呢</div>2019-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg" width="30px"><span>WL</span> 👍（0） 💬（3）<div>请问一下老师，如果namingServer集群的各节点在多机房部署，如果一个机房与所有broker的通信中断了，那这个节点的namingServer上的信息就与其他namingServer不一致了，出现这种情况怎么办？</div>2019-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg" width="30px"><span>益军</span> 👍（29） 💬（1）<div>优点:  nameserver本身设计为无状态，实现简单，
缺点: broker客户端通信成本复杂，适合在客户端环境完全可控的情况下设计。namesrv 一致性无法保证，需要定时幂等性心跳保持最终一致性。</div>2019-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg" width="30px"><span>饭粒</span> 👍（8） 💬（0）<div>优点：实现简单，集群节点平等，比较容易的水平扩展节点数量提供高可用性。路由数据读写都是内存，QPS比较高。
缺点：每个 broker 需要与所有 nameserver 节点心跳通信，通信成本较大，无法保证强一致性。</div>2019-11-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg" width="30px"><span>leslie</span> 👍（2） 💬（0）<div>    老师最近的课都是在啃代码且非常整体性：学习上是越来越辛苦了，总要翻阅和梳理知识才能明白题目可能的问题。
    节点之间不互相通信其实减少了网络开销以及相互的等待确认的过程从而节约了时间,不会互相影响互相继承：换个角度来思考这个问题其实就像是我们用虚拟化一样，RocketMQ的这种NameServer就像是docker&#47;Kubernetes，各自出了问题不会影响其它的docker&#47;K8。
   优势就是减少了节点之间的通信以及等待的代价，不足就是出了问题如何发现以及通知系统&#47;服务端。等待老师对于这个问题的答案的公布：等待明天老师继续的分享，谢谢。</div>2019-09-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg" width="30px"><span>糖醋🏀</span> 👍（2） 💬（0）<div>nnameserver各个节点独立不通信，是ap的思路。
各个节点总是可用，但是节点之间不通信，有可能由于网络原因，某个节点的路由信息可能会不一致。
客户端拉去所有节点的路由信息，可以弥补某个节点路由信息不一致的情况。</div>2019-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg" width="30px"><span>亚林</span> 👍（1） 💬（0）<div>牺牲一致性，提高可用性</div>2020-09-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg" width="30px"><span>大毛</span> 👍（0） 💬（0）<div>优势：
1 - 每个节点都是独立的，不需要考虑类似主从同步这种问题，实现起来比较简单。
劣势：
1 - 数据一致性的保证比较弱，每个节点的数据取决于 Brocker 上报的数据是否成功被 NameServer 正确处理。如果某次数据上报对一个节点成功，另一个节点失败，会导致这两个节点的数据不一致。
2 - 会消耗更多的资源，每个 Brocker 需要和每个 NameServer 进行通信。在超大规模集群下，可能这种通信本身就成为瓶颈</div>2023-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg" width="30px"><span>谁都会变</span> 👍（0） 💬（0）<div>NameServer是单独存在的服务吗，像Kafka和Zookpeer？RocketMQ好像没有Zookpeer，它是怎么做的？</div>2023-02-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2c/73/7f/9088256b.jpg" width="30px"><span>莫名其妙的人</span> 👍（0） 💬（0）<div>文章没有提到客户端与哪个NameServer节点通信，看了一些网上说法，应该是客户端只需要链接NameServer集群地址，然后产生一个随机数取模（失败则轮训即可）。这种随机选择策略不会产生一些不均衡吗？为什么不适用负载均衡，动态路由等方式呢？
</div>2022-08-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg" width="30px"><span>Heaven</span> 👍（0） 💬（0）<div>1.越简单的设计,健壮性越好,越单一的功能,性能越好,这样设计必然提供了更高的性能
2,但是容易出现无法保证一致性的问题,但是我想,可能RMQ也不在乎</div>2021-02-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg" width="30px"><span>prader26</span> 👍（0） 💬（0）<div> rocketmq 如何在集群中找到正确的节点。
 
 核心是利用的NameServer 和broker 联合实现的。
 1 每个broker 都和全部的NameServer 进行通信。
 2 当broker 上Topic信息发生改变的时候，会通知所有的NameServer 更新路由信息，同时broker 也会定时把信息
   上报到所有的NameServer节点。这个就起到了NameServer对broker 进行健康检测的作用。
3  每台NameServer 都能单独提供服务。当NameServer 和broker 之间的通信断掉，消费者会重新去NameServer上拉
  取别的broker 信息，这样就起到了自动切换失效Broker的作用。   </div>2020-12-08</li><br/><li><img src="" width="30px"><span>信大捷安</span> 👍（0） 💬（1）<div>看了留言中，nameServer可以做一个集群，topic是散列在nameServer集群中的一个服务中，那么是如何保证topic正确的散列的其中的一个nameServer中的，很好奇？</div>2020-09-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg" width="30px"><span>Peter</span> 👍（0） 💬（0）<div>优点是性能高，Broker只需关心单个节点，而不需要关注集群状态，客户端只需要和一个NameServer打交道，不用关心集群状态。
缺点是不能保证一致性</div>2019-11-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/cf/7a/51951b07.jpg" width="30px"><span>微笑</span> 👍（0） 💬（0）<div>nameserver服务感觉跟注册中心有点像</div>2019-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d3/c2/4d485226.jpg" width="30px"><span>柳俊波</span> 👍（0） 💬（0）<div>优点：
1:Nameserver高可用，节点之间无状态，减少节点同步逻辑，非常轻量级。
缺点：
1:牺牲了一致性。两个nameserver数据不一致，导致消息数据倾斜</div>2019-10-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg" width="30px"><span>姑射仙人</span> 👍（0） 💬（0）<div>还有个缺点是NameService不支持写扩展，增加服务节点无法水平扩展，让我想起了zookeeper。不知道理解是否正确。</div>2019-09-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg" width="30px"><span>DFighting</span> 👍（0） 💬（0）<div>多个NameServer独立对外提供服务是一种用冗余的路由注册来换维持集群式的NameServer间数据一致性和高可用性的方式，集群部署不可避免需要在数据一致性和高可用性间平衡，这会给程序设计、编码和后溪维护带来很大的代价，因为路由信息本就不会太多，所以选择了前者。
不过我更偏向于后者，单节点独立提供服务肯定会出现某个节点请求当前的NameServer找不到对应的正常Broker的情况，因为NameServer不能保证保存了完整的Broker集群拓扑。路由发现算法虽然会导致一些时间的服务不可用，但在Broker集群体量很大的时候，肯定比独立NameServer好点。当然目前也可以考虑部署RocketMQ集群，让每个独立的NameServer服务部分区域的Broker的设计思路吧</div>2019-09-17</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132" width="30px"><span>有铭</span> 👍（0） 💬（0）<div>这整个就是一个微服务架构</div>2019-09-17</li><br/>
</ul>