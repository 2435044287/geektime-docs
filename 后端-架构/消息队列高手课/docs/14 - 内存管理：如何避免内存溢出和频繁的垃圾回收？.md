你好，我是李玥。今天，我们来聊一聊内存管理的问题。

不知道你有没有发现，在高并发、高吞吐量的极限情况下，简单的事情就会变得没有那么简单了。一个业务逻辑非常简单的微服务，日常情况下都能稳定运行，为什么一到大促就卡死甚至进程挂掉？再比如，一个做数据汇总的应用，按照小时、天这样的粒度进行数据汇总都没问题，到年底需要汇总全年数据的时候，没等数据汇总出来，程序就死掉了。

之所以出现这些情况，大部分的原因是，程序在设计的时候，没有针对高并发高吞吐量的情况做好内存管理。要想解决这类问题，首先你要了解内存管理机制。

现代的编程语言，像Java、Go语言等，采用的都是自动内存管理机制。我们在编写代码的时候，不需要显式去申请和释放内存。当我们创建一个新对象的时候，系统会自动分配一块内存用于存放新创建的对象，对象使用完毕后，系统会自动择机收回这块内存，完全不需要开发者干预。

对于开发者来说，这种自动内存管理的机制，显然是非常方便的，不仅极大降低了开发难度，提升了开发效率，更重要的是，它完美地解决了内存泄漏的问题。是不是很厉害？当年，Java语言能够迅速普及和流行，超越C和C++，自动内存管理机制是非常重要的一个因素。但是它也会带来一些问题，什么问题呢？这就要从它的实现原理中来分析。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg" width="30px"><span>linqw</span> 👍（116） 💬（1）<div>尝试回答下课后习题，老师有空帮忙看下哦
如果有一个微服务是处理大量的文本，感觉这种一般不会要求时延，大部分都会进行异步处理，更加注重服务的吞吐率，服务可以在更大的内存服务器进行部署，然后把新生代的eden设置的更大些，因为这些文本处理完不会再拿来复用，朝生夕灭，可以在新生代Minor GC，防止对象晋升到老年代，防止频繁的Major GC，如果晋升的对象过多大于老年代的连续内存空间也会有触发Full Gc，然后在这些处理文本的业务流程中，防止频繁的创建一次性的大对象，把文本对象做为业务流程直接传递下去，如果这些文本需要复用可以将他保存起来，防止频繁的创建。也为了保证服务的高可用，也需对服务做限流、负载、兜底的一些策略。</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg" width="30px"><span>leslie</span> 👍（36） 💬（0）<div>       一路跟着老师学到现在我大致明白了老师想阐述什么或者说上次回答我的困惑时的答案了；其实老师是想传授：为何要用消息队列、如何使用、何种场景下使用其涉及什么知识我们应当如何把握它的使用。
        老师上次的回答提到程序不用太深：不过其实程序、网络还有今天的课程提及的内存管理-其实是计算机组成原理的东西，如何合理的去结合这些知识才是消息队列把握好的关键；就像老师今天留的题目其实就是需要程序的垃圾回收机制的知识和组成原理的内存管理的知识结合才能给出相应的正确答案，不知道是否可以这样理解老师今天的题目？
       同时在跟几位老师的课一起学习知识并梳理自己从业多年的知识体系：至少让我觉得之前对于课程的选择是正确的，至少从大的方面去理解了；老师其实是在授之与渔，而非简单的授之与鱼。
      期待老师的下节课：希望老师解答一下我对于问题方向上的理解是否正确，谢谢。</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（20） 💬（3）<div>课后思考及问题
1：这个算法有一个最大问题就是，在执行标记和清除过程中，必须把进程暂停，否则计算的结果就是不准确的。这也就是为什么发生垃圾回收的时候，我们的程序会卡死的原因。后续产生了许多变种的算法，这些算法更加复杂，可以减少一些进程暂停的时间，但都不能完全避免暂停进程。
对于这段有几个问题？
1-1：进程必须暂停，是在标记阶段还是在清除阶段？还是两者都会？
1-2：进程暂停这个实现过程是怎样的？暂停后需要再启动，这个又是一个怎样的过程？
1-3：后面解释进程必须暂停的原因是为了使计算结果更加准确，我觉得好比打扫卫生，我一个房间一个房间来，也不耽误其他房间的事，是不是暂停是不必须的，其实 young gc 几乎不停的在发生，只有发生full gc 的时候性能才会大大降低？
1-4：内存清除这个动作具体是怎么实现的？是电平复位？还是打上可以继续使用的标位？如果打标位这个该怎么打呢？一位一位的打？还是一个字节一个字节的打？更或者是一块一块的打？</div>2019-08-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg" width="30px"><span>lupguo</span> 👍（13） 💬（1）<div>高并发和避免gc，尽可能少的系统调用次数，让用户态的应用程序可以快速接受tcp传过来的数据（增大接收套接字的buffer缓冲区大小，可以降低用户态和内核态的内存拷贝频次，降低上下文切换开销）。
全业务处理流程考虑用指针传递，避免内存拷贝或者堆上内存开销（栈上开销os自行回收），降低被gc可回收的变量基数。
考虑业务处理线程或协程去复用一些申请的内存区域，比如go中的buffer pool，以及通过buffer reset在处理完业务时候自动释放，可以复用申请的内存区域。
通过pprof，runtime去监控和观察内存和、gc的实际情况做对照，了解应用程序实际内存的使用情况。
暂时想到这么多。
</div>2020-05-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/23/46/db5212bc.jpg" width="30px"><span>努力努力再努力</span> 👍（4） 💬（1）<div>老师，假如我有一个对象，这个对象作为接口的入参，但是前端在传值的时候，只传了部分字段，那么在申请内存空间的时候，这个对象是只申请传值了的这些对象所以占用的空间，还是所有属性占用的空间</div>2019-11-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg" width="30px"><span>冰激凌的眼泪</span> 👍（3） 💬（1）<div>占用内存差不多的，是不是比较适合池化？</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/45/62/3c6041e7.jpg" width="30px"><span>木小柒</span> 👍（2） 💬（1）<div>接上一条，点击空白留言出去了，这个功能好尴尬。可以先看机器能给到的内存量和cpu消耗，看大约一秒钟可以处理多少文件。然后限流，可以把文件存本地，也可以存消息队列中，看资源来定。控制文件数量，虽然处理排队慢了，但不至于挂掉。</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg" width="30px"><span>Hurt</span> 👍（1） 💬（1）<div>其他语言的内存管理 也存在类似的现象吗 也是这么处理吗 老师</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg" width="30px"><span>grey927</span> 👍（0） 💬（1）<div>对于需要频繁使用，占用内存较大的一次性对象，我们可以考虑自行回收并重用这些对象。实现的方法是这样的：我们可以为这些对象建立一个对象池。
---》这个是不是就是设计模式中的享元模式的实际应用</div>2020-05-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg" width="30px"><span>Peter</span> 👍（37） 💬（0）<div>简单整理下jvm的一些概念，帮大家回忆回忆这些理论哈哈
垃圾回收算法：
标记清除：效率较低，会产生内存碎片
复制算法：将内存一分为二，通过不断将活着的对象移动到内存另一面，再清除这面，解决了效率低、内存碎片的问题，引来新的问题：内存一分为二代价太高
标记-整理算法：先标记（过程跟标记清除一样）再将存活对象都向一端移动，清理掉端边界以外的内存。适用于老年代
分代收集算法：将内存划分为几块，新生代采用复制算法，老年代采用标记-整理算法
垃圾收集器：
Serial收集器：新生代采用复制算法，会stop the world；老年代采用标记-整理算法，也会stop the world
ParNew收集器：Serial收集器的多线程版本，其他一模一样
Parallel Scavenge收集器：特点：可控制的吞吐量
CMS收集器：特点：重视服务响应速度，降低GC停顿时间
大致分为4个步骤
初始标记
并发标记
重新标记
并发清除
会在初始标记和重新标记这两步stop the world
G1收集器：特点：可预测的停顿，可以明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒
G1的运作大致分为以下几步：
初始标记
并发标记
最终标记
筛选回收
会在初始标记、最终标记、筛选回收时stop the world
</div>2019-10-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（18） 💬（1）<div>需求：
1.处理10kb的文本（文本存储和业务处理）
2.进程不卡死（高响应服务不中断）


分析：
1.请求不可丢失，响应要快，允许业务处理有一定滞后性。
2.发挥单机性能极限，但不越限导致卡顿或中断。

方案：
1.采用生产消费模式，接受到数据直接持久化，异步消费。为了实现数据积压，不丢失，可以走跨进程的实现，比如mq。
2.压测文本落盘和文本业务处理两个进程的负载能力，调整其接入层线程池线程数，找到最高单机并发上限，设置令牌桶做限流。通过水平扩提高总请求负载力。落盘和业务处理两块根据并发负载力调整相对集群的节点比例。


注：除非业务真有性能需求，不然千万别一个对象传到底。架设防腐层，业务解耦，对系统的扩展力很是重要。对于高速发展的项目（变化大且快），其价值远大于这么点性能提升。（先往易于演变的架构走，前期堆机器。真到业务量足够庞大，需要调优时再调优）</div>2019-08-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/05/06/f5979d65.jpg" width="30px"><span>亚洲舞王.尼古拉斯赵四</span> 👍（18） 💬（5）<div>通过一个对象池，池子里的对象大小是10k，每次请求申请对象，结束请求归还对象。另外提个意见，老师能在每次新课的时候讲述一下上一课提的问题的答案吗？</div>2019-08-22</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132" width="30px"><span>a、</span> 👍（10） 💬（0）<div>通过jstat 观察gc情况和分析gc日志，来合理分配堆内存，年轻代，年老代大小，尽量让对象在minor gc就能被回收，而不需要执行full gc。因为full gc执行速度慢，程序暂停时间就长</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg" width="30px"><span>渔村蓝</span> 👍（3） 💬（0）<div>拿到文本，异步写入硬盘，给队列一个路径，另一个线程监控队列，一个个路径拿出来加载到内存一个个处理。</div>2019-08-22</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIBabuBHlohpGYRDt4mwWghVDztHyRnC9SfyYnENUZNbCe8m05qQn0cHdiazU4eKmMtSQ0bHicwLLQ/132" width="30px"><span>vi</span> 👍（3） 💬（1）<div>1. 使用对象池，重复使用对象，每次处理文件中的行数据，更新到利用的对象中
2. 把对象外迁，使用中间件缓存对象，不被GC扫描到</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg" width="30px"><span>业余草</span> 👍（3） 💬（1）<div>除了方法论，还想要一个结合方法论的demo实现！</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg" width="30px"><span>许童童</span> 👍（2） 💬（0）<div>我会考虑使用享元模式，预先分配10KB 左右的对象池，当请求进来时，从对象池中拿一个来使用，用完后，自己释放，以此来自己回收，复用这些对象，减少对象的创建，从而减少垃圾回收。</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg" width="30px"><span>徐李</span> 👍（1） 💬（0）<div>关于问题：
1.增大硬件
2.当请求达到一定数目时，直接返回请求超时，就是不到后台，在网关处就返回
</div>2022-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/b5/a8/427a7b6d.jpg" width="30px"><span>石佩</span> 👍（1） 💬（0）<div>目前这些知识点对于消息队列来说都是必须的，每一点甚至最后在消息队列中都有单独的模块进行实现，文末留的问题就是消息队列实际面对的问题，Broker会接收各种消息进行文本处理 然后存储</div>2020-03-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3d/c9/9ea5b6b5.jpg" width="30px"><span>九黎曦</span> 👍（1） 💬（2）<div>内存管理这一块比较烦旳是，对象移动问题，因为对象需要移动，所以对象所有的引用都要修改，而这个过程中需要暂停，而且有些对象不支持移动，例如系统的对象等，所以内存管理的最佳策略是分析服务的对象周期制定内存区分配方案，如果参差不齐可以考虑拆分，这也是拆分微服务的策略之一</div>2020-03-26</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/hWjwsc6FgZfNkKiacOSUZicscNGFgdqvoo08QFQlfrg39srZJlZicbBP9zsLcDnKAkBfia2lZoKJ8h7QwTYiboiaRT6g/132" width="30px"><span>成都小郭</span> 👍（1） 💬（0）<div>disruptor,一个高性能队列,也有这样对对象的优化处理..初始化队列长度之后,就会创建那么多个对象,新消息进来就给对象赋值,减少了很多对象创建和销毁的时间</div>2019-09-19</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3DicN9rHZiblia3zNpKJ3hEegicBFZqzZBS7l0oSENZicnqw340TnHVQsfNL33OtGyxEVQuS8DmqhPDQ/132" width="30px"><span>笑傲流云</span> 👍（1） 💬（0）<div>老师，说下我的思路：1，jvm对字符串有优化，字符串是不可变对象，通过字符串常量池，可以复用一些字符串；2，文本10kb过大，是否可以拆分？建议分割文本，形成小对象直接在年轻代被垃圾回收，避免大对象直接进入老年代，引发频繁的full gc；3，Kafka底层存储机制大量使用了page cache，把子节码缓存在磁盘，避免大量对象引发gc问题。</div>2019-08-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d9/78/8a328299.jpg" width="30px"><span>佳佳大魔王</span> 👍（1） 💬（4）<div>创建一个静态类型的字符串来存放这个文本，这样每次改变字符串的内容就好了，而不用gc他</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/b8/52/5ab04f5d.jpg" width="30px"><span>廖子博</span> 👍（0） 💬（0）<div>为什么高并发下程序容易卡死？
1.垃圾回收和内存碎片整理需要暂停进程。
2.高并发垃圾回收和碎片整理更加频繁，而且暂停还会导致请求积压，进一步恶性循环。

如何解决？
1.减少一次性对象创建。特别是大对象。
2.使用对象池，实现对象服用。
3.自行实现内存管理（不推荐）
4.限流。比如，排队、降级、拒接访问等。</div>2023-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg" width="30px"><span>小红帽</span> 👍（0） 💬（0）<div>从java语言角度来看，要提高接口吞吐量，提高响应时间，减少系统卡顿，至少要考虑以下几个问题：
1、如何减少fullgc次数？我们可以通过提高硬件资源加大内存，然后调大新生代的大小。然后再业务使用过程中该对象最好引用传递一直到结束，不要频繁的创建对象；
2、因为吞吐量和响应时间是矛盾的，所以如果要提高吞吐量，我们可以同步改异步，先刷盘，再异步处理；
如果要提高响应时间，那只能降低吞吐量，压力测试后限流；
</div>2023-03-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg" width="30px"><span>谁都会变</span> 👍（0） 💬（0）<div>增加机器可以缓解这种一次性对象大量创建的问题吗？原来一台机器是每分钟创建10万，平分5台机器就是每分钟俩万。</div>2022-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg" width="30px"><span>徐李</span> 👍（0） 💬（0）<div>如何避免内存溢出和频繁的垃圾回收，正常并发小的时候，高级语言的自动内存gc不存在问题，都是在空闲的时候进行垃圾回收，垃圾回收导致的程序中断，用户不会有感知。但是在并发量大的时候，进行的垃圾回收，对程序的中断，让用户体验到程序确实是中断了，而且垃圾回收刚刚结束，立马这个又有并发请求进来，不断的gc，让用户感觉程序在不断的中断。

</div>2022-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg" width="30px"><span>再见理想</span> 👍（0） 💬（0）<div>申请内存：
1，计算对象的大小
2，找出对应大小的连续内存
3，将内存地址绑定到对象的引用上。
内存回收使用标记-清除的方法，难点在于内存碎片的整理及 执行内存回收时，程序处于短暂的不可用状态。
内存回收的时机:
1，系统定时执行自动回收。
2，内存不足时触发内存回收。
高并发系统需要注意，尽量少创建一次性的大对象，尽量传递对象应用，让对象可以重复利用。无法避免大的一次性对象，可以用对象池优化。</div>2022-04-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg" width="30px"><span>凯文小猪</span> 👍（0） 💬（0）<div>老师的问题很好 这里我再加一点假设 因为问题里是10KB的纯文本 这种请求一般在前台是很少见得。
假设按QPS1000计 那么固定带宽是 10KB * 1000 = 10MB 故这里还要注意千兆网卡是否能同时撑住上下行带宽。当然考虑到10KB文本的场景 个人感觉请求量不会再大了 且对时延可以适当放宽。

以下说下我的思路：
1. 增大Eden区 以PS G1这类针对前台应用的GC来说 。尽可能能地让朝生夕死的大对象在eden区消亡是最好的。故10MB 以 4:1:1的来反推 最后eden区最少需要： 10MB *2 * 4 * 10 = 800MB

简单说下这里的系数：
1）2为动态年龄判断的最小阈值，故此处要乘以2
2）4为eden区与from区默认配比
3）10这里为放大系数 此处为我个人的经验值

2.如果请求允许时延 或者说不是立即给出返回结果。那么通常为了增大吞吐量 此处会使用异步模式，或者扔到站点的线程池里或者扔到db里。
这里讨论下为什么不适合扔到db里。因为innodb是以16KB为一页 而这个10k的纯文本显然极具挤压行记录 造成innodb的页迅速占满。反而使得业内行记录极具减少 且考虑到10KB的随机IO写入 应该使用顺序IO下推的方式。所以我会使用MQ来推到下游服务来实现异步。</div>2021-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg" width="30px"><span>宙斯</span> 👍（0） 💬（0）<div>问题：如果我们的微服务的需求是处理大量的文本，比如说，每次请求会传入一个 10KB 左右的文本，在高并发的情况下，你会如何来优化这个程序，来尽量避免由于垃圾回收导致的进程卡死问题？
回答：申请一个全局10k空间，专门存放文本，请求完成不释放，后续再次使用。</div>2021-09-15</li><br/>
</ul>