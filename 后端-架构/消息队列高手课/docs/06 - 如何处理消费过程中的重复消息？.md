你好，我是李玥。上节课我们讲了如何确保消息不会丢失，课后我给你留了一个思考题，如果消息重复了怎么办？这节课，我们就来聊一聊如何处理重复消息的问题。

在消息传递过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。对使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。

比如说，一个消费订单消息，统计下单金额的微服务，如果没有正确处理重复消息，那就会出现重复统计，导致统计结果错误。

你可能会问，如果消息队列本身能保证消息不重复，那应用程序的实现不就简单了？那有没有消息队列能保证消息不重复呢？

## 消息重复的情况必然存在

在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：

- **At most once**: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。
- **At least once**: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。
- **Exactly once**：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg" width="30px"><span>微微一笑</span> 👍（255） 💬（1）<div>解决一个问题，往往会引发别的问题。若消息队列实现了exactly once，会引发的问题有：①消费端在pull消息时，需要检测此消息是否被消费，这个检测机制无疑会拉低消息消费的速度。可以预想到，随着消息的剧增，消费性能势必会急剧下降，导致消息积压；②检查机制还需要业务端去配合实现，若一条消息长时间未返回ack，消息队列需要去回调看下消费结果（这个类似于事物消息的回查机制）。这样就会增加业务端的压力，与很多的未知因素。
所以，消息队列不实现exactly once，而是at least once + 幂等性，这个幂等性让给我们去处理。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg" width="30px"><span>oscarwin</span> 👍（221） 💬（13）<div>我觉得最重要的原因是消息队列即使做到了Exactly once级别，consumer也还是要做幂等。因为在consumer从消息队列取消息这里，如果consumer消费成功，但是ack失败，consumer还是会取到重复的消息，所以消息队列花大力气做成Exactly once并不能解决业务侧消息重复的问题。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg" width="30px"><span>linqw</span> 👍（33） 💬（9）<div>学习完如何处理消费过程中的重复消息，写下自己的理解，老师有空帮忙看下哦
1、使用数据库的唯一索引防止消息被重复消费，感觉如果业务系统存在分库分表，消费消息被路由到不同的库或表，还是会存在问题。
2、为更新的数据设置前置条件，可以在消息中附带属性，比如当前账户的总金额，或者表中多加一个版本号字段，配合数据库行锁，类似乐观锁的概念，Java CAS，比较内存中的旧值是否和预先的旧值相等，如果是替换成新值。存在的问题和1类似。
3、记录并检查操作，在每个消息中维护一个全局唯一的ID，根据全局唯一ID进行判断消息是否已经被消费。存在的问题，全局唯一ID的实现有一定的复杂度，需要确保检查消费状态、更新数据、以及更新消费状态三个操作原子性，解决方式涉及到分布式锁和分布式事务，并且对高性能、高并发也有一定的影响。
4、尝试回答下课后习题①设置成Exactly once从消息队列的角度来看，为了确保消息没有被丢失或者重复，队列需采取一定的类似回查的手段，检测消费者是否有收到消息进行处理，在一定程度上会导致队列堆积等一系列问题，并且队列实现的复杂度上升。②从消费者的角度而言，因为消费者端和Broker Service端都是会各自集群，消费者端可能会存在网络抖动，导致Broker Service为了确保消息不丢失和重复，需要一直进行回查类似的操作，但是由于网络问题，导致队列堆积。
5、有个疑问如果队列的实现是At least once，但是为了确保消息不丢失，Broker Service会进行一定的重试，但是不可能一直重试，如果一直重试失败怎么处理了？</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg" width="30px"><span>Dovelol</span> 👍（29） 💬（2）<div>老师好，想问下关于幂等的情况，像设置帐户余额为100元，或者给余额为500的加100，如果有中间状态的变更或者ABA问题，也能算是幂等操作吗？</div>2019-08-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e1/cf/23a33fb4.jpg" width="30px"><span>年年</span> 👍（24） 💬（6）<div>这课买的太值了，是本平台最吸引我的一门课，一口气看了八篇</div>2019-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg" width="30px"><span>游弋云端</span> 👍（19） 💬（1）<div>我的理解如下：
1、按照您给的公式：At least once + 幂等消费 = Exactly once，所以对于消息队列来讲，要做到Exactly once，其实是需消费端的共同配合（幂等消费）才可完成，消息队列基本只提供At least once的实现；
2、从给的几种幂等消费的方案看，需要引入数据库、条件更新、分布式事务或锁等额外辅助，消息队列如果需要保障Exactly once，会导致消费端代码侵入，例如需要消费端增加消息队列用来处理幂等的client端，而消费端的形态可是太多了，兼容适配工作量巨大。故这个Exactly once留给用户自己处理，并且具有选择权，毕竟不是所有业务场景都需要Exactly once，例如老师讲的机房温度上报的案例。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg" width="30px"><span>leslie</span> 👍（13） 💬（2）<div>    对于老师说的为何都是支持At least once:是不是与以下几种情况相关；不对之处还望老师指出，因为我是刚好最近有时会有些异常数据联想到的也算是学习此课的初衷之一。
    1.硬件异常或者系统异常导致的数据丢失：这里想咨询老师一下，消息队列为何不能做成像数据库一样的用undo log和redo log去避免硬件的这种异常。
    2.就像为何网络协议中一样TCP和UDP的区别：消息反馈可能不是每一个反馈一次，有时是一批反馈异常，传输中可能会出现丢包或者顺序不一致。
          最近几个刚好同时在学：刘超老师的网络协议、操作系统以及您的消息队列觉得之间有彼此的关系；能力有限，故而仅仅是猜测，只能通过不断的向各位老师学习才能不断的找出问题提升自己，不足之处还望老师提点-谢谢。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e2/6e/0a300829.jpg" width="30px"><span>李先生</span> 👍（12） 💬（2）<div>我有个疑问，如果使用redis来实现幂等，那么在redis中设置的唯一id肯定要设置失效时间的。比如失效时间设置为10s，在这10s之内可以保证拥有唯一id的消息只被消费一次。那么10s之后又出现一个相同的唯一id，由于redis中这个唯一id已经失效，这个消息将再次被消费。这种如何处理呢？</div>2020-03-12</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132" width="30px"><span>a、</span> 👍（12） 💬（2）<div>因为目前消息队列，在发送消息给客户端的时候，一般需要客户端ack之后才能确定，这条消息是不是真的被消费了。
1.如果客户端设置的是自动ack，那么mq就能保证只发送一次，但是这样会因为客户端消费消息不成功，而导致消息丢失
2.如果客户端都设置手动ack，这样又有一个问题，如果mq发送消息给客户端成功了，客户端也已经消费完成了，就在准备ack的时候，和mq失去了联系，这时候mq是不知道，这条消息是否真的被消费了，只能选择重发消息。
所以我觉得:如果消息队列保证了只发一次，那么消息队列就无法保证消息由于客户端消费失败而不丢失，就好像分布式系统中的cap理论，只能保证其中的两种，而无法三个都保证。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" width="30px"><span>张三丰</span> 👍（8） 💬（3）<div>文中有句话想跟老师确认下，如下:

”t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；

t1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。”

1.这是因为每个队列配置多个消费组导致的吧？
2.通常情况下配置多个消费组是为了提升消费能力？
3.如果配置多个消费组是为了提升消费能力，那么为什么每个消费组配置多个消费者？反正每个消费组只有一个消费者能成功消费到消息。每个消费组只配置一个消费者不行吗？</div>2019-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg" width="30px"><span>小伟</span> 👍（7） 💬（2）<div>文中有句话想跟老师确认下，如下:

”t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；

t1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。”

这个情况只能在有消息重发，且重发到了不同队列上才可能发生吧，否则再怎么重发都会由相同的消费者消费。</div>2020-01-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/08/24/1d3bafaf.jpg" width="30px"><span>Spring coming</span> 👍（6） 💬（1）<div>请教老师，看到一个同学的评论:&quot;有一个疑问，为更新的数据设置前置条件 中的例子。如果账户 X 当前的余额为 500 元，将余额加 100 元。可能会有类似CAS中的ABA问题，所以还是使用版本号递增的方案的更好一些吧&quot;.  为啥可能有aba问题？ 如果有重复消息，不管这两条谁先成功，另外一条应该不会成功，因为有500这个限制条件。是不是我哪里没理解到位，希望老师解答</div>2020-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg" width="30px"><span>Better me</span> 👍（6） 💬（1）<div>对于思考题，三种服务质量标准都有各自的使用场景，这就好比数据库中隔离级别的实现，Serializable隔离级别不仅可以避免脏读、不可重复读，还避免了幻读，但同时代价花费也是最高，性能很低。文中的Exactly once(恰好一次)基本类似，虽然一定程度上可以避免消息重复以及消息丢失，但其实现必然也意味着高代价、低性能。最后深深的感受到架构的设计的关键就是判断和取舍，以及针对特定场景去做特定的实现。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg" width="30px"><span>小伟</span> 👍（4） 💬（3）<div>李老师，我有个问题： 
    我看很多小伙伴们留言说业务端实现幂等就完全解决问题了，但我觉得幂等不是银弹，不能解决所有问题。
    幂等只能保证消息被重复消费后的结果正确，但重复消费消息本身也是有代价的。举例，一个业务操作是写文件，执行成本是锁定文件、IO、网络传输、CPU时间片占用等，这些都是没有价值的，类似于不挂挡踩油门，听响而已。
    个人观点，如果业务执行开销较小，那么业务幂等就够了。如果业务执行开销大，那么前置条件判断就比较好，虽然条件的判断也会有不小开销，但两害相权取其轻。如果任一种的代价都太大，那么看能否拆分业务操作，拆分后哪个代价小就用哪个。
    另，根据老师的定义，这里的幂等“其任意多次执行所产生的影响均与一次执行的影响相同”应该不包含前置条件检查和记录并检查，因为这两个都没有“多次执行”，所以应该是与幂等并列的解决重复消息问题的实现方式。
    有不妥处，请不吝指教。</div>2020-01-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg" width="30px"><span>james</span> 👍（4） 💬（2）<div>第三种方案，b也会收到同样消息的原因是啥，是a消费时间太长重发导致的吗？ kafka中每个consumer一个queue不会出现这种场景，而rocketmq的顺序消费也不会出现</div>2019-11-10</li><br/><li><img src="" width="30px"><span>Geek_865595</span> 👍（4） 💬（3）<div>具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。
请问：这个消费状态是什么？怎么获取这个消息状态，然后怎么设置它的状态？</div>2019-08-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg" width="30px"><span>丁小明</span> 👍（3） 💬（1）<div>老师关于幂等性第三点有些疑问，是不是队列开启ACK模式就能避免这个情况发生呢。重复消息投递应该投到相同队列。这样就不会出现一个consumerA还未消费完返回ACK之前，另一个consumerB就去消费下一条消息。对于同一个队列来说，队列是不是保证了串行消费。这样就只需要保证业务流水号唯一就行了。希望老师解答</div>2020-04-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/aa/5e/9be28107.jpg" width="30px"><span>Josey</span> 👍（3） 💬（1）<div>老师，我想问一下，假如消费者和生产者连接的不是同一个数据库，那怎么能通过数据库约束的方式实现幂等操作？还有全局ID的形式，如果这个ID的消息被消费过是要把处理状态更新到数据库中吗？如果也是连接的不同数据库，这种情况下怎么处理？忘老师回复！</div>2020-03-04</li><br/><li><img src="" width="30px"><span>whhbbq</span> 👍（3） 💬（1）<div>老师好，看了幂等方法之后，感觉第一种方法和第三种方法非常类似，区别就是第三种方法多了一个消费状态，不知道消费状态包含哪些值? 我理解， 应该包含消费中和消费完成，并且将【全局ID+消费状态】作为数据库唯一索引，应该可以解决，重复消费问题。</div>2020-02-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/92/69/b04bd4cd.jpg" width="30px"><span>特铮</span> 👍（3） 💬（1）<div>“更新数据的同时将版本号 +1”和“记录并检查结果”比，实现难度有区别么，如果存储引擎没有原生支持的话？</div>2020-02-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg" width="30px"><span>攀攀</span> 👍（3） 💬（1）<div>kafka接收线上mysql的binlog日志来进行数据同步  在分布式消费的情况下  可能出现分布式多台机器同时消费相同数据的问题  
如果说kafka保证了每个分区的消息顺序  那么我们只要按照主id进行hash 就可以保证相同的id 只会发往相同的机器  老师  这么说对吗 </div>2019-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/a5/36/d93c851b.jpg" width="30px"><span>jinny</span> 👍（3） 💬（1）<div>老师，关于采用消息中带上更新条件的方法，我有一个问题：就那个当余额为500时，执行加100，如果当前消息被消费前，下一条消息到来时，数据库余额还是500，这时设置更新条件也是500，这种问题怎么解决？</div>2019-08-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg" width="30px"><span>饭粒</span> 👍（2） 💬（1）<div>请教老师：
1）利用前置条件防重复消费那块，如果当前消息没有被消费过，但是有中间账户有其他操作（转账、消费）使得账户的余额不再是500，这样消息会被错误的判重？
2）全局 ID 查询消费状态的分布式问题，查询用 select * from t where id=8 for update 给这条消息加锁可以吗？</div>2019-11-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3f/1e/8e184acb.jpg" width="30px"><span>荆仙</span> 👍（2） 💬（1）<div>有一个疑问，为更新的数据设置前置条件 中的例子。如果账户 X 当前的余额为 500 元，将余额加 100 元。可能会有类似CAS中的ABA问题，所以还是使用版本号递增的方案的更好一些吧
</div>2019-10-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/f2/70/8159901c.jpg" width="30px"><span>David Mao</span> 👍（2） 💬（1）<div>请教一下老师，重复消息多的话可能会影响效能，消息队列有这方面的设计考量吗？</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ee/67/d6d9499e.jpg" width="30px"><span>木木木</span> 👍（1） 💬（2）<div>没明白，“如果账户 X 当前的余额为 500 元，将余额加 100 元&quot;和“检查消息执行状态，发现消息未处理过，开始执行账户增加 100”，这两者有啥区别，不都是消费端compareAndUpdate吗，都可以用普通数据库事务就能实现</div>2019-08-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/4d/37/d6359a78.jpg" width="30px"><span>星帆</span> 👍（1） 💬（1）<div>mqtt服务器有推荐的吗？</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9c/40/6323850e.jpg" width="30px"><span>Jian</span> 👍（1） 💬（1）<div>在分布式环境下，如果让message queue负责实现exactly once，会导致其处理极其复杂，以及性能低下——这样的产品性价比不高。在分布式环境内，借助其他组件，结合特定的业务，才是解决exactly once最具性价比的方式。</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg" width="30px"><span>许童童</span> 👍（1） 💬（1）<div>老师你好，在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug。
不应该是保证隔离性吗？</div>2019-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（1） 💬（1）<div>我觉得主要是因为在性能上对恰好一次做了取舍</div>2019-08-03</li><br/>
</ul>