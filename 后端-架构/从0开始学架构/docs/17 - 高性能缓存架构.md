虽然我们可以通过各种手段来提升存储系统的性能，但在某些复杂的业务场景下，单纯依靠存储系统的性能提升不够的，典型的场景有：

- 需要经过复杂运算后得出的数据，存储系统无能为力

例如，一个论坛需要在首页展示当前有多少用户同时在线，如果使用MySQL来存储当前用户状态，则每次获取这个总数都要“count(\*)”大量数据，这样的操作无论怎么优化MySQL，性能都不会太高。如果要实时展示用户同时在线数，则MySQL性能无法支撑。

- 读多写少的数据，存储系统有心无力

绝大部分在线业务都是读多写少。例如，微博、淘宝、微信这类互联网业务，读业务占了整体业务量的90%以上。以微博为例：一个明星发一条微博，可能几千万人来浏览。如果使用MySQL来存储微博，用户写微博只有一条insert语句，但每个用户浏览时都要select一次，即使有索引，几千万条select语句对MySQL数据库的压力也会非常大。

缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。

缓存能够带来性能的大幅提升，以Memcache为例，单台Memcache服务器简单的key-value查询能够达到TPS 50000以上，其基本的架构是：

![](https://static001.geekbang.org/resource/image/c7/15/c70fdcaab49fe730380d2207017c4215.jpg?wh=3065%2A2187)

缓存虽然能够大大减轻存储系统的压力，但同时也给架构引入了更多复杂性。架构设计时如果没有针对缓存的复杂性进行处理，某些场景下甚至会导致整个系统崩溃。今天，我来逐一分析缓存的架构设计要点。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/ce/46/67c145ee.jpg" width="30px"><span>bluefantasy</span> 👍（368） 💬（36）<div>我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加redis缓存解决了问题。

 对于缓存雪崩问题，我们采取了双key策略：要缓存的key过期时间是t，key1没有过期时间。每次缓存读取不到key时就返回key1的内容，然后触发一个事件。这个事件会同时更新key和key1。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg" width="30px"><span>王磊</span> 👍（221） 💬（11）<div>经常我说到缓存的时候，面试官问我，数据库自身不是有缓存吗，标准答案是怎么回击他?</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/95/6f0aad03.jpg" width="30px"><span>loveluckystar</span> 👍（93） 💬（7）<div>讲一个头两天发生的事情，我们的一个业务背后是es做db，之前是通过redis做缓存，缓存一段时间后失效再从es读取，是业务访问加载缓存的方式。有一天线上es集群机器单台出现问题，返回慢，由于分布式的缘故，渐渐拖满了所有请求，缓存失效来查询es发生了超时，加载失败，于是下次访问还是直接访问es。最终缓存全部失效，qps翻了好多倍，直接雪崩，es集群彻底没有响应了。。。之后我们只好先下线这个缓存加载功能，让集群活过来，最终改造缓存加载方式，用后台进程去更新缓存，而不用业务访问加载。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ca/e4/f15a1cf0.jpg" width="30px"><span>三月沙@wecatch</span> 👍（83） 💬（3）<div>好的缓存方案应该从这几个方面入手设计：
1.什么数据应该缓存
2.什么时机触发缓存和以及触发方式是什么
3.缓存的层次和粒度（ 网关缓存如 nginx，本地缓存如单机文件，分布式缓存如redis cluster，进程内缓存如全局变量）
4.缓存的命名规则和失效规则
5.缓存的监控指标和故障应对方案
6.可视化缓存数据如 redis 具体 key 内容和大小</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/05/d8/cd269378.jpg" width="30px"><span>一叶</span> 👍（71） 💬（3）<div>笔记：
书籍：
《高性能Mysql》
《unix编程艺术》：宁花机器一分，不花程序员一秒

提升性能：
先单机，有压力后优先考虑sql优化、db参数调优，还有硬件性能(32核&#47;16G&#47;SSD)优化，不行还可以再考虑业务逻辑优化、缓存。不要一上来就读写分离、集群等，能单库搞定的就毫不犹豫的单库。

---

主从读写分离
适用于单机无法应付所有请求，且读比写多时，读写分离还可以分别针对读写节点建索引来优化。
对实时性要求不高：刚写入就读会有延迟，同步数据特别大时，延迟可能达到分钟级（可用缓存解决：2-8原则，挑选占访问量80%的前20%来缓存）。
TODO主从还能设置自增长key不一样？

分库分表（甚用，增加很多复杂度）
几千万或上亿
分库时机：单机性能瓶颈，1业务不复杂，但整体数据量影响到数据库性能；2业务复杂，需要分系统由不同团队开发，使用分库减少团队耦合。（分库导致不能join和事务（有方案但性能太低用了跟没分库差别不大，用最终一致性&#47;事件驱动））
分表时机：单表数据量大拖慢了sql性能，做垂直（将常用和不常用字段分开）或水平拆分（id分段、hash路由、添加路由表等）提高速度。（那么join、count、分页排序等就变得复杂）
TODO环状hash 一致性hash？

nosql
（nosql——not noly sql 本质上是牺牲ACID中的某个或某几个属性，以解决关系数据库某些复杂的问题）
关系数据库：强大的sql功能和ACID属性，发展了几十年技术相当成熟 Mysql &#47; Postgresql 
k-v存储：解决关系数据库无法存储数据结构的问题 Redis &#47; Memcache （redis不太适合key的value特别大，这种情况会导致整个redis变慢，这种场景mc更好-&gt;参考IO模型 redis单Reactor单进程读写大value会阻塞所有业务 持久化也会）
文档数据库：解决关系数据库强schema约束，查询不存在的列会报错，扩充很麻烦还会长时间锁表  MongoDB 
列式数据库：解决关系数据库处理大数据分析或统计时IO高的问题，关系数据库即使只处理某列也会把整行查询到内存中 HBase &#47; Greenplum
全文搜索引擎：解决关系数据库全文搜索like扫描全表性能问题 ElasticSearch &#47; solr
LevelDB 内存型？
时序数据库？：实时计算统计实时监控 influxDB
OLAP OLTP HTAP？

缓存（千万千万不要设计复杂的缓存，到时候各种不一致问题烦死你）
cdn、nginx缓存、网关缓存、数据层缓存redis、db本身也有缓存(sql结果缓存、读取的磁盘分页缓存)
缓存穿透：1本身无数据(添加默认值缓存&#47;布隆过滤器[整型自增key？]) 2未生成缓存(识别爬虫并禁止 但可能影响seo)
缓存雪崩：缓存实效后大家都在更新缓存导致系统性能急剧下降（1消息队列通知后台更新、2使用分布式更新锁）
缓存热点：大部分业务都会命中的同一份缓存，比如1000w+粉丝的微博消息，复制多分缓存副本，key里面加副本编号将请求分散，且设置过期范围，而不是所有副本固定同一过期时间。
缓存框架看一下设计思路：echcache、网友分享https:&#47;&#47;github.com&#47;qiujiayu&#47;AutoLoadCache


</div>2018-09-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9f/d5/bc83e702.jpg" width="30px"><span>mapping</span> 👍（26） 💬（1）<div>计算机界两大难题：命名和缓存过期。没用缓存的时候，想着怎么用缓存提升性能，用了缓存又担心数据更新不及时。技术上希望所有的请求都能命中缓存，业务上又恨不得数据实时最新。所以就会引入各种缓存过期策略，如设置过期时间，按规则删除，打版本。这些应该在前期设计缓存系统时规划好，我们最早是将 sql md5 作 key 查询结果存入缓存，结果业务系统数据不一致，要清除缓存简直是噩梦，只能祭出绝招重启 memcache，后面改成按规则删除，在 key 中加上业务和用户的前缀，可以很方便删除某个业务或某个用户的缓存。以上过期策略在前端浏览器也是这样，最简单就是 web 服务器设置静态资源缓存过期时间，如果业务频繁发新版本，过期时间不宜设置太长，但其实每次变动的文件很少，这种策略会导致大部分缓存命中率不高。按规则删除，早期很多网站上会有诊断助手类的东西，页面加载错误点下诊断助手就帮你清除缓存，原理就是对静态文件逐一带上 no-cache 请求头发送 ajax 请求强制覆盖缓存（跟 DevTools 中 disable cache 原理一样）。打版本其实就相当于让浏览器请求一个新版本文件，对于老版本文件就让它在缓存中自生自灭。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg" width="30px"><span>公号-技术夜未眠</span> 👍（23） 💬（1）<div>上缓存架构的时候，结合以前的实际经历，会有几个值得注意的地方:

1 哪些数据才真正的需要缓存？缓存也并非银弹。既然允许数据缓存，那么在你是可以接受在一定时间区间内的数据不一致性的。(当然可以做到最终一致性)

2 确定好1后，就需要会数据类型进行分类，比如业务数据缓存，http缓存等

3 根据数据类型及访问特点的不同选择不同缓存类型的技术方案。

请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？

</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/9e/10/3cb10bf7.jpg" width="30px"><span>醇梨子</span> 👍（21） 💬（5）<div>华仔，请教一下，针对这种高并发缓存架构设计中，缓存和存储系统一致性问题怎么保证？比如说商品浏览人数，需要存库，然后又需要放缓存，需要频繁更新数据库。</div>2018-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/87/57/645159ee.jpg" width="30px"><span>鹅米豆发</span> 👍（14） 💬（1）<div>       1、最早也是采用后台用数据库，前台用关系型数据库+被动缓存的模式。结果是经常的性能抖动，且缓存一致性问题很难解决。后来我们的多数系统，都采用了前后台分离的模式——后台原始数据仍然是关系型数据库，前台使用缓存作为数据源，两者之间数据实时同步+定时同步+人工触发结合。
       这个模式，基本根除了穿透，雪崩，不一致，性能抖动这些。但带来了新的问题，比如数据丢失且不可恢复。我们的做法是，让缓存具备相对可靠的持久化机制+运维体系。
       2、遇到过几次热点问题，感觉这个更加棘手些。第一种情况，单Key数据结构本身过大，单个分片出现热点，单次访问的复杂度变大。这个相对容易，可以对key进行拆分，使用hashtag机制分片。第二种情况，数据分片普遍不均衡，较少遇到，遇到就比较棘手。第三种情况，数据分片均衡，但访问不均衡，可以增加副本数量。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/dd/bd/9b93ea26.jpg" width="30px"><span>blacknccccc</span> 👍（13） 💬（1）<div>对于像淘宝商品列表筛选项特别多，组合起来会更多，这样在后台做更新缓存怎么处理，难道是把每一种组合的分页数据都缓存下来吗</div>2018-07-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg" width="30px"><span>jacy</span> 👍（12） 💬（2）<div>商品列表中，像商品描述等信息，缓存更新不及时影响不大，但某些重要数据，如价格，需要及时更新的数据，有没什么好的办法做到刷新。对于价格这种关键数据，不缓存，直接从数据库查询，是否可行。或者在用户查看商品详情时再去数据库查询价格，但可能出现列表中的价格和详情页中的价格不一致。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" width="30px"><span>李</span> 👍（9） 💬（1）<div>感觉概念理解上有点差异，缓存穿透出现在缓存失效要去查数据库。缓存击穿则是一个key失效导致高并发访问数据库压力增大。缓存雪崩则是大量缓存key失效或者缓存宕机了，导致数据库并发压力增大。感觉老师您把缓存穿透说成了击穿，击穿说成了雪崩。不知道我是否理解有问题？</div>2018-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg" width="30px"><span>何磊</span> 👍（9） 💬（1）<div>遇到过一次缓存失效导致缓存穿透，很多请求的压力直接到了db。为了处理这种情况，我采用的方案就是：key永不过期，后台有个进程定时更新所有缓存。
文中提到的结合消息队列来更新更具有时效性，非常棒，看到评论中的有一个双key机制，设计很巧妙，不过成本太高了。相当于成本翻倍。</div>2018-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c6/e5/7e86498f.jpg" width="30px"><span>cqc</span> 👍（9） 💬（1）<div>1个问题：关于后台更新，既然缓存服务器内存不足，需要剔除数据，那么后台更新再次触发查询，是否又会导致其他一些缓存数据被剔除，这感觉像是陷入一个循环了
1个思路：我们之前的web项目，对于缓存热点数据，为了减少服务器的压力，在客户端引入了缓存：CDN加local storage，感觉对服务器端压力分散还是很有效果的。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ca/61/b3f00e6f.jpg" width="30px"><span>byte</span> 👍（8） 💬（1）<div>业务上通过Redis集群缓存网络数据，分布在北上广三地，3个数据中心，集群规模是80台物理机共1000个左右实例1主3从。线上出现过跨地域集群数据频繁全量同步打爆交换机的问题，导致整个服务不可用。通过排查发现是网络延时导致频繁全量同步以及服务器电源过热导致从服务器频繁重启。解决方案是跨地数据同步通过kafka试下，再接入各地Redis集群，电源问题通过更换硬件解决。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/6c/3d/f9ec02ea.jpg" width="30px"><span>倔强小小🐤</span> 👍（8） 💬（1）<div>我们系统是做美术馆的3d展示的，后台配置的数据有点多，画框数据有几m，单个模型数据有几百k，最早直接mysql直接读取，后来用redis但是感觉效果不理想，又引入ehcache，发现不经过网络传输性能很好，经过网络传输后网络一般还是卡的很，后来又在前端用local storage进行缓存，后端通过rabbitmq进行消息通知前端清除本地缓存，缓存设置有效期都是一天，请问下我们这种情况有更好的方案吗</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/58/50/abb7bfe3.jpg" width="30px"><span>june peng</span> 👍（7） 💬（1）<div>你好，在缓存雪崩后台更新策略里，比如1000个同时访问一个失效的缓存key，如果给这个key加读写锁，这样保证只有一个访问存储系统，其它999个人虽然慢点，但是至少能保证业务不会挂。如果用消息队列，就是前台只拿缓存key里的数据（不能访问存储系统），如果key不存在就发给消息队列更新，如果启多个进程去接受这些消息，依然不能避免后台击穿存储系统，难道只有启用一个进程？这样又太慢，可否进一步说明这种方案的复杂点在哪？谢谢</div>2018-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg" width="30px"><span>Sic Pavis</span> 👍（6） 💬（4）<div>刚好前段时间就有一个问题。
产品反馈：后台更新的配置不生效，需要过几小时到半天不等的时间才能生效。
从数据库确认持久化数据没问题，因此怀疑是缓存问题。

我们的缓存设计是：业务key加一个缓存版本号做key，每次更新数据对应缓存的版本号就+1。
前台定期扫描缓存版本号来实现缓存的更新。

于是我查到了线上最新的版本号去缓存服务器查询，见鬼，数据也是正常的。排查了几天没有结果，无奈上线一个版本打了debug日志，终于找到原因了。

我们的服务是双中心的，两边各存有一份缓存版本号，不知道什么原因，导致一边的缓存版本号比另外一个集群的多了3。由于我们的更新策略不是删掉无效的缓存，而是更新缓存的key，因此旧版本的缓存数据实际上还在缓存服务器上。更要命的是缓存服务器做了双中心同步（为啥同步暂且不提），这样就导致实际上一边集群读取的实际上是另外一个集群几个版本前留下的缓存数据。需要等待这个数据过期后，才能正常从数据库加载数据。</div>2018-08-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（5） 💬（1）<div>本来是看在《数据结构和算法之美》看一致性哈希，然后看到了雪崩效应，然后找到缓存雪崩，然后找到了这里。

我对于缓存雪崩 Cache avalanche的定义有一点疑问，感觉似乎更像是缓存击穿 Cache breakdown，当然这两个的定义本来就有相似的地方。缓存击穿更多的强调大量缓存同时过期，而缓存雪崩在缓存过期的基础上，又加上了缓存服务器宕机。

就好比，一台缓存服务器宕机，然后导致其他的缓存服务器压力变大，进而影响整个缓存系统。就好像是雪崩时的第一片掉落的雪花。

不过，定义本身并不重要，主要还是对于场景的描述和解决方案。

有意思的是，似乎在维基百科上并没有 Cache avalanche, Cache breakdown, Cache penetration 的定义。</div>2020-05-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cd/ee/f204ba32.jpg" width="30px"><span>100kg</span> 👍（5） 💬（2）<div>你好，我想请教下，如果两台mysql互为主从，其中一台主键自增步长设置为2，另一个为1，这样做会影响性能吗？比如索引的连贯性之类的</div>2018-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg" width="30px"><span>王磊</span> 👍（5） 💬（1）<div>关于缓存雪崩的定义，文中的例子是说单条缓存在生成的时间间隔内有大量相同请求查询存储系统，除此之外，记得还有一个更典型的场景，是大量缓存同时过期，导致大量不同请求去查询存储系统(数据库)。请点评。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg" width="30px"><span>kissrain</span> 👍（4） 💬（11）<div>请教一下华仔，像用户下单场景，是先写入数据库再失效缓存还是先失效缓存再写入数据库呢？</div>2019-01-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg" width="30px"><span>王磊</span> 👍（4） 💬（1）<div>&#39;后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些.&#39; - 没觉得简单啊，因为如文中所说，后台更新也可能会出现多个业务线程都发送了缓存更新消息，这种情况我理解也需要有分布式锁来避免多个相同请求查询存储系统，否则在判断的时候，因为缓存在构建还没有准备好。</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg" width="30px"><span>探索无止境</span> 👍（4） 💬（4）<div>文中提到了缓存穿透存储数据不存在的情况，存储空对象，但是如果黑客恶意发起连续的攻击，而且key不相同，那么也会让缓存服务器的内存被迅速占满，这个方案感觉还是有些问题的</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg" width="30px"><span>ZHANGPING</span> 👍（3） 💬（1）<div>在网上看到过一个有意思的方案：把所有确定的Key都放在布隆过滤器，先判断Key是否存在，来避免缓存穿透。</div>2021-06-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/61/df/11db20f2.jpg" width="30px"><span>北北也是程序员</span> 👍（3） 💬（3）<div>我来说说我做过的一个项目设计的缓存策略吧，因为需要实时查询所有open状态的基础订单列表信息，所以有个后台进程每分钟刷新一次缓存。但因为open态order太多，导致redis序列化与反序列化过程太久而连接中断，后来我采用的一个方案就是根据每次查询必选的组合查询条件分别分组然后以单个查询值作为key放到缓存中，这样既达到了按照查询条件过滤的情况，又缩减了每次存取数据的字节数。可能比较简单吧，感觉也没有什么特别的。哈哈😄</div>2018-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/ce/3d/385b8263.jpg" width="30px"><span>星火燎原</span> 👍（3） 💬（3）<div>如果用redis做分布式锁 从业务上设置超时时间为1s 但是有一些逻辑单元确实需要执行比如3s才能释放掉锁。那么这种“正常的异常情况”应该怎么解决呢？</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ba/78/3821b5b1.jpg" width="30px"><span>啊哈</span> 👍（3） 💬（1）<div>如果采用商品分页缓存，怎么实现更新呢，商品对实时性还是有要求的吧？比如更改价格，或者新上架的商品，怎么能比较实时的展现？还有商品页还是很复杂的，除了筛选还有很多的排序等等，这些场景怎么应用缓存吗？</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/28/3b6546e8.jpg" width="30px"><span>Snway</span> 👍（3） 💬（1）<div>订单设置的缓存有效期是永久的，但再一次上线后，更新缓存的后台线程出问题，导致用户查看不了最新订单数据，引起大量客诉！</div>2018-06-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e5/0d/b4258141.jpg" width="30px"><span>姜泮昌</span> 👍（3） 💬（1）<div>目前我们还没用上缓存技术，所有请求都直接访问了数据库，导致数据库集群压力大，cpu、内存、IO常常过高，请问项目初用缓存，比如redis ，有什么指导原则或技巧吗？是缓存热点sql还是热点功能还是根据其他原则缓存呢？</div>2018-06-05</li><br/>
</ul>