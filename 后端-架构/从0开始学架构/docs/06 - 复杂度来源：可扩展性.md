你好，我是华仔。复杂度来源前面已经讲了高性能和高可用，今天我们来聊聊可扩展性。

可扩展性是指，系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。

由于软件系统固有的多变性，新的需求总会不断提出来，因此可扩展性显得尤其重要。在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题；后来的设计模式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。

设计具备良好可扩展性的系统，有两个基本条件：

1. **正确预测变化**
2. **完美应对变化**

但要达成这两个条件，本身也是一件复杂的事情，我来具体分析一下。

## 预测变化

软件系统与硬件或者建筑相比，有一个很大的差异：软件系统在发布后，还可以不断地修改和演进。

这就意味着**不断有新的需求需要实现**。

如果新需求能够少改代码甚至不改代码就可以实现，那当然是皆大欢喜的，否则来一个需求就要求系统大改一次，成本会非常高，程序员心里也不爽（改来改去），产品经理也不爽（做得那么慢），老板也不爽（那么多人就只能干这么点事）。

因此作为架构师，我们总是试图去预测所有的变化，然后设计完美的方案来应对。当下一次需求真正来临时，架构师可以自豪地说：“这个我当时已经预测到了，架构已经完美地支持，只需要一两天工作量就可以了！”
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/18/07/9f5f5dd3.jpg" width="30px"><span>憶海拾貝</span> 👍（224） 💬（4）<div>设计模式的核心就是，封装变化，隔离可变性</div>2018-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg" width="30px"><span>Geek_zbvt62</span> 👍（140） 💬（7）<div>我平时工作中更多提醒自己压抑一下想预测各种需求变化的欲望。因为之前总是过度设计。压抑并不是说不去考虑各种变化，而恰恰需要把可能性大的变化点一一罗列出来，分维度打分，维度包括 可能性大小？长期还是短期会变化？如果发生变化，目前的组织和系统要花多大成本适应变化。这些变化正是李老师之前说过的各种复杂度上的变化，比如用户量激增带来的性能要求。此外还包括一个业务功能逻辑上的变化。
在经过上面分析后往往会给出“上中下”策的设计方案，下策一般考虑的变化少，短视，但迅速，修改小，立竿见影。上策一般看重远期，但成本高很高，也很可能预测不中。
最后还要分析，如果决定采用下中策，如果预测的变化发生了，系统修改为中上策的代价有多大，有些代价几乎是无穷大的，比如必须中断服务进行升级。如果代价小，那可以放心采用下策或中策。如果答案是否，可上策当前的代价又真的不可接受，那又要返回头重新分析了
实践发现这个方法挺好用，尤其当有人来咨询架构方案时，往往对给出的结果比较满意</div>2018-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/74/3d/54bbc1df.jpg" width="30px"><span>Jaime</span> 👍（70） 💬（5）<div>曾经在游戏中使用过工厂模式和状态模式，但交个另外一个人维护了一个月，我回头去看，代码已经没办法入眼😅😅😅。虽然说设计模式确实是程序员的基本功，但其实很多程序员也不是很明白设计模式的。对于现在来说，我比较喜欢的做法就是先分层，层与层之间用消息解耦，在层内部的实现我会分模块出来，遵守单一职责原则。同时会积极跟业务部门沟通，预测一下下一步的方向。虽然不是每次都准确，但也大概做到心中有数，对于现在的系统也有个预估。这几年的编程经验给了我一些启发，一定不要过分设计，首先要能正确工作的软件是最重要的。</div>2018-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg" width="30px"><span>Mark Yao</span> 👍（43） 💬（5）<div>说说我们的消息系统，原始需求是用户操作业务后给用户手机短信提醒，设计初衷考虑到可能涉及到多家第三方短信服务商。我们统一定义发送短信接口，定义实时和定时发送方式，在内容形式定义模版接口接受不通形式自定义模版的内容，后来把短信定义为消息中的一种，如微信、短信、站内消息、app push 都为消息，又抽象出来消息接口，消息开发中使用多种设计模式。最后发现就就一直使用短信服务。我困惑地方，扩展性需要在什么时候做，做到什么程度呢？</div>2018-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e5/0a/13c0f653.jpg" width="30px"><span>带刺的温柔</span> 👍（18） 💬（1）<div>厉害了程序员都想要开发一个完美的灵活可扩展的系统永无止境，而往往陷入过度设计的泥潭，最后累的要死得到的可能是貌似完美符合了扩展性但是非常不好用甚至有点画蛇添足的感觉。觉得扩展性不是一触而就的也不是一成不变的它是一它是不断改进的过程，不变的是满足需求是底线在追求扩展性的路上把风险控制在最低。我在兼容简单与扩展性上我觉得一定的冗余是个不错的选择，老师你觉得呢</div>2018-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c5/f2/57f33e71.jpg" width="30px"><span>武洪凯</span> 👍（13） 💬（1）<div>老师能不能推荐一些构架的书，中文的英文的都可以。课程讲的很好，不过很多细节深扣的话感觉还要继续看书。</div>2018-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg" width="30px"><span>明翼</span> 👍（10） 💬（1）<div>设计模式里面的依赖倒置原则，上层不依赖下层，下层也不依赖上层，两者都依赖于抽象，抽象是稳定的，上层和下层都是可扩展的，相当于文章说的一个稳定层抽象，两个变化层…</div>2018-05-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg" width="30px"><span>zhou</span> 👍（9） 💬（1）<div>老师你讲的看起来有点吃力，能否推荐几本书让我先入个门</div>2018-06-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cf/bb/22af0e52.jpg" width="30px"><span>孙振超</span> 👍（9） 💬（1）<div>之前看过一篇介绍架构的博文，里面提到一个观点：衡量架构的好坏是变更的成本。扩展性的好坏很依赖于设计人员对问题的抽象能力，如同文中所描述的把系统分为稳定层和抽象层两部分，就是对问题进行了抽象。具体而言，在设计上经常采用的方法是模板+接口，将具体的业务逻辑抽象为固定的几个步骤，每一个步骤是一个接口，而后根据不同的对应的参数动态选择不同的实现，这样当已有的业务发生变更时，只需要调整相应的逻辑即可，做好关注点分离，面对新增的业务逻辑和形态，添加对应的实现即可，无需修改已有的内容。
另外就是利用动态修改能力（比如java中无需重启服务修改某一个属性的值）来应对业务变动，提升扩展性</div>2018-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（6） 💬（1）<div>老师在留言里面提到，“设计的时候考虑可扩展性，但是如果代价比较大，就展示不做，有需要时再重构”，这个比较实用。

之前做过的系统对于可扩展没有什么要求，实在不行的时候，就会考虑推到重来。

可扩展性并不想前面提到的高性能和高可用那么容易衡量，因为扩展的可能性还是要小一些，或者说可扩展性并不是特别的明显。

按照专栏里面的说法，设计模式好像更多的是考虑可扩展性，感觉上似乎对于高性能和高可用意义不大。但是反过来，对于普通的应用开发者来说，是不是遇到扩展性问题（或者需求变化）的可能性要远大于高性能或者高可用？</div>2020-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/de/cc/9c6f6615.jpg" width="30px"><span>王念</span> 👍（6） 💬（1）<div> 先满足功能 再重构框架</div>2018-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg" width="30px"><span>建强</span> 👍（5） 💬（1）<div>我曾经用过的可扩展编程技术：
1.把一个通用的处理过程用一个函数来实现，把一些会变化参数放到一个配置文件活数据库表中。
2.编程面向接口，不是面向具体的实现细节。
3.采用封装、继承、多太等面向对象的技术
4.采用拼接动态SQL语句构建条件组合查询语句。</div>2019-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg" width="30px"><span>Hwan</span> 👍（4） 💬（2）<div>前几个月设计和开发一个审核的系统，通过将职责划分清楚之后，再使用微服务将各个模块划分出来，审核的算法和调用第三方的这些和主系统分开，现在不管怎么加其他第三方的审核服务都没事，还是很开心的</div>2019-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6b/72/30c631fe.jpg" width="30px"><span>I</span> 👍（4） 💬（1）<div>代码中实现的扩展，只采用过插件模式。但插件模式似乎应对场景比较单一，大神可以谈谈代码中的其他实现方式吗？</div>2018-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/14/a6/d00153f1.jpg" width="30px"><span>不再犹豫</span> 👍（4） 💬（1）<div>代码层面来说我觉得是快速实现，持续重构。建立在对业务充分理解的基础上，按照依赖抽象的原则，提取出因业务变化而导致代码逻辑变化部分。</div>2018-05-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg" width="30px"><span>ZHANGPING</span> 👍（3） 💬（1）<div>个人对可扩展的理解：因为业务需求的变更（新增或修改），使得系统需要支持新的功能。其本质是业务驱动，所以作为开发者在设计之初就需要对行业有深刻的认知，知道行业演进规则，熟悉业务层的玩法，套路，和自己当前公司的定位。然后再从技术层面考虑怎样去尽可能的提供灵活的解决方案。
当然如果作为行业的领导者，可能没有参照物，这个时候也可以通过和产品的探索+论证，预测出可能的改动点，当然可能不对。 </div>2021-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg" width="30px"><span>Xiao</span> 👍（3） 💬（1）<div>在实际编码阶段，会采用相应设计模式来coding，比如策略、工厂、代理模式、模版方法模式等等，也会将DDD的思想运用到coding中来，尽量做到高内聚。项目架构设计上，也会运用DDD的六边形架构设计。个人觉得DDD的思想在复杂的业务背景下，能够带来意想不到的效果。
还有，个人觉得架构师首先应该也是行业业务专家，在做架构设计的时候，能够对未来业务发展有一定的把控力。</div>2020-09-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/58/d4/c1e67d7a.jpg" width="30px"><span>GEEKBANG_4123791</span> 👍（3） 💬（1）<div>设计模式要好好看看了</div>2020-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/04/78/37b46ba6.jpg" width="30px"><span>鲁米</span> 👍（2） 💬（1）<div>1 写 2 抄 3 重构原则。等待到 3 代码都 “shi山了”。</div>2023-08-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/ab/79/e293456e.jpg" width="30px"><span>RMB</span> 👍（2） 💬（1）<div>业务的复杂度决定架构设计的复杂度，有时把业务想的太复杂，反而让架构设计更臃肿，所以，其他暂且不说，对复杂业务的拆分能力以及把控业务的拆分粒度，非常重要！</div>2021-01-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/28/aa/06c12256.jpg" width="30px"><span>两只狮子</span> 👍（2） 💬（1）<div>【从0开始学架构】学习本节课程有共鸣。可扩展性总会提到，但是可扩展性应该怎么做，做到什么程度，有没有跑偏，在工作中往往就不是那么有明显的界限。按照老师的思路将可扩展性提炼为文中提到的预测变化和应对变化，我的感觉无比到位。文中提到的现象我在工作中总会遇到，也会想到很多办法去解决实际的问题，但是并没有真正的将这个经历理论化，我想着也许就是普通人跟大神的区别。今天学习后的收获，1、利用老师的理论指导工作；2、往后的工作中要多思考多提炼。</div>2020-02-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b0/82/013f0f1e.jpg" width="30px"><span>艳姐</span> 👍（2） 💬（1）<div>设计模式是代码级别的，跟架构层面的不同。架构层面的扩展性例子只谈了数据库的扩展，能否再举个复杂点的例子便于理解。</div>2018-07-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/18/59/daeb0b6c.jpg" width="30px"><span>日光倾城</span> 👍（2） 💬（1）<div>前面讲高性能和高可用还觉得很贴近，这个可拓展性就觉得很不好把握了，可能我平常接触的需求比较简单，就只考虑怎么实现，没有考虑扩展性，有时候觉得需求太个性化没啥拓展可言，或者说抽不出来变化与不变，所以这方面的经验很欠缺。后面工作中还是要加强这方面的意识</div>2018-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/9c/6e/01b4d5d2.jpg" width="30px"><span>liupan</span> 👍（1） 💬（1）<div>策略模式、代理模式、模板模式与装饰者模式的差异在哪？目前设计感觉这几种都沾边了，比如一个任务进来，先执行1，再执行2最后执行3;不同的场景1-2-3的实现可能相同可能不同，那么用多态来封装这些差异，相同的应用通用点，不同的个性化就增加类来实现，业务场景进来会进不同的策略，来区分是否执行下一步，都会先执行到代理类，再转到真正的实现类，所以感觉用了多个设计模式</div>2020-05-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg" width="30px"><span>考休</span> 👍（1） 💬（1）<div>学习了老师的文章，又看了大家的评论，从技术上讲的都很多了，工作中我还发现一个可扩展性的难题，就是需求的沟通上，有的时候因为沟通导致的过度设计也很频繁，很多时候产品总是讲什么都想要，可是也不见得这些都需要做可扩展性的设计，也要对产品人员晓以利害，因此预估扩展性导致的开发复杂度也很重要了。</div>2019-07-11</li><br/><li><img src="" width="30px"><span>whhbbq</span> 👍（1） 💬（1）<div>【不能每个设计点都考虑可扩展性】
关于这点，有点感触。一开始搭建系统的时候，使用的是mysql数据库，leader审核代码时，因为在代码中使用了一些mysql特有的语法而被要求修改（比如自增主键）。原因是系统后续可能会使用oracle来存储。当时就感觉这种可能性太小了。囧。。

实践证明，这只是在给自己找麻烦。要是早看到华仔的文章就好了哈哈</div>2019-05-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/74/68/3725546b.jpg" width="30px"><span>Carlos</span> 👍（1） 💬（1）<div>李老师专栏真是干货满满呀。我一般是上下班路上听，每篇文章听的不止一两遍。就可扩展性这片，结合老师讲解，我说说自己想法。我认为可扩展性架构里的变化应该分为两种，一种是新增，一种是优化。第一种是架构设计需要考虑的问题，比如系统增加新接入方式，不用改现有代码，只要新增一种实现就能满足，这是好的架构。不好的架构是无法通过新增新实现来完成，而是要修改现有代码逻辑，这样会带来两个问题，一是可能会破坏原有的功能，二是增加原有方式的代码复杂度，为维护增加难度。第二种优化可能主要是功能设计时需要考虑的，现实情况是，产品本身的某个使用习惯，在对客户进行演示交流时，不满足客户要求，他们更习惯另外一种方式，这种情况先是进行引导，引导不成，就要结合客户意愿，进行优化了，这种优化通常是基于原有逻辑的修改。新增实现就没有意义了。</div>2018-06-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/2b/1b/e88e33ba.jpg" width="30px"><span>Chang</span> 👍（1） 💬（1）<div>设计不同算法，没办法做到极致！其实设计项目多了发现都是trade off</div>2018-06-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/65/d5/88beb15a.jpg" width="30px"><span>李志博</span> 👍（1） 💬（1）<div>正打算规则引擎剥离变化的部分</div>2018-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d9/da/23a4a0c4.jpg" width="30px"><span>aiwen</span> 👍（1） 💬（1）<div>讨论问题比较多，解决问题的方案却没提，后续会有相关的问题成熟的常用的解决方案么</div>2018-05-10</li><br/>
</ul>