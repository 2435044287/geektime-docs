你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。

在上一篇文章中，我们一起学习了两层调度。在两层调度架构中，第二层调度只知道集群中的部分资源，无法进行全局最优调度。那么，是否有办法解决全局最优调度的问题呢？

答案是肯定的，解决办法就是我今天要带你打卡的共享状态调度。

接下来，我们就一起看看共享状态调度到底是什么，以及它的架构和工作原理吧。

## 什么是共享状态调度？

通过我们前两篇文章的讲述，不难发现，集群中需要管理的对象主要包括两种：

- 一是，资源的分配和使用状态；
- 二是，任务的调度和执行状态；

在单体调度中，这两种对象都是由单体调度器管理的，因此可以比较容易地保证全局状态的一致性，但问题是可扩展性较差（支持业务类型受限），且存在单点瓶颈问题。

而在两层调度中，这两种对象分别由第一层中央调度器和第二层Framework调度器管理，由于Framwork调度器只能看到部分资源，因此不能保证全局状态的一致性，也不容易实现全局最优的调度。

为了解决这些问题，一种新的调度器架构被设计了出来。这种架构基本上沿袭了单体调度器的模式，通过将单体调度器分解为多个调度器，每个调度器都有全局的资源状态信息，从而实现最优的任务调度，提供了更好的可扩展性。
<div><strong>精选留言（16）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg" width="30px"><span>亢（知行合一的路上）</span> 👍（25） 💬（1）<div>单体调度：一个部门经理（调度）给所有下属安排工作；
双层调度：多个项目经理（二层调度）向部门经理（一层调度）申请人力资源；
共享状态：两位部门经理同时给下属安排工作，根据任务优先级解决冲突。</div>2020-03-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/51/ec/3d51d5e6.jpg" width="30px"><span>上校</span> 👍（5） 💬（2）<div>老师说到omega的缺点，感觉可以用多个Borg管理多个集群，然后不同Borg负责不同的任务类型的执行来解决omega的缺点</div>2020-05-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f2/66/b16f9ca9.jpg" width="30px"><span>南国</span> 👍（1） 💬（1）<div>关于多节点之间的并发冲突问题应该有以下解决方案:
1.应用层做一些调整,使得在每个调度器上的数据申请不同的资源,避免并发问题的最好方法就是不出现并发.
2.乐观的解决方案,多节点一起提交,在资源管理器上收敛于一致状态.
3.分布式锁,这个感觉效率不高,因为每次得到锁得到资源以后还需要一个全局的共识.</div>2020-04-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/a0/0f/110d92e4.jpg" width="30px"><span>风华笔墨</span> 👍（0） 💬（1）<div>我觉得解决并发冲突，在本地调度计算出资源分配的过程中，找出资源的最大值和最小值作为一个区间划分。同时还需要各个cell state每隔一定时间进行广播比对，使没有交叉的区间先执行。</div>2020-05-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg" width="30px"><span>Eternal</span> 👍（10） 💬（1）<div>感觉这一节超级棒，老师通过事务的例子来解释共享状态的调度很深刻。
我对老师的问题关于共享状态调度的核心解决并发冲突的思考：
一个job由多个task组成，一个job要么全都执行，要么全都不执行，就像老师说的理解成一个事务；
1.job执行执行的时候如果阻塞等待资源，我们可以将阻塞加上超时时间，超时后还不能获取到资源，当前job主动释放自己已经占有的资源，这可以叫做等待超时时间；
2.如果一个job占有了一些资源，正在执行，我们可以给当前job设置一个超时时间，如果job在超时时间内还没把资源执行完，自己主动释放占有的资源，回滚job的所有task，这可以理解成作业超时时间
3.多个job的多个task在抢资源的时候，我们可以设计一个公平和非公平的抢占队列
4.共享状态下的调度有一个特点是每个调度器都有全局的资源，这个可以这样改进一下：每个调度器的资源分为两部分组成，一部分独占，一部分由共享抢占获取，这样减少并发的程度；这让我想到了操作系统的内存模型，一个核心占用一部分固定内存，然后其它的内存是共享的，也就是可以抢占的

</div>2019-10-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg" width="30px"><span>leslie</span> 👍（2） 💬（0）<div>    关于并发其实数据系统中一直很早就在处理这种问题：从早期单机RMDB-&gt;读写分离-&gt;一主多从-&gt;内存库【虽然市面上各种分类众多，可是个人还是偏向这种说法，各种关系太复杂了】。
    谈不上什么特别好的解决方案：就谈谈老师课程中提到的Google对此的做法吧MVCC，其实这确实是一条解决的方式和思路，就像内存库就无法做到ACID特性，只能牺牲部分。目前主流其实就是老师文中所说的先锁或者后验证。
    前段时间和本地的同行交流发现其实随着现在系统的越来越复杂：操作系统都开始特性化的时代确实感觉定制化的东西已经越来越多的出现在计算机的各个方面，如何从中获得一个相对中立的方案才是关键吧。</div>2019-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg" width="30px"><span>波波安</span> 👍（1） 💬（1）<div>解决并发冲突的方法就是加锁，在分布式架构中可以采用分布式锁，具体有前面讲到的三种，基于数据库的，基于redis的，基于zookeeper的分布式锁。</div>2019-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg" width="30px"><span>第一装甲集群司令克莱斯特</span> 👍（0） 💬（0）<div>老师这课后总结，真是一流的。</div>2021-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg" width="30px"><span>西门吹牛</span> 👍（0） 💬（0）<div>俩种调度方式，就和单机下通过悲观锁和乐观锁访问共享资源一样，这种思想到处可见，要学习思想才能自己设计。
共享的调度，同样的思想，在计算几上也有类似，比如cpu执行指令，会采用分支预测的方式来尽可能提升cpu的利用率，预测对了，那么就节省了cpu等待条件判断的返回的时间，如果条件判断结果出来，发现错了，那就重来，要知道，cpu是很快的，在大的循环里面，只会在最后一次会预测错误，总的来说利大于弊。</div>2020-08-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg" width="30px"><span>亢（知行合一的路上）</span> 👍（0） 💬（0）<div>今天又看了一遍，之前都没理解啊😓 看了之后，还得实践，才能加深理解。
现在还不知道调度器的 Cell State 和 State Storage 中的 Cell State 是怎么保持一致的？
新来的 job，调度器根据本地 State 副本进行 task 和资源的映射，完成后，将结果提交到中心？如果无冲突，则将变更同步到本地；如果冲突，也更新，过会再试。
待继续学习……</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（0） 💬（0）<div>并发冲突的解决思路？
1：并行串行化，锁＋阻塞队列
2：类似CAS，不断尝试
那种方式比较好，需要看场景，竞争大的加锁控制会好一些，竞争小的使用CAS应该可以😄</div>2020-02-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg" width="30px"><span>米 虫</span> 👍（0） 💬（0）<div>看了这篇文章，感觉只要有了类似redis和锁后，这个世界已经不存在单点问题了。</div>2019-12-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg" width="30px"><span>阿卡牛</span> 👍（0） 💬（0）<div>不同的体系结构是否对选择不同的调试结构有影响？</div>2019-10-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e9/1a/6ba207a3.jpg" width="30px"><span>天天向善</span> 👍（0） 💬（0）<div>很抽像，能不能描述一下调度器做了哪些事情，任务举几个例子，共享状态调度的资源状态和任务状态有哪些</div>2019-10-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg" width="30px"><span>Jackey</span> 👍（0） 💬（0）<div>能想到的解决冲突的方法就是加锁了，乐观锁或是悲观锁，本质上都是让并行变串行。当然也有一些可以优化的点，比如读读并行。</div>2019-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（0） 💬（0）<div>1.同步
给资源编号，按照一定的顺序加锁，释放锁，以免出现死锁
2.CAS compare and swap
可能还有其他方式，可以参考维基百科的Synchronization条目</div>2019-10-21</li><br/>
</ul>