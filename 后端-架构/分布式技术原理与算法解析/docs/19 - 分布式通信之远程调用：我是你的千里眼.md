你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。

在前面三个模块中，我带你学习了分布式领域中的分布式协调与同步、分布式资源管理与负载调度，以及分布式计算技术，相信你对分布式技术已经有了一定的了解。

通过前面的学习，不知道你有没有发现分布式的本质就是多进程协作，共同完成任务。要协作，自然免不了通信。那么，多个进程之间是如何通信的呢？这也就是在“第四站：分布式通信技术”模块中，我将要为你讲解的问题。

话不多说，接下来我们就一起进入分布式通信的世界吧。今天，我首先带你打卡的是，分布式通信中的远程调用。

## 什么是远程调用？

首先，我通过一个例子，来让你对远程调用和本地调用有一个直观了解。

以电商购物平台为例，每一笔交易都涉及订单系统、支付系统和库存系统，假设三个系统分别部署在三台机器A、B、C中独立运行，订单交易流程如下所示：

1. 用户下单时，调用本地（机器A）的订单系统进行下单；
2. 下单完成后，会远程调用机器B上的支付系统进行支付，待支付完成后返回结果，之后在本地更新订单状态；
3. 在本地远程调用机器C上的仓库系统出货，出货完成后返回出货结果。

在整个过程中，“下单”和“订单状态更新”两个操作属于本地调用，而“支付”和“出货”这两个操作是通过本地的订单系统调用其他两个机器上的函数（方法）实现的，属于远程调用。
<div><strong>精选留言（29）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/77/2a/4f72941e.jpg" width="30px"><span>cpzhao</span> 👍（8） 💬（1）<div>参考zookeeper作为注册中心时的实现。消费方缓存服务方的信息，然后向注册中心订阅服务者的信息，如果服务方有上下线可以及时通知到。并且再加一个定时刷新的兜底集中。
高可用会依赖注册中心，所以一般注册中心也不是单机运行的，一般可以用集群主备或者多主（参考集群架构那块）的方式来搞。</div>2020-02-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg" width="30px"><span>lobby</span> 👍（0） 💬（1）<div>想到的就是本地缓存，然后监听变化。看见有同学说定时刷新兜底，感觉更稳妥</div>2020-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4f/f9/1f0a9665.jpg" width="30px"><span>任大鹏</span> 👍（10） 💬（1）<div>服务消费方本地缓存一份地址列表</div>2019-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（8） 💬（3）<div>文中从n*m的通信量直接引入了服务注册中心，感觉有点牵强，是因为通信量大才引入的注册中心吗？引入之后通信量就不大了？那最大不还是有n*m个调用关系吗？文中引入的注册中心只是为了查询服务提供方地址吧？</div>2019-12-18</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132" width="30px"><span>鱼向北游</span> 👍（2） 💬（0）<div>回问题 可以用缓存 但要解决缓存失效问题</div>2019-12-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg" width="30px"><span>kylexy_0817</span> 👍（2） 💬（0）<div>终于打卡都这章，满满的干货，谢谢老师！</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/67/7e/bf563d29.jpg" width="30px"><span>蛙</span> 👍（2） 💬（1）<div>老师，请问思维导图使用什么软件画的？</div>2019-11-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg" width="30px"><span>Jackey</span> 👍（2） 💬（1）<div>1.抱歉想先纠个错：RPC调用过程第6步Pay写成了Par
2.思考题：没有了解过dubbo，工作中用的是Spring cloud，注册中心eureka。这里每个服务都会在本地缓存一份注册表，然后定时刷新，这样服务调用时只需要读本地缓存即可。但也引入了一些新的问题，比如缓存时间设置多久合适？太长导致更新不及时，太短则会耗费过多资源。这里是不是可以考虑注册中心“通知”各个客户端，例如引入mq，获取pub&#47;sub。但这样会增加系统复杂度，还是要结合实际情况考虑。
3.想补充一点点rpc调用的细节，内核中会有消息缓冲区，发送消息时会把消息写到buffer中，然后发给本地网卡，读消息时也一样，需要从内核的read buffer中读。如果发送消息很大，就会有多次网络通信。</div>2019-11-04</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJt38jZaMKP6tnUSrUlqRqYuVEB1TNZW67xNzQGx8Yt4rfFSdAXB3taQWz8xGCgN0G9oYKfyfM0VA/132" width="30px"><span>Geek_3046bc</span> 👍（1） 💬（0）<div>回复问题：可以使用zookeeper，etcd等组件来解决注册中心的实现，同时对于dubbo的设计也有一个疑问，注册中心为什么不直接转发到对应的服务节点，这样对于调用方无需理解服务列表。而且zookeeper的监听者全部收缩到注册中心上了，避免了zookeeper的性能问题。可以用多实例的方式来解决注册中心的单点的问题。</div>2021-07-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg" width="30px"><span>leslie</span> 👍（1） 💬（0）<div>       老师的这张图表分享的非常好：用句通俗的话语“没有对比就没有伤害&quot;，各种知识的优劣直接用图表展现就非常直观的体现了-方便记忆；毕竟学习中有些知识还是要记忆的。
       记住关键的知识，然后对课程的知识勤加思考和练习；自然就掌握了。</div>2019-11-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（1） 💬（0）<div>感觉缓存这个方法用的好多，我觉得本质上就是将数据放到离数据使用者更近的地方。比如磁盘、内存，高速缓存，寄存器，离CPU越来越近，访问速度越来越快，但造价也越来越贵。</div>2019-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/8c/f9/7f61c49c.jpg" width="30px"><span>扭转乾坤</span> 👍（0） 💬（0）<div>想起了之前的微服务技术,微服务技术(springcloud) 和 大数据技术(hadoop  spark  flink  hbase等)的区别 我的理解是 前者是任务分离 解决的问题比如是 高并发 后者是 数据分裂  解决的问题有 数据量大</div>2023-07-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/6c/3b/703d19dd.jpg" width="30px"><span>张立奎</span> 👍（0） 💬（0）<div>老师好，文章里看到有http协议慢，不适合远程调用。spring cloud默认http协议，这块老师怎么看，有点懵</div>2022-07-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/f1/39/b0960780.jpg" width="30px"><span>恶魔果实</span> 👍（0） 💬（0）<div>Go RPC可以利用HTTP和TCP来传递数据，请问老师这里如何理解？HTTP不是应用层协议吗？为什么可以和传输层的TCP放在一起理解。</div>2021-07-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg" width="30px"><span>mickey</span> 👍（0） 💬（0）<div>缓存一份，设置过期时间，推拉更新、定时更新。</div>2021-04-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f2/66/b16f9ca9.jpg" width="30px"><span>南国</span> 👍（0） 💬（0）<div>服务调用方设置缓存，当有服务提供方失效的时候可以参考chubby的对缓存失效的处理方法，即服务调用方向注册了失效提供方节点的服务调用方发送一个失效通知，此时不更新缓存，等到第一次调用的时候在重置缓存，把一个集中的修改平均下来</div>2020-07-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/a0/0f/110d92e4.jpg" width="30px"><span>风华笔墨</span> 👍（0） 💬（0）<div>消费方本地缓存列表，以及注册Watch，当注册中心发生变动时，就会通知并更新本地缓存。</div>2020-05-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg" width="30px"><span>88591</span> 👍（0） 💬（0）<div>缓存服务列表，1、可以减少查询次数，2、当注册中心不可用时，rpc 还能进行</div>2020-04-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg" width="30px"><span>极客雷</span> 👍（0） 💬（0）<div>RPC</div>2020-03-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg" width="30px"><span>亢（知行合一的路上）</span> 👍（0） 💬（0）<div>老师说 HTTP 协议既繁琐又浪费时间，不适用于有低延时要求的大规模分布式系统，如果对时延有一定的容忍度，二者皆可选吧？我觉得把远程过程调用当成本地函数调用，这种写法比较舒服吧？如果用 HTTP 协议，还得封装成函数，确实繁琐。</div>2020-03-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（0） 💬（0）<div>阅过留痕
还好吧！
RPC微服务的基础，之前研究过，读起来丝毫不费劲，大概原理就是这样了啦！每个大厂也都有自己的框架，细节上稍微不同，底座还是网络通信，其他的封装都是为了使网络通信的过程简单化，易于业务研发使用，提升开发效率。</div>2020-02-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg" width="30px"><span>💢 星星💢</span> 👍（0） 💬（0）<div>这个应该需要加个缓存层，如果注册中心服务改变，需要通知调用方更新缓存。。</div>2019-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg" width="30px"><span>拒绝</span> 👍（0） 💬（0）<div>当一台机器 A 上运行的进程 P 需要远程调用时，它就先查一下机器 A 维护的映射表，找出对应的调用 ID，然后把它传到另一台机器 B 上，机器 B 通过查看它维护的映射表，从而确定进程 P 需要调用的函数，然后执行对应的代码，最后将执行结果返回到进程 P。
请问老师这个映射表是服务提供方注册到注册中心，然后由注册中心下发给调用方的吗？</div>2019-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/4a/d5f5a260.jpg" width="30px"><span>一毛钱</span> 👍（0） 💬（0）<div>在各个进程本地做一个缓存，第一可以不用每次都查注册中心，第二可以用来预防注册中心挂掉而引起的服务不可用</div>2019-11-17</li><br/><li><img src="" width="30px"><span>Geek_f6f02b</span> 👍（0） 💬（0）<div>同步就是代码会按照所写代码逻辑顺序执行

异步在正常情况下也是按照所写代码逻辑顺序执行，但是一些特殊的地方不会等待代码执行完成就执行下面代码，例如：异步 ajax 请求，如果你将异步请求来的结果赋值给一个未定义的变量，在下面代码直接alert 这个变量是那么 js 会报错未定义。因为异步执行的代码，还未等 ajax 请求结束就直接执行了下面的代码。


阻塞，当处理的任务不满足（比如一些公用资源锁了）那么就会切换成其它进程处理（可能其它进程再次不满足执行状态再次切换），等其它进程任务处理完成再切换回来，依赖系统内核调度做进程切换

非阻塞，进程有一个任务队列，所有请求都先到队列，进程获取队列中任务执行，当处理满足处理状态立即处理，当不满足处理状态，该进程会将当前处理状态存入内存然后注册一个触发事件，等满足该事件可以继续处理的时候会触发通知进程继续处理该任务，而获取通知前该进程可以直接处理下一个任务无需等待，也不依赖系统的进程切换，所以没有进程切换的损耗效率更高

特点：同步编程的代码更易书写也便于理解排错，非阻塞效率比阻塞效率更高
不知道这样理解对不对？</div>2019-11-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg" width="30px"><span>Eternal</span> 👍（0） 💬（0）<div>引入了注册中心后，服务的高可用被转嫁到了注册中心，如果注册中心挂了，所有调用都不通；如果一个服务离开或者加入注册中心，这个时候服务注册中心的服务列表是实时更新还是由一定延迟，这也影响可用性</div>2019-11-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg" width="30px"><span>1024</span> 👍（0） 💬（0）<div>同步异步的例子举的挺好。
思考题：服务调用方应该有个预加载和缓存机制来减少调用注册中心的次数</div>2019-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（0） 💬（0）<div>服务调用端加个本地缓存，但要注意缓存失效的问题，比如注册中心发现注册的服务有变更（可能是新服务来了，也可能是老服务有个实力挂掉等），要通知服务调用端更新本地缓存。</div>2019-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg" width="30px"><span>啦啦啦</span> 👍（0） 💬（0）<div>不错不错，让我真正理解了rpc</div>2019-11-04</li><br/>
</ul>