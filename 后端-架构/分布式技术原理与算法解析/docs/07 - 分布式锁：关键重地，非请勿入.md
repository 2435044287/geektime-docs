你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。

我在[第3篇文章](https://time.geekbang.org/column/article/141772)中，与你一起学习了分布式互斥，领悟了其“有你没我，有我没你”的精髓，为你解释了同一临界资源同一时刻只能被一个程序访问的问题，并介绍了解决分布式互斥的算法。

不知道你有没有发现一个细节，在之前介绍的算法中，我主要讲了如何协调多个进程获取权限和根据权限有序访问共享资源，“获得访问权限的进程可以访问共享资源，其他进程必须等待拥有该权限的进程释放权限”。但是，我并没有介绍在访问共享资源时，这个权限是如何设置或产生的，以及设置或产生这个权限的工作原理是什么。

那么，在本讲，我就将带你一起打卡分布式锁，去学习分布式锁是如何解决这个问题的。

## 为什么要使用分布锁？

首先，我先带你认识一下什么是锁。

在单机系统中，经常会有多个线程访问同一种资源的情况，我们把这样的资源叫做共享资源，或者叫做临界资源。为了维护线程操作的有效性和正确性，我们需要某种机制来减少低效率的操作，避免同时对相同数据进行不一样的操作，维护数据的一致性，防止数据丢失。也就是说，我们需要一种互斥机制，按照某种规则对多个线程进行排队，依次、互不干扰地访问共享资源。

这个机制指的是，为了实现分布式互斥，在某个地方做个**标记**，这个标记每个线程都能看到，到标记不存在时可以设置该标记，当标记被设置后，其他线程只能等待拥有该标记的线程执行完成，并释放该标记后，才能去设置该标记和访问共享资源。这里的标记，就是我们常说的**锁**。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg" width="30px"><span>Eternal</span> 👍（29） 💬（3）<div>学完3-7节我自己总结了一下个人的理解：
分布式协调与同步的场景中需要解决一些通用问题
1.分布式系统中，多个节点都需要访问一个临界资源，但是同一时刻只能有一个节点可以访问，为了解决这个问题就是要通过分布式互斥来实现，老师说的有你没我，有我没你；分布式锁就是实现分布式互斥的一种实现方式
2.分布式系统中，多个节点需要同时写一份相同的数据，怎么保证数据写的是一致的呢？需要一个节点来协调，这个协调节点叫做leader，它是怎么产生的呢？是通过选举产生的，这就是分布式选举；
3.分布式系统中，多个节点达成某一项共识可以通过选举（投票）的方式实现，选举不简单是少数服从多数，还有一些拓展：投票的时候考虑优先级，考虑权重，考虑代理等
4.分布式系统中除了互斥，达成共识还有协同作战：分布式事务，多个节点同时做一件事，要么全成功，要么全失败；本来单机事务是通过数据库（Mysql）的多版本MVCC实现的，现在在分布式环境中，每个节点都有数据库，不能实现分布式事务了，现在需要通过程序来模拟实现单机事务的特性ACID。考虑实际情况，XA协议下的2阶段和3阶段提交都不能很好的满足需求，衍生出了新的理论(BASE)来实现


</div>2019-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/69/88/528442b0.jpg" width="30px"><span>Dale</span> 👍（13） 💬（1）<div>分布式互斥是在分布式系统中存在多个节点共享某个资源或临界区，任何时刻只允许一个进程访问资源或执行临界区，而分布式锁正好是解决分布式互斥的一种方法。</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg" width="30px"><span>冬风向左吹</span> 👍（11） 💬（1）<div>1、分布式互斥：在一个分布式系统中，控制集群中的节点互斥的访问共享资源，算法有：集中式算法、民主协商算法（分布式算法）、民主协商算法

2、分布式锁：实现分布式互斥需要用到分布式锁。
      基于数据库的分布式锁；
      基于缓存的分布式锁；
      基于zookeeper的分布式锁

3、分布式选举：对于一个分布式集群来说，需要对集群节点进程调度、管理，需要通过分布式选举选出leader节点。选举算法有：
     长者为大：bully算法
     民主投票：Raft算法
     具有优先级的民主投票：ZAB算法

4、分布式共识：分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。常用的算法有： 
      PoW（工作量证明：比特币）
      PoS（权益证明：以太坊）
      DPos（委托权益证明：比特股）

5、分布式事务：XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。事务管理器即类似于使用集中式算法对资源进行协调
      二阶段提交方法（2PC）：强一致性
      三阶段提交方法（3PC）：强一致性
      基于分布式消息的最终一致性方案</div>2020-04-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" width="30px"><span>xfan</span> 👍（6） 💬（1）<div>最后一段有些问题 应改为若本进程为写请求，则向比自己序号小的最后一个请求节点注册监听事件，因为写和写之间也是互斥的。</div>2019-10-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg" width="30px"><span>piboye</span> 👍（1） 💬（4）<div>如果客户端和zk的链接突然断开，但业务又在调用api的等待中，这个时候很难说锁避免了临界资源被并发访问吧</div>2020-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg" width="30px"><span>Jackey</span> 👍（1） 💬（2）<div>读请求watch比它小的写请求，写请求是不是应该watch比它小的请求（无论读写）？不然会有冲突的吧？不知道理解对不对</div>2019-10-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/50/1c/26dc1927.jpg" width="30px"><span>次郎</span> 👍（0） 💬（1）<div>老师，我有个问题，分布式锁，比如a拿到了锁执行时间超过了超时时间，那么b就可以拿到锁了，这个时候a提交数据，不就造成锁失效的问题了么？</div>2020-06-09</li><br/><li><img src="" width="30px"><span>开心小毛</span> 👍（0） 💬（1）<div>若其他进程已对临界资源进行写入，则当前进程则无论读写都必须阻塞。不知老师是否同意。</div>2019-10-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg" width="30px"><span>miracle</span> 👍（49） 💬（8）<div>1 .redis 不用通过超时来释放锁，DEL操作可以直接释放不用等到超时
2. redis 官方已经明确说明不推荐 setnx 来实现分布式锁了(https:&#47;&#47;redis.io&#47;commands&#47;setnx) 官方给出了 the Redlock algorithm 各语言的实现版本是来实现分布式锁的机制，比如JAVA的实现版本(https:&#47;&#47;github.com&#47;redisson&#47;redisson) 所以从可靠性来讲并不比zk的方案差</div>2019-10-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg" width="30px"><span>忆水寒</span> 👍（14） 💬（1）<div>分布式锁是实现互斥的一种手段。</div>2019-10-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（12） 💬（1）<div>给库存数加锁这个例子写的不好。文中说到，
        我们能想到的最简单方案就是，给吹风机的库存数加一个锁。当有一个用户提交订单后，后台服务器给库存数加一个锁，根据该用户的订单修改库存。而其他用户必须等到锁释放以后，才能重新获取库存数，继续购买。

      既然说了其他用户必须等到锁释放后才能重新获取库存，那为什么后面又说A和B同时获得库存数呢？这不矛盾了吗？还有这个库存数是存在哪里的？如果存在公共服务器上，类似于redis那个例子，那多个用户抢同一把锁也没问题啊，反正只有一个能抢到，等一个用户释放锁，下一个用户再获得锁。</div>2019-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（6） 💬（0）<div>阅过留痕
1：锁的本质就是一个标记，通俗点就是一个变量
2：单机锁是多个线程共享的某个变量，操作共享资源前，需要先看这个变量是否为某个值，表示加锁或解锁啦
3：分布式锁是多个进程共享的某个变量，其他的和单机锁类似，当然，操作系统如果挂了，单机也就完全不可用了，如果操作系统没挂，多线程共享某个变量的控制通常是非常健壮的，分布式系统的特点是不会整个集群不可用，不过某台机器不可用的概率非常大，同时网络通信也是不可靠的，所以，分布式锁的可靠性就不好保证了，为了保证他的可靠性就需要引入集群，这样复杂性又会增多了
4：分布式锁很明显是分布式互斥的一种实现方式
5：从面试的角度来讲老师讲解的还不够全面，redis分布式锁的三连击都顶不住，不够细致和全面。</div>2020-02-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/3b/5c/f77a77ef.jpg" width="30px"><span>小咖</span> 👍（6） 💬（0）<div>这课程买的太赚了
</div>2019-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg" width="30px"><span>卫江</span> 👍（5） 💬（4）<div>老师，想问一个问题，通过zoomkeeper来实现分布式锁，等发生网络中断的对应的临时节点会消失来实现分布式锁的异常情况，我们知道进程挂掉会触发相应的文件引用计数减一，一般情况下会把连接关闭，但是如果是正常的网络中断引起的临时节点消失，从而其他进程获取锁，但是可能发生网络中断的进程业务并没有处理完成，这个该怎么办？</div>2019-10-07</li><br/><li><img src="" width="30px"><span>Geek_f6f02b</span> 👍（4） 💬（0）<div>分布式锁与分布式互斥的关系是什么呢？
我觉得分布式互斥是前提条件或者说实现目的，而分布式锁是手段或者说是实现方法。
还有文章中有2个地方不理解。一个是那个zookeeper实现分布式锁的，写请求为什么说是要等待比自己小的读请求结束，如果是比自己小的写请求就不用等待了吗？我理解是，自己为读请求就等待比自己小的写请求结束，写请求就等待所有比自己小的所有请求结束。另一个不理解也是类似问题，就是下面那个写watch应该是等等比自己小的那个事件就结束添加watch事件吧？</div>2019-10-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg" width="30px"><span>流云</span> 👍（3） 💬（0）<div>分布式锁是分布式互斥的一种实现，更确切的说是一种集中式分布式互斥算法，由第三方（DB，cache，zk）来充当协调者。</div>2020-03-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" width="30px"><span>任鹏斌</span> 👍（3） 💬（0）<div>老师关于redis的分布式锁还有几个问题
1、setnx加过期时间的原子性问题（目前应该已经解决）
2、锁的续期问题
3、如果redis集群或者主从模式下只写入一个节点时挂掉导致锁失效

期望老师答疑时详细说一下</div>2019-10-18</li><br/><li><img src="" width="30px"><span>开心小毛</span> 👍（3） 💬（4）<div>请老师确认一下redis是否会为一个KEY建立等待队列。我以为，Redis的分布式锁根本没有队列，收到setnx返回为0的进程会不断的重试，直到某一次的重试成为DEL命令后第一个到达的setnx从而获得锁，至于此进程在等待获得锁的众多进程中是不是第一个发出setnx的，redis并不关心。</div>2019-10-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/ce/b9/ec9de161.jpg" width="30px"><span>厨子</span> 👍（1） 💬（0）<div>作者其实可以再多写点，说明redis和zk的节点超时的一些原因以及zk的锁为什么要找节点最小的那个节点</div>2020-09-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ea/e7/9ce305ec.jpg" width="30px"><span>Sancho</span> 👍（1） 💬（0）<div>老师您好，在读你这篇专栏时，对基于Zookeeper实现的分布式锁有几个疑问？
1.从应用程序角度，对Zookeeper的请求应该只有一个，获取分布式锁请求。这个请求到达Zookeeper后如何被拆分成“读请求”和“写请求”的？
2.文中“Zookeeper实现分布式锁”的第4个步骤，和“解决羊群效应”的第3个步骤中，提到的“节点编号”和“序号”是同一个含义吗？
3.“解决羊群效应”的第3个步骤，没太想明白，可能是存在第1个问题的困扰导致的。能否请老师补充一张时序图。
谢谢。</div>2020-02-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a9/84/c87b51ce.jpg" width="30px"><span>xiaobang</span> 👍（1） 💬（0）<div>分布式锁实现了分布式互斥的集中式算法？</div>2019-11-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a8/e2/f8e51df2.jpg" width="30px"><span>Li Shunduo</span> 👍（1） 💬（2）<div>redis的分布式锁如何实现排队？</div>2019-10-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg" width="30px"><span>Allan</span> 👍（0） 💬（0）<div>1、分布式锁与分布式互斥的关系是什么呢？
分布式互斥的时候我们讲到了三种解决互斥的方法，霸道总裁：集中式方法，民主协商：分布式方法，轮值CEO：令牌环方法。都是为了获得允许，然后才能发送消息调用。而分布式锁通过数据库，redis缓存，zookeeper临时文件这三种方式用来告诉具体怎么做。所以这么看来，分布式锁是分布式互斥的具体解决方案。</div>2024-08-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/70/9e/9337ca8e.jpg" width="30px"><span>jaryoung</span> 👍（0） 💬（0）<div>zk的方案，有比较尴尬的问题。如果zk，为了分布式锁引入zk，感觉有点过了。🤣</div>2024-01-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ba/e4/6df89add.jpg" width="30px"><span>芋头</span> 👍（0） 💬（0）<div>个人标记：数据库容易理解、redis方案没有涉及redLock、zookeeper需要深入一下</div>2023-03-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cc/58/c593587c.jpg" width="30px"><span>ahnselina</span> 👍（0） 💬（0）<div>想象一下，用户 A 想买 1 个吹风机，用户 B 想买 2 个吹风机。在理想状态下，用户 A 网速好先买走了 1 个，库存还剩下 1 个，此时应该提示用户 B 库存不足，用户 B 购买失败。但实际情况是，用户 A 和用户 B 同时获取到商品库存还剩 2 个，用户 A 买走 1 个，在用户 A 更新库存之前，用户 B 又买走了 2 个，此时用户 B 更新库存，商品还剩 0 个。这时，电商就头大了，总共 2 个吹风机，却卖出去了 3 个。
===============================
没看懂这，在有锁的情况下，用户A和用户B怎么会同时获取到库存呢，不应该是只有一个获取到库存吗</div>2020-12-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/90/db/02aa2247.jpg" width="30px"><span>林通</span> 👍（0） 💬（0）<div>本进程为写请求，如果比自己序号小的节点中有读请求，则等待。
如果比自己序号小的节点有写请求，就不用等待了吗？ </div>2020-11-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg" width="30px"><span>业余爱好者</span> 👍（0） 💬（0）<div>分布式锁和之前的分布式互斥不是一回事吗?</div>2020-09-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/c2/6b/149d9ab1.jpg" width="30px"><span>李树增</span> 👍（0） 💬（0）<div>分布式锁？
	在分布式环境中，多个系统想访问同一共享资源时，实现多进程分布式互斥的一种锁
分布式锁的三种实现
	基于数据库（关系型）实现分布式锁
		核心思想：在数据库中创建一张锁表，当我们要锁住某个资源时，就在表中增加一条数据，释放锁则删除该条记录。利用数据库实现分布式锁。
		不足
			数据库需要落到硬盘上，频繁的读取数据库会导致IO开销大。
			并发量低
			性能低
			单点故障。数据库不可用，整个系统都会崩溃
			死锁。由于数据库锁没有失效时间，若某个进程没有正确的释放锁（删除表记录），会导致锁记录一直存在数据库中，其他进程会一直拿不到锁
		应用场景
			适用于并发量低、性能要求低的场景
	基于缓存实现分布式锁
		核心思想：将相关数据放在内存中，减少磁盘IO开销，提升效率，同时可设置锁超时时间，避免死锁问题出现。可以使用Redis的setnx（key，value）函数实现分布式锁。其中key表示锁id，value==currentTime + timeOut，该函数返回1则表示正确获取锁，返回0表示获取锁失败。
		优势
			性能更好。数据存放在内存中，而不是磁盘，避免了频繁的磁盘IO操作
			很多缓存可以跨集群部署，避免了单点故障的问题
			很多缓存服务都提供了可以用来实现分布式锁的方法。eg：Redis的setnx函数
			可以设置锁超时时间，得益于这些缓存服务支持自动删除过期数据
		不足
			锁失效时间的控制不稳定（可能因为网络波动等因素导致不正确的锁超时，这时的失效会导致数据不一致）
			可靠性不如ZooKeeper
			不易理解
		应用场景
			适用于高并发、对性能要求高的场景
	基于ZooKeeper实现分布式锁
		ZooKeeper的树形数据存储结构主要由4种节点构成
			持久节点。这是默认的节点类型，一直存在于ZooKeeper中
			持久顺序节点。也就是说，在创建节点时，ZooKeeper根据节点创建的时间顺序对节点进行编号
			临时节点。与持久节点不同，当客户端与ZooKeeper断开后，该进程创建的临时节点就会被删除
			临时顺序节点，就是按时间顺序编号的临时节点
		核心思想：在对应的持久节点shared_lock的目录下为每个进程创建一个临时顺序节点，每个节点确定编号是否最小，若最小，则获得锁；否则等待更小编号节点释放锁
		优势
			无单点故障、不可重入（ZooKeeper的机制决定，若当前节点为读请求，并且比自己小的节点中没有写请求的话，可以直接访问资源）、死锁问题
			几乎解决了数据库锁和缓存式锁的不足
			可靠性高
			易于实现
		不足
			性能没有缓存式分布式锁好
			难以理解
		应用场景
			ZooKeeper适用于大部分分布式场景，但是不适用于对性能要求极高的场景

分布式锁关键点
	互斥性，即在分布式系统环境下，分布式锁应该能保证一个资源或一个方法在同一时间只能被一个机器的一个线程或进程操作
	具备锁失效机制，防止死锁。即使有一个进程在持有锁的期间因为崩溃而没有主动解锁，也能保证后续其他进程可以获得锁
	可重入性，即进程未释放锁时，可以多次访问临时资源
	有高可用的获取锁和释放锁的功能，且性能要好

如何解决分布式锁的羊群效应问题
	什么是羊群效应？
		所谓羊群效应，就是在整个分布式锁的竞争过程中，大量的“Watcher 通知”和“子节点列表的获取”操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑。
	解决方法
		在与该方法对应的持久节点的目录下，为每个进程创建一个临时顺序节点。
		每个进程获取所有临时节点列表，对比自己的编号是否最小，若最小，则获得锁。
		若本进程对应的临时节点编号不是最小的，则继续判断：
			若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当监听到该节点释放锁后，则获取锁；
			若本进程为写请求，则向比自己序号小的最后一个请求节点注册 watch 监听，当监听到该节点释放锁后，获取锁。
</div>2020-09-02</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132" width="30px"><span>Geek_c22199</span> 👍（0） 💬（1）<div>没懂，读读可以，写写也可以？

a.  本进程为读请求，如果比自己序号小的节点中有写请求，则等待；
b.  本进程为写请求，如果比自己序号小的节点中有读请求，则等待。</div>2020-04-17</li><br/>
</ul>