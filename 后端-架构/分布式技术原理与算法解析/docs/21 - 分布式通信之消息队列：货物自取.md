你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。

在上一篇文章，我带你学习了分布式通信技术中的发布订阅。总结来说，发布订阅就是发布者产生数据到消息中心，订阅者订阅自己感兴趣的消息，消息中心根据订阅者的订阅情况，将相关消息或数据发送给对应的订阅者。所以，我将其思想，概括为“送货上门”。

在实际使用场景中，还有一种常用的通信方式，就是将消息或数据放到一个队列里，谁需要谁就去队列里面取。在分布式领域中，这种模式叫“消息队列”。与发布订阅相比，消息队列技术的核心思想可以概括为“货物自取”。

接下来，我们就一起打卡分布式通信技术中的消息队列吧。

## 什么是消息队列？

回想一下，在上一篇学术电子论文订阅的例子中，出版社或会议方将论文发布到论文网站（或平台）上，然后论文网站再将论文推送给订阅相关论文的老师或学生。这里的论文网站就是消息中心，负责根据订阅信息将论文送货上门，角色非常关键。

但其实，除了将论文送货上门外，我们还能想到另外一种模式，也就是出版社或会议方将论文发布到论文网站进行存储，老师或学生根据需要到论文网站按需购买文章。

这种思想，在分布式通信领域中称为消息队列模式，论文网站充当的就是消息队列的角色，也非常关键。接下来，**我再通过一个具体的应用案例来帮助你更加深入地理解什么是消息队列吧**。
<div><strong>精选留言（22）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg" width="30px"><span>piboye</span> 👍（3） 💬（2）<div>订阅模式的核心是一个消息可以被多个人消费，消息队列是一个消息一个人消费。</div>2020-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg" width="30px"><span>88591</span> 👍（1） 💬（1）<div>记录消费消息的对应关系。可以在客户端记录，也可以在服务端记录。，服务端记录更可靠，但是通信成本高。增加了服务器的开销。客户端记录简单，但是容易丢失。</div>2020-04-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg" width="30px"><span>忆水寒</span> 👍（34） 💬（3）<div>这个问题其实问的是幂等性问题，在目前流行的几种MQ中都可能存在。比如Kafka，在kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费吧。但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，有时候直接kill进程再重启。这会导致consumer有些消息处理了，但是没来得及提交offset，尴尬了。重启之后，少数消息会再次消费一次。其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/6b/6a/798232a8.jpg" width="30px"><span>信xin_n</span> 👍（13） 💬（2）<div>好像有点明白了，发布订阅模式是 push 模式，消息队列是 pull 模式。</div>2019-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg" width="30px"><span>随心而至</span> 👍（8） 💬（0）<div>分布式数据存储，好像都是利用某种hash算法将数据存在不同的机器上。Kafka： hash（消息的键）来确定分区；Redis：hash（key）来确定slot；ES：hash（docId）来确定shard。</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg" width="30px"><span>观弈道人</span> 👍（6） 💬（0）<div>感觉这个有点问题吧，不管是订阅还是队列模式，都是broker“送货上门”给消费端的，希望聂老师能再解释下，谢谢！</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg" width="30px"><span>阿卡牛</span> 👍（3） 💬（2）<div>我理解的消息队列模型，同一份消息只能被消费一次吧？</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/fb/63/1f05c62e.jpg" width="30px"><span>小李飞菜刀</span> 👍（2） 💬（0）<div>感觉上一课的发布订阅模式,举了Kafka的例子不好，因为Kafka是拉的模式，是消费者主动消费数据，不是被推送过来的。
kafka的生产者只负责生产数据，不管有没有消费者；
kafka的消费者可以从头、上次消费点、最新的方式消费数据；</div>2020-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/08/5b/2a342424.jpg" width="30px"><span>青莲</span> 👍（2） 💬（0）<div>每个消费者都有维护一个自己消费消息的偏移量，可以存储在本地，或类似zookeepr的协同服务上，每次重启都去协同服务上拉取上一次消费的偏移量，从上一次记录开始消息；当然这种情况，由于各种异常原因还是有可能消息至少被消费一次，如常见的消息重放等，所以需要在业务方消费时进行业务上的幂等处理</div>2019-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg" width="30px"><span>Allan</span> 👍（0） 💬（0）<div>1、消息队列模型中，消费者是主动去消息队列获取消息的，而消息队列需要保证多个消费者可以获取到消息，也就是说一个消费者获取消息后并不会删除该消息，那么如何保证同一个消息不被同一个消费者重复消费呢？
我知道的是kafka是通过offset，也就是位移来解决的消费进度。同样的消息队列模式我觉得也是可以通过消费位移来解决消费的进度，保证消费过的数据就不会重复消息</div>2024-08-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/bf/22/26530e66.jpg" width="30px"><span>趁早</span> 👍（0） 💬（0）<div>规定一个queue or patition 在同一个消费组只能有一个消费者去消费</div>2021-09-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg" width="30px"><span>GaGi</span> 👍（0） 💬（0）<div>RocketMQ虽然是消息队列的中间件，但是其还是使用发布订阅模式实现，相对应的存储使用了队列。</div>2021-04-12</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfk5OeeGFBKX6ehZTAfwicDHa6Yy9WEn1zIq1iaDYN261N3w5C6fPkLex3L65tqU4q2HeTt05v8LKw/132" width="30px"><span>penny19</span> 👍（0） 💬（0）<div>可不可以理解为，发布订阅的时延比队列模式低？因为队列一般去轮训，效率不如发布订阅的主动推过来</div>2021-03-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（0） 💬（0）<div>如何保证同一个消息不被同一个消费者重复消费呢？
有个小游戏，通过一个小窗口可以看到里面的动画内容，看的人需要买票，一张票只能看一次，看过之后票就作废了，如果有N个窗口，一张票可以从头看到尾，怎么保证每个窗口只看一次呢？那就需要记住持票人看到那个位置的窗口了，我觉得MQ的解决思路是一样的，总之需要记录下每个消费者消费了什么消息，把每个消费者消费的消息都记录下来数据量太大了，由于是队列可以利用他的方向性，记录消费消息的位置，这样也能间接知道对应的消费者消费了那些消息。</div>2020-02-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg" width="30px"><span>小孩</span> 👍（0） 💬（1）<div>听下来感觉一个是push一个是pull，可是我用消息队列也是push啊，学完有点晕了</div>2019-12-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/4a/d5f5a260.jpg" width="30px"><span>一毛钱</span> 👍（0） 💬（0）<div>kafka的offset就是解决多消费者的问题的</div>2019-11-30</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132" width="30px"><span>易儿易</span> 👍（0） 💬（0）<div>思考题:不是可以使用线程安全的队列吗？数据结构里是支持的，产品型的消息队列中间件不支持吗？</div>2019-11-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg" width="30px"><span>kylexy_0817</span> 👍（0） 💬（0）<div>在消费端作幂等处理，如在缓存上记录消息是否有被消费过，或在数据库的层面加上唯一索引约束数据只能被插入一次</div>2019-11-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg" width="30px"><span>梅子黄时雨</span> 👍（0） 💬（0）<div>可以在也许层面做防止重复消费的逻辑</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/fe/39/6203b3f2.jpg" width="30px"><span>tracy</span> 👍（0） 💬（0）<div>1.消息端实现幂等性，比如支付消息，以订单号为唯一标识，消息时候可以根据状态判断是否处理过，数据库加上唯一索引
2.消费时候可以再内存中加set去重
3.应该需要根据不同的业务分析处理</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg" width="30px"><span>Jackey</span> 👍（0） 💬（1）<div>这里想到可以考虑从consumer端控制，consumer消费消息时，broker可以返回一个偏移量，由consumer记录这个偏移量。下次消费时直接从偏移位置处开始消费。
或者由broker来记录消费者和对应偏移量，消费者要重复消费时直接不返回数据。但broker之间的数据同步应该会使系统更加复杂</div>2019-11-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg" width="30px"><span>啦啦啦</span> 👍（0） 💬（0）<div>打卡</div>2019-11-11</li><br/>
</ul>