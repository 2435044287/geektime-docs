你好，我是丁威。

从这节课开始，我们就要进行基础篇的学习了。想要熟练使用中间件解决各种各样的问题，首先需要掌握中间件的基础知识。

我认为，中间件主要包括如下三方面的基础：数据结构、JUC和Netty，接下来的两节课，我们先讲数据结构。

数据结构主要解决的是数据的存储方式问题，是程序设计的基座。

按照重要性和复杂程度，我选取了数组和链表、键值对(HashMap)、红黑树、LinkedHashMap和PriorityQueue几种数据结构重点解析。其中，数组与链表是最底层的两种结构，是后续所有数据结构的基础。

我会带你分析每种结构的存储结构、新增元素和搜索元素的方式、扩容机制等，让你迅速抓住数据结构底层的特性。当然，我还会结合一些工业级实践，带你深入理解这些容器背后蕴含的设计理念。

说明一下，数据结构其实并不区分语言，但为了方便阐述，这节课我主要基于Java语言进行讲解。

## 数组

我们先来看下数组。

数组是用于储存多个相同类型数据的集合，它具有顺序性，并且也要求内存空间必须连续。高级编程语言基本都会提供数组的实现。

为了更直观地了解数组的内存布局，我们假设从操作系统申请了128字节的内存空间，它的数据结构可以参考下面这张图：
<div><strong>精选留言（8）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/29/97/23/9c9bd0d4.jpg" width="30px"><span>苜蓿°</span> 👍（14） 💬（1）<div>问题1
	网上找寻资料学习了一下:
		(1) 开放定址法
			①线性探测法
			实现过程：当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值，取模是为了保证找到的位置在0~m-1的有效空间之中。
			公式：h(x)=(Hash(x)+i)mod (Hashtable.length);（i会逐渐递增加1）
			存在问题：出现非同义词冲突（两个不相同的哈希值，抢占同一个后续的哈希地址）被称为堆积（聚集）现象
			②平方探测法（二次探测）
			实现过程： 当我们的所需要存放值的位置被占了，会前后寻找而不是单独方向的寻找
			公式：h(x)=(Hash(x) +i)mod (Hashtable.length);（i依次为+(i^2)和-(i^2)）
			存在问题：相比线性探测减少找寻时间，但不会减少堆积（聚集）现象
		（2）再哈希法
			实现过程：同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止
			存在问题：不易发生聚集，但是增加了计算时间
		（3）建立公共溢出区
			实现过程：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中
			存在问题：需要实时动态维护两张哈希表</div>2022-06-29</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132" width="30px"><span>末日，成欢</span> 👍（10） 💬（1）<div>HashMap 中哈希槽的容量为什么必须为 2 的倍数？

当我们计算key的索引下标时， 通过会对key的哈希码对数组取模运算来计算出下标值。

而JAVA中的大神对取模运算又进行了一次优化。 将取模运算优化为与运算。

为什么能被优化为与运算呢？

举个简单的例子： hashcode为11,数组容量为4。 我们知道对于2的n次方一定能整除2的n-1次方。

11对8取模，获取它的余数,也就是它的下标值。 

转化为二进制1011 % 0100, 也就是1011&#47;0100, 因为2的n次方一定能整除2的n-1次方的缘故，高位直接舍弃。 

其余的无法被整数的也就是它的余数，它的低位就是它的余数， 获取它的低位就可以通过x011&amp;(0100-1)=&gt;也就是hash &amp; (n-1),能推导出这个公式是建立在数组的容量是2的倍数的前提上。

为什么要优化为与运算呢？

我的猜想，计算机对于与运算的指令比取模运算的指令要少的多， 故与运算要高效的多。

最后，我还想再说一个key获取哈希值的优化。

我们知道，生成哈希值的原则就是要尽量让所有的元素都参与到计算。

key获取哈希值， 并不是简单的直接获取哈希码， 而是该key的哈希值高低16位再一次又进行了异或运算，这样就可以让哈希值再次变化。

其实也可以不变化的，但是对于起始容量比较小，大量的元素如果低位都相同，就可能会造成大量的哈希冲突。 

而再一次进行异或运算， 即使相同的低位也可以再次变化， 减小hash冲突。
</div>2022-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg" width="30px"><span>蔫巴的小白菜</span> 👍（4） 💬（2）<div>hashmap，容量设计成2的整数幂，我理解有两点：
1.就是设计成2整数幂可以利用位运算的高效，快速找到下标。
2.为了扩容搬运元素方便，小于之前size的元素，可以直接搬运到新size的原始位置，而超过原始size的元素，只需要下标加上原始size即可，实战了高效的扩容元素迁移。</div>2022-07-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/8d/55/1345dff3.jpg" width="30px"><span>独自等待</span> 👍（0） 💬（3）<div>RocketMQ这块的分析还可以</div>2022-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/de/e0/64e555ae.jpg" width="30px"><span>Zero</span> 👍（0） 💬（0）<div>ArrayList与LinkedList的对比图中，ArrayList中的数组是以1.5倍进行扩容的吧，图中标错了</div>2024-11-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg" width="30px"><span>夜空中最亮的星</span> 👍（0） 💬（0）<div>分析到位 图标很棒</div>2022-07-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg" width="30px"><span>William Ning</span> 👍（0） 💬（0）<div>https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;64586
数据结构与算法之美

对照着学习～～</div>2022-07-06</li><br/><li><img src="" width="30px"><span>Geek_xbye50</span> 👍（0） 💬（3）<div>hashmap1.8之前采用头插法的解释很牵强啊！通过复杂度比较的话头尾不都是O(1)</div>2022-06-26</li><br/>
</ul>