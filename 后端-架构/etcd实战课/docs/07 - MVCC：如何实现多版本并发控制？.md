你好，我是唐聪。

在[01](https://time.geekbang.org/column/article/335204)课里，我和你介绍etcd v2时，提到过它存在的若干局限，如仅保留最新版本key-value数据、丢弃历史版本。而etcd核心特性watch又依赖历史版本，因此etcd v2为了缓解这个问题，会在内存中维护一个较短的全局事件滑动窗口，保留最近的1000条变更事件。但是在集群写请求较多等场景下，它依然无法提供可靠的Watch机制。

那么不可靠的etcd v2事件机制，在etcd v3中是如何解决的呢？

我今天要和你分享的MVCC（Multiversion concurrency control）机制，正是为解决这个问题而诞生的。

MVCC机制的核心思想是保存一个key-value数据的多个历史版本，etcd基于它不仅实现了可靠的Watch机制，避免了client频繁发起List Pod等expensive request操作，保障etcd集群稳定性。而且MVCC还能以较低的并发控制开销，实现各类隔离级别的事务，保障事务的安全性，是事务特性的基础。

希望通过本节课，帮助你搞懂MVCC含义和MVCC机制下key-value数据的更新、查询、删除原理，了解treeIndex索引模块、boltdb模块是如何相互协作，实现保存一个key-value数据多个历史版本。
<div><strong>精选留言（29）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/51/1d/50085e60.jpg" width="30px"><span>五味子</span> 👍（32） 💬（1）<div>我理解etcd采用延迟删除，1是为了保证key对应的watcher能够获取到key的所有状态信息，留给watcher时间做相应的处理。2是实时从boltdb删除key，会可能触发树的不平衡，影响其他读写请求的性能。</div>2021-02-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/aa/9a/92d2df36.jpg" width="30px"><span>tianfeiyu</span> 👍（15） 💬（4）<div>一般情况下（默认堆积的写事务数大于 1 万才在写事务结束时同步持久化），数据持久化由 Backend 的异步 goroutine 完成，它通过事务批量提交，定时将 boltdb 页缓存中的脏数据提交到持久化存储磁盘中
---
如果etcd集群突然挂了，如何保证这部分未持久化的数据不会丢呢？</div>2021-02-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg" width="30px"><span>花晨少年</span> 👍（4） 💬（4）<div>并发读特性的核心原理是创建读事务对象时，它会全量拷贝当前写事务未提交的 buffer 数据，并发的读写事务不再阻塞在一个 buffer 资源锁上，实现了全并发读。
---------------
写事务未提交，为什么读事务要去读这个脏数据呢？另外写事务的写buffer是这个事务所有操作一起写bufeer吗，我们保证原子的写呢，在不锁的情况下？
我理解是如果对读事务来看，想让写事务具有原子性，应该必须得加锁吧。</div>2021-04-18</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep075ibtmxMf3eOYlBJ96CE9TEelLUwePaLqp8M75gWHEcM3za0voylA0oe9y3NiaboPB891rypRt7w/132" width="30px"><span>shuff1e</span> 👍（4） 💬（1）<div>当你再次查询 hello 的时候，treeIndex 模块根据 key hello 查找到 keyindex 对象后，若发现其存在空的 generation 对象，并且查询的版本号大于被删除时的版本号，则会返回空。
---
如果删除了之后，又重新写入了。
查询的最新的版本号，还是会返回最新的数据的吧。</div>2021-02-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b9/bb/71c0f013.jpg" width="30px"><span>Ching</span> 👍（0） 💬（3）<div>“全局版本号随读写事务自增，因此是 main 为 2，sub 随事务内的 put&#47;delete 操作递增，因此 key hello 的 revison 为{2,0}，key world 的 revision 为{2,1}。” 老师请问一下，读事物也会递增全局版本号吗？然后这个子版本号，在这个例子里有两个put，为什么不是递增2呢？是一个事物内的全部写操作只看作1次子版本递增吗</div>2021-08-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d0/b4/a6c27fd0.jpg" width="30px"><span>John</span> 👍（0） 💬（1）<div>如果一个key 删除了，并且compactor也已经真正删除了该key,那查询历史某个版本会报错？</div>2021-07-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg" width="30px"><span>石小</span> 👍（0） 💬（3）<div>backend 的异步 goroutine 完成，它通过事务批量提交，定时将 boltdb 页缓存中的脏数据提交到持久化存储磁盘中。
有配置能控制提交条目和刷新频率吗？</div>2021-03-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/68/83/ecd4e4d6.jpg" width="30px"><span>WGJ</span> 👍（0） 💬（1）<div>在删除原理中：
当你再次查询 hello 的时候,....，若发现其存在空的 generation 对象，并且查询的版本号大于被删除时的版本号，则会返回空。  中的查询的版本号，中的查询版本号如果没有指定，默认是最新的话，我理解的应该是和删除的版本号相等吧？</div>2021-02-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（0） 💬（1）<div>为什么 etcd v2 版本基于内存的 Watch 机制会不可靠呢？ 存在历史版本不就可以比较key 的 value 是否有变化的？</div>2021-02-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/46/0f/f6cfc659.jpg" width="30px"><span>mckee</span> 👍（6） 💬（0）<div>思考题：
etcd 为什么删除使用 lazy delete 方式呢？相比同步 delete, 各有什么优缺点？
etcd要保存key的历史版本，直接删除就不能支持revision查询了；
lazy方式性能更高，空闲空间可以再利用；

当你突然删除大量 key 后，db 大小是立刻增加还是减少呢？
应该会增大，etcd不会立即把空间返回系统而是维护起来后续使用，维护空闲页面应该需要一些内存；</div>2021-02-05</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDUJyeq54fiaXAgF62tNeocO3lHsKT4mygEcNoZLnibg6ONKicMgCgUHSfgW8hrMUXlwpNSzR8MHZwg/132" width="30px"><span>types</span> 👍（5） 💬（1）<div>并发读特性的核心原理是创建读事务对象时，它会全量拷贝当前写事务未提交的 buffer 数据，并发的读写事务不再阻塞在一个 buffer 资源锁上，实现了全并发读。

是否可以具体讲讲全量拷贝如何实现全并发读？</div>2021-03-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/3a/de/e5c30589.jpg" width="30px"><span>云原生工程师</span> 👍（3） 💬（0）<div> 老师每讲内容太丰富了</div>2021-02-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/db/50/c2d07bb1.jpg" width="30px"><span>L。</span> 👍（1） 💬（2）<div>老师，请教个问题，treeindex是采用btree来实现的索引，那么请问一下， 这个索引是在内存中，还是会落盘</div>2022-05-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg" width="30px"><span>神毓逍遥</span> 👍（1） 💬（0）<div>结合MySQL的MVCC一起看</div>2021-08-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/aa/9a/92d2df36.jpg" width="30px"><span>tianfeiyu</span> 👍（1） 💬（1）<div>一般情况下（默认堆积的写事务数大于 1 万才在写事务结束时同步持久化），数据持久化由 Backend 的异步 goroutine 完成，它通过事务批量提交，定时将 boltdb 页缓存中的脏数据提交到持久化存储磁盘中
---
如果 etcd 集群突然挂了，如何保证未持久化的这部分数据不会丢？</div>2021-02-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/61/e6/fedd20dc.jpg" width="30px"><span>mmm</span> 👍（1） 💬（0）<div>“基于 Backend&#47;boltdb 提供的 MVCC 机制，etcd 可实现读写不冲突。”
老师buffer由于全拷贝实现了并发读，那treeindex和boltdb读写如何做到不冲突呢？</div>2021-02-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/2e/c5/231114ed.jpg" width="30px"><span>Hadesu</span> 👍（0） 💬（0）<div>mvcc可以存储一个数据的多个版本，可以在事务提交时做版本冲突检测。即使用mvcc，并发读写treeindex和boltdb应该都是避免不了加锁操作的。mvcc比悲观锁的性能好是不是这样的？mvcc开始事务时，读操作前加锁，读完解锁，写操作前加锁，写完解锁，读写之间的操作不加锁。悲观锁开始事务到结束事务都持有锁。mvcc持有锁的时间比悲观锁少了读写之间的操作的时间？</div>2024-08-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/1f/ab/42fc8571.jpg" width="30px"><span>Little Bird</span> 👍（0） 💬（0）<div>treeIndex 为什么不使用 B+ 呢？</div>2024-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/e4/04/18933a58.jpg" width="30px"><span>心如水滴</span> 👍（0） 💬（0）<div>思考题
1. lazy delete避免批量的删除操作对存储引擎造成很大的压力
2. 优点：删除操作效率高，无需长时间等待。
    缺点：删除后会有一段时间占用存储空间，会造成一定的资源浪费
3. db大小会立刻增加。因为etcd会追加空的generation到keyIndex，并在boltdb添加对版本号的删除标识</div>2023-12-28</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZMrPJicXYt6R327pBUxSR1TkMCZNo2072tAdKxuE0qzJ8GlLI4ldaZEibL8xgvE5k6t3O9ibRmgbjw/132" width="30px"><span>dasonzheng</span> 👍（0） 💬（0）<div>版本号（revision）并不是一个简单的整数，是 {main, sub}这样一个组合的struct，比如{2,0}，但get查询时返回的create_revision&#47;mod_revision都是一个整数。create_revision&#47;mod_revisio实际返回的是main的值么，比如{2,0}里的2</div>2023-07-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/c3/34/58426785.jpg" width="30px"><span>预见</span> 👍（0） 💬（0）<div>这跟mysql的很多实现都好像啊</div>2023-03-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg" width="30px"><span>JianXu</span> 👍（0） 💬（0）<div>“当你再次发起一个 put hello 为 world2 修改操作时，key hello 对应的 keyIndex 的结果如下面所示，keyIndex.modified 字段更新为 &lt;3,0&gt;，generation 的 revision 数组追加最新的版本号 &lt;3,0&gt;，ver 修改为 2。”

老师，hello world 和 hello world2 属于同一个transaction 吗？如果属于，那是不是revision 数组最新版本是&lt;3,1&gt; 呢？只有在不属于一个Tx 的时候才是 &lt;3,0&gt; </div>2023-01-27</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/uQoCBsia00Dr1g05SCZ69esjDwJWP4QGbckxNZAO44xg4Hu2YjDROoITtvcLr23ae9SrE5tVR95U8ricVMicdnUIw/132" width="30px"><span>Geek_439a6d</span> 👍（0） 💬（0）<div>在 MVCC put  key 的过程中，要是 treeIndex 和 boltdb 的修改成功了（从上面看起来，应该是可以向用户返回 put 成功），持久化失败了，这时候会不会导致丢数据？是因为，多个 etcd 节点之间进行了数据同步，单个节点死掉以后，其他节点还是会持久化，所以保证了不会丢数据吗？</div>2022-09-14</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/uQoCBsia00Dr1g05SCZ69esjDwJWP4QGbckxNZAO44xg4Hu2YjDROoITtvcLr23ae9SrE5tVR95U8ricVMicdnUIw/132" width="30px"><span>Geek_439a6d</span> 👍（0） 💬（0）<div>revision 中main 是个全局递增的int64 整数，随着用户不断对etcd 中的数据进行操作，main 不会溢出吗？</div>2022-09-14</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDRPejHodutia9Ud8UZLY8g5lTkKXgf3J104c0jM9aFfAGNoUdxkRLnnWRc5Kd3jIeN3EqXxKFT0g/132" width="30px"><span>蓝莓侠</span> 👍（0） 💬（0）<div>boltdb 使用的 唯一key，怎么产生的？用的什么算法？是整个etcd集群从有第一个写请求后，从1开始自增得到的？</div>2022-02-11</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W15zhRusOohD37CFCxSOnZfeOppkicDpOLVVmQYlbpw6rGib2Ib8smSFHZiaXXa7OJhHTQ/132" width="30px"><span>scott</span> 👍（0） 💬（1）<div>感谢分享，我有两个疑问：
1. ConcurrentReadTx会全量拷贝buffer，这样就不会阻塞写事务，但是这个buffer不会是stale吗？因为写事务会writeback buffer，但是好像没有看到更新ConcurrentReadTx拷贝的buffer。
2. `server&#47;etcdserver&#47;apply.go`文件中的`applierV3backend.Txn`方法，在执行pb.TxnRequest事务时，先去执行compareToPath方法，判断是走Then还是Else分支中的`[]*RequestOp`，这个过程是启动一个readTx，然后关闭此readTx，接着开启一个writeTX执行applyTxn，但是有没有可能前面判断的compareToPath已经被更改了，导致执行的分支不准确？
谢谢！</div>2021-11-18</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDUJyeq54fiaXAgF62tNeocO3lHsKT4mygEcNoZLnibg6ONKicMgCgUHSfgW8hrMUXlwpNSzR8MHZwg/132" width="30px"><span>types</span> 👍（0） 💬（1）<div>数据持久化由 Backend 的异步 goroutine 完成，它通过事务批量提交，定时将 boltdb 页缓存中的脏数据提交到持久化存储磁盘中
请问下，此时的异步批量提交是一次性将所有的脏数据都持久化的存储磁盘还是每次持久化部分脏数据？
个人理解是全部刷入,因为部分刷入无法准备记录consistent index，请作者解答下，谢谢</div>2021-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/70/13/accdc2df.jpg" width="30px"><span>M⃰I⃰ ⃰m⃰a⃰n⃰c⃰h⃰i⃰</span> 👍（0） 💬（0）<div>在一个度为 d 的 B-tree 中，节点保存的最大 key 数为 2d - 1
--这里最大key数不应该是d-1么？</div>2021-08-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（0） 💬（1）<div>在进行  boltdb 存储的时候 key 和 value 都被编码了，这个编码的规则是什么的？</div>2021-02-04</li><br/>
</ul>