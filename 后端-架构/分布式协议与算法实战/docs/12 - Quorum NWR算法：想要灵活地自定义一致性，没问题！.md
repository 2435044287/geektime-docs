你好，我是韩健。

不知道你在工作中有没有遇到这样的事儿：你开发实现了一套AP型的分布式系统（我在[04讲](https://time.geekbang.org/column/article/200717)提到了AP型系统的特点，你可以回顾一下），实现了最终一致性。业务也接入了，运行正常，一起看起来都那么美好。

可是，突然有同事说，我们要拉这几个业务的数据做实时分析，希望数据写入成功后，就能立即读取到新数据，也就是要实现强一致性（[Werner Vogels提出的客户端侧一致性模型](https://www.allthingsdistributed.com/2008/12/eventually_consistent.html)，不是指线性一致性），数据更改后，要保证用户能立即查询到。这时你该怎么办呢？首先你要明确最终一致性和强一致性有什么区别。

- 强一致性能保证写操作完成后，任何后续访问都能读到更新后的值；
- 最终一致性只能保证如果对某个对象没有新的写操作了，最终所有后续访问都能读到相同的最近更新的值。也就是说，写操作完成后，后续访问可能会读到旧数据。

其实，在我看来，为了一个临时的需求，我们重新开发一套系统，或者迁移数据到新系统，肯定是不合适的。因为工作量比较大，而且耗时也长，而我建议你通过Quorum NWR解决这个问题。

也就是说，在原有系统上开发实现一个新功能，就可以满足业务同学的需求了。因为通过Quorum NWR，你可以自定义一致性级别，通过临时调整写入或者查询的方式，当W + R &gt; N时，就可以实现强一致性了。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/89/e5/a346ba59.jpg" width="30px"><span>沈伟敏</span> 👍（22） 💬（7）<div>AP系统之上通过Quorum NWR实现了强一致性，这个是不是违背了“CAP不可能三角”。这个要怎么理解呢？</div>2020-04-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg" width="30px"><span>姜川</span> 👍（16） 💬（2）<div>如果我们用raft协议的最终一致性来做整个系统的核心协议，这时出现了要强一致的需求，我们就可以不改变raft协议的前提下，引入NWR，raft协议已经保证了W是超过半数以上的，那我们就让R也超过半数以上，就能保证基于raft协议还能做出强一致性的需求了，或者改动raft协议，让其可以拥有配置写ALL的能力也可以</div>2020-03-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/83/39/f9623363.jpg" width="30px"><span>竹马彦四郎的好朋友影法師</span> 👍（11） 💬（1）<div>&quot;当 W + R &gt; N 的时候，对于客户端来讲，整个系统能保证强一致性，一定能返回更新后的那份数据。&quot;
顿时明白了韩老师在本文开头说的 &quot;Werner Vogels 提出的客户端侧一致性模型，不是指线性一致性&quot;
确实，图1中的AP系统其实并没有实现线性一致性，但是该AP系统实现了客户端侧一致性模型。</div>2020-05-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/c3/5d/ced9b5c2.jpg" width="30px"><span>Michael Tesla</span> 👍（8） 💬（3）<div>老师，写入 W 个节点失败，有可能有脏数据残留，是不是需要使用分布式事务呢？</div>2020-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg" width="30px"><span>kylexy_0817</span> 👍（8） 💬（1）<div>联想起另一门视频课程，MongoDB，好像也是采取Quorum NWR算法实现数据强一致性^_^</div>2020-04-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg" width="30px"><span>右耳听海</span> 👍（8） 💬（5）<div>老师能讲下为什么w+r&gt;n时是强一致性的吗</div>2020-03-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" width="30px"><span>每天晒白牙</span> 👍（6） 💬（1）<div>关于思考题，老师在文中提到的资料有一些参考点：
在需要提供高性能和高可用性的分布式存储系统中，副本的数量即 n 通常超过 2 个。
只关注容错的系统通常使用 n=3 （W=2和R=2配置）。
需要提供非常高读取负载的系统通常会复制超出容错要求的数据</div>2020-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/bc/d7/938c83b8.jpg" width="30px"><span>fy</span> 👍（4） 💬（3）<div>问个问题，假设322配置，第一次写入只成功了一个节点，返回客户端错误，这时候有个读取操作，刚好获取到了上一次写入成功的那一个副本，然后返回了这份数据，那不是和之前的操作结果矛盾了么</div>2020-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg" width="30px"><span>小晏子</span> 👍（4） 💬（1）<div>我理解课后思考的问题是”为什么只需要备份数据到部分节点，不需要备份到所有节点“，因为是AP系统，所以为了提升效率，备份数据到N个副本就可以认为是数据写入成功了，整个系统因为是最终一致性，系统内部会异步同步节点之间的数据，所以最终所有节点上的数据肯定会一致的，另外工程实践里N&gt;=3, 是因为冗余数据是保证可靠性的手段，如果N=2，那么损失一个节点就退化为单节点了。</div>2020-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg" width="30px"><span>Geek_zbvt62</span> 👍（4） 💬（1）<div>每次写入数据都要产生对应版本号是吧</div>2020-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/1c/e1/c99d1473.jpg" width="30px"><span>longyi</span> 👍（3） 💬（4）<div>老师,你在文中提到”读取指定数据时，要读 R 副本，然后返回 R 个副本中最新的那份数据”
，问题是我们怎么去判断那个副本是最新的呢？</div>2020-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg" width="30px"><span>侧耳倾听</span> 👍（2） 💬（1）<div>明白老师的意思了，系统已经在运行，副本数和写入数都是已定的，理论上不能动态调整的，所以我们只能调整R来实现强一致性，实时读取最新数据，所以我们只需要在新的功能里计算好R的数目，然后接入存储系统读取数据，然后在本地通过版本号或者日期取最新数据即可。</div>2020-04-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/8d/3b/42d9c669.jpg" width="30px"><span>艾瑞克小霸王</span> 👍（2） 💬（1）<div>这里的一个节点的意思是不是一个raft集群? 采用多个raft集群做数据分片和多副本?</div>2020-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/e3/8b/27f875ba.jpg" width="30px"><span>Bryant.C</span> 👍（1） 💬（2）<div>我理解Kafka是不是也不支持读一致性级别，通过ack为-1设置强一致</div>2020-09-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg" width="30px"><span>月迷津渡</span> 👍（1） 💬（3）<div>这篇核心写的很清晰，我有个小问题，关于W和R的平衡当中提到要写优化就要R=N，W=1 这样就满足W+R&gt;N，对于这个W=1是会变吗就是不同数据可以写到不同节点 但是还是满足W=1，因为我在考虑当这个持有数据的唯一节点挂了，那节点所持有数据就不可修复了吧。所以后面提到读大多数和写大多数节点是一种满足容错的配置。
另外我想到如果集群中某个节点挂了的话N会动态变化吗？因为节点挂了就意味着数据不可用在机器网络或硬件坏掉的情况下数据也无法恢复到其他新启动节点？我记得mongo里就是配置readConcern和WriteConcern就是用的majortiy 这种感觉就是应对节点变化的一种策略(动态大多数而并非指定指定一个固定的值)吧。</div>2020-03-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg" width="30px"><span>吴小智</span> 👍（1） 💬（1）<div>按需求配置，再好不过了</div>2020-03-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/2a/b8/edbafb82.jpg" width="30px"><span>彦</span> 👍（1） 💬（3）<div>进行R操作时，R&gt;2，读出的数据怎么知道哪个数据是最新的呢？时序数据库里面本来带了时间戳，可以靠这个判断，但还是需要保障整个系统时序一致，其他非时序系统怎么办？</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（1） 💬（1）<div>influxdb 不是国产的开源时序数据库吗？ 为什么没有找中文文档呢？</div>2020-03-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg" width="30px"><span>iron_man</span> 👍（1） 💬（3）<div>any：任何一个节点写入成功后，或者接收节点已将数据写入 Hinted-handoff 缓存（也就是写其他节点失败后，本地节点上缓存写失败数据的队列）后，就会返回成功给客户端。
这里“本地节点上缓存写失败数据的队列“是什么意思，不太明白，是指缓存备份吗？本地缓存写失败了再写到这个缓存里面？</div>2020-03-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg" width="30px"><span>qinsi</span> 👍（1） 💬（5）<div>W+R=N时应该也是最终一致吧</div>2020-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg" width="30px"><span>Gopher</span> 👍（0） 💬（1）<div>懂了这里的强一致性不是内部实现而是相当于外层实现</div>2020-07-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4a/93/8986789d.jpg" width="30px"><span>C生万物</span> 👍（0） 💬（3）<div>说了很多常见的东西，但偏偏一些容易搞混的点却没讲清楚，像客户端一致性跟线性一致性，我还以为quorum就能实现跟raft paxos一样的强一致性了。</div>2020-06-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/2e/c5/231114ed.jpg" width="30px"><span>Hadesu</span> 👍（0） 💬（0）<div>有三个节点，分别为a b c。假设key一开始不存在任何节点上。假设w等于2，r等于2。某个kv client把（key，value）写到了a节点，但之后kv client挂了。之后读的时候，会存在不一致的情况。情况一，一个节点有值，一个节点无值。情况二，两个节点都无值。</div>2024-04-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d7/cd/e069d1fe.jpg" width="30px"><span>顾文杰</span> 👍（0） 💬（1）<div>老师，对于W=N R=1的情况，针对某个key，如果N个W没有全部完成写value，此时出现不同的客户端访问不同的副本去读key，从不同的副本会不会读到不一样的值value？课程里面只讲了全部写完以后，对于正在写时，如何保证各个读的一致性有点疑惑</div>2023-03-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/8a/7e/bfe37c46.jpg" width="30px"><span>飞鱼</span> 👍（0） 💬（0）<div>从图中你可以看到，DATA-2 的读副本数为 2。也就是说，客户端读取 DATA-2 的数据时，需要读取 2 个副本中的数据，然后返回最新的那份数据。这里需要你注意的是，无论客户端如何执行读操作，哪怕它访问的是写操作未强制更新副本数据的节点（比如节点 B），但因为 W(2) + R(2) &gt; N(3)，也就是说，访问节点 B，执行读操作时，因为要读 2 份数据副本，所以除了节点 B 上的 DATA-2，还会读取节点 A 或节点 C 上的 DATA-2，就像上图的样子（比如节点 C 上的 DATA-2），而节点 A 和节点 C 的 DATA-2 数据副本是强制更新成功的。这个时候，返回给客户端肯定是最新的那份数据。

老师，这里B节点是旧数据，C或A是最新的数据。那么，客户端是如何在A\C 和B中做取舍的，他怎么知道B是旧的，是因为有额外存储的版本信息吗？</div>2022-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/8a/7e/bfe37c46.jpg" width="30px"><span>飞鱼</span> 👍（0） 💬（0）<div>读一致性和写一致性，具体是什么意思？</div>2022-06-22</li><br/><li><img src="" width="30px"><span>public</span> 👍（0） 💬（0）<div>我能在哪找到更多有关于实现思路的细节，比如如何确定数据应该写到哪些副本上。副本和数据关系的维护是怎样的。</div>2022-04-23</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKoEicqUZTJly55qoUXRmK4wia7YbnibsMncJaO6tKgKAQNJRfpMsibvfeiaukIibsCsuaic8QjQ3gOoTGA/132" width="30px"><span>张可夫斯基</span> 👍（0） 💬（0）<div>W为all，R为1时，容错能力最好吧？ 可以容忍N-1副本故障。 W为1时，R为ALL，当刚写入数据的那个副本挂掉，那就会产生数据丢失吧？ 所以W至少写入2个以上，才能保证数据不丢失？</div>2022-03-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg" width="30px"><span>Z宇锤锤</span> 👍（0） 💬（0）<div>两副本就可以。读一写二，或者读二写一，都可以保证读取到最新数据</div>2022-01-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg" width="30px"><span>核桃</span> 👍（0） 💬（0）<div>在glusterfs里面还有一种叫仲裁节点的出现，可以理解为2+1的副本机制，其中2是两个副本数据节点，1是仲裁节点，该节点只保留分片副本元数据，不实际保存数据，这样做是为了减少副本数据量的，只要写入元数据一致就可以了，但是不需要所有副本数据都必须写入成功。可以借鉴一下。</div>2021-12-16</li><br/>
</ul>