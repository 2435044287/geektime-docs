你好，我是陶辉。

上一讲我们从多个角度优化HTTP/1的性能，但获得的收益都较为有限，而直接将其升级到兼容HTTP/1的HTTP/2协议，性能会获得非常大的提升。

HTTP/2协议既降低了传输时延也提升了并发性，已经被主流站点广泛使用。多数HTTP头部都可以被压缩90%以上的体积，这节约了带宽也提升了用户体验，像Google的高性能协议gRPC也是基于HTTP/2协议实现的。

目前常用的Web中间件都已支持HTTP/2协议，然而如果你不清楚它的原理，对于Nginx、Tomcat等中间件新增的流、推送、消息优先级等HTTP/2配置项，你就不知是否需要调整。

同时，许多新协议都会参考HTTP/2优秀的设计，如果你不清楚HTTP/2的性能究竟高在哪里，也就很难对当下其他应用层协议触类旁通。而且，HTTP/2协议也并不是毫无缺点，到2020年3月时它的替代协议[HTTP/3](https://zh.wikipedia.org/wiki/HTTP/3) 已经经历了[27个草案](https://tools.ietf.org/html/draft-ietf-quic-http-27)，推出在即。HTTP/3的目标是优化传输层协议，它会保留HTTP/2协议在应用层上的优秀设计。如果你不懂HTTP/2，也就很难学会未来的HTTP/3协议。

所以，这一讲我们就将介绍HTTP/2对HTTP/1.1协议都做了哪些改进，从消息的编码、传输等角度说清楚性能提升点，这样，你就能理解支持HTTP/2的中间件为什么会提供那些参数，以及如何权衡HTTP/2带来的收益与付出的升级成本。
<div><strong>精选留言（19）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg" width="30px"><span>Geek_007</span> 👍（13） 💬（1）<div>虽然h2做了很多性能上的提升，但还是得结合实际来看，比如上传大文件使用h2的话，性能会不及h1。因为上传的文件大小是一样的，但是h2的流控会限制住每条connection,h2的默认控制窗口在65535字节，尽管tcp没有拥塞窗口的控制，但也要受限于h2自己的流控。也就是一路发送65535字节后就得等服务端ack。所以链接复用只对小请求有效。除非客户端和服务端避免特地避免了上述问题。陶老师，觉得呢？</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg" width="30px"><span>test</span> 👍（12） 💬（2）<div>protobuf是对请求body进行了压缩，http2是对请求的header进行压缩。http2还可以使用stream方式传输，这些都是protobuf没有解决的。</div>2020-06-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/f9/30/54c71bf9.jpg" width="30px"><span>不会飞的海燕</span> 👍（10） 💬（1）<div>老师，既然h2只是对头部进行压缩，那h2+pb压缩Body是不是可以进一步减少体积；我看有的公司使用tcp+pb，这种方式比h2+pb传输效率高吗</div>2020-06-26</li><br/><li><img src="" width="30px"><span>myrfy</span> 👍（9） 💬（2）<div>请问老师，h2的推送和websocket有什么区别呢？</div>2020-06-10</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132" width="30px"><span>有铭</span> 👍（4） 💬（1）<div>我查了很多资料，都说h2的推送是针对资源的，单次请求，主动传输多个关联资源。目前没发现有暴露api给应用层使用者主动推送消息的案例。所以似乎h2的推送和我们传统意义上的推送不是一个概念，至少它和websocket这种真正的应用层可控双向传输不是一回事。我也希望老师能有案例告诉我h2真能达到websocket那种效果</div>2020-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg" width="30px"><span>冬风向左吹</span> 👍（4） 💬（1）<div>请问老师，不知道我的这些理解是不是对的：
1、多个stream并发是共用的同一个tcp连接，所以只需要1 次 TCP 握手、1 次 TCP 慢启动以及 1 次 TLS 握手；
2、因为多个stream共用了同一个tcp连接，tcp报文是有序的，所以也会有队头阻塞问题；
3、同一个stream中的多个请求是串行的；
4、首个请求使用静态表和Huffman编码，后续请求头部使用动态表编码；

疑问：
老师的示例中，为什么host头部一会儿在静态表中，一会儿在动态表中？是因为上面第4点的原因吗？</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/56/75/6bf38a1e.jpg" width="30px"><span>坤哥</span> 👍（3） 💬（1）<div> 感觉stream 好像rabbitmq  的channel 的概念，也是tcp同一个socket多路复用，不知道理解对吗？</div>2020-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg" width="30px"><span>妥协</span> 👍（3） 💬（1）<div>请教老师，多个stream之间并发是通过stream id做隔离的吗？wireshake中看到的一条条记录是frame还是message?</div>2020-06-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg" width="30px"><span>惘 闻</span> 👍（1） 💬（1）<div>老师，syream相当于tcp链接，那么h2的并发stream不就相当于同时开了多个tcp链接吗？这样的话和h1有什么区别？</div>2021-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/56/75/6bf38a1e.jpg" width="30px"><span>坤哥</span> 👍（1） 💬（1）<div>老师，这讲我看了3次也不明白，你的另一课程web socket有这方面的详细展开吗？</div>2020-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/60/de/d752c204.jpg" width="30px"><span>鹤鸣</span> 👍（1） 💬（1）<div>静态表和动态表本身也是占了一定的空间的，在发送报文时，静态表本身不需要随着报文被发送，因为双方已经达成了共识。但是对端不知道动态表是如何编码的，所以动态表则需要随着报文一起发送。也就是说，动态表本身也占了一部分发送的数据量，增大了待发送报文的长度。</div>2020-06-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg" width="30px"><span>J.Smile</span> 👍（0） 💬（1）<div>老师，动态表简单理解是不是这样子？
比如客户端第一次服务器，客户端将请求的头部对象进行动态表构建，然后发给服务端，服务端这边也会构建动态表。以后客户端再发请求每次就传递数字了。</div>2020-07-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg" width="30px"><span>安排</span> 👍（9） 💬（0）<div>静态表保存了最常用的一些头部，这些不变的头部可以全局保存一份，节约内存，不用每个连接重新构建，也节省构建表的时间。</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg" width="30px"><span>Only now</span> 👍（1） 💬（0）<div>静态编码兼容连接初始阶段，在首次发起连接时，无连接历史统计数据可做参考，此时要能效率的使用编码，那么只好使用预制的编码表，这样可以做到多端，多服务的统一。

基于连接上的历史数据统计信息做动态是需要额外付出代价的，它同时要求客户端和服务器进行传输统计，且由于并发请求和响应引起的两端同步问题可能导致动态编码表的不一致。</div>2020-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/97/69/80945634.jpg" width="30px"><span>罐头瓶子</span> 👍（1） 💬（0）<div>静态 Huffman 编码可以在第一次传输时就降低头部大小，这部分编码是所有链接都可公用的，服务端客户端可降低动态编码的内存消耗。</div>2020-06-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg" width="30px"><span>全麦小面包</span> 👍（0） 💬（0）<div>老师的例子中，静态Huffman码有5位的，也有6位的，怎么确定当前读的数据是几位呀？</div>2023-04-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/37/a0/032d0828.jpg" width="30px"><span>上杉夏香</span> 👍（0） 💬（0）<div>动态哈夫曼编码。首先需要客户端与服务器相一致，其次因为动态维护，需要占用彼此的内存，另外就是占用cpu资源，每次请求响应都需要动态计算调整。整体效果不如静态提前编码好。</div>2022-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg" width="30px"><span>李二木</span> 👍（0） 💬（0）<div>stream的单号和双号是什么意思？是奇数和偶数区别吗？
</div>2022-02-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg" width="30px"><span>那时刻</span> 👍（0） 💬（0）<div>请教一个在HTTP&#47;2里Stream权重的问题，A（权重12）、B（权重8）的Stream依赖传输 C（权重3）Stream, 此时这个Stream的权重还是 3么？如果权重是3的话，那之前A，B所在Stream被丢弃了么？</div>2020-06-10</li><br/>
</ul>