你好，我是蒋德钧。

Redis官方在今年5月份正式推出了6.0版本，这个版本中有很多的新特性。所以，6.0刚刚推出，就受到了业界的广泛关注。

所以，在课程的最后，我特意安排了这节课，想来和你聊聊Redis 6.0中的几个关键新特性，分别是面向网络处理的多IO线程、客户端缓存、细粒度的权限控制，以及RESP 3协议的使用。

其中，面向网络处理的多IO线程可以提高网络请求处理的速度，而客户端缓存可以让应用直接在客户端本地读取数据，这两个特性可以提升Redis的性能。除此之外，细粒度权限控制让Redis可以按照命令粒度控制不同用户的访问权限，加强了Redis的安全保护。RESP 3协议则增强客户端的功能，可以让应用更加方便地使用Redis的不同数据类型。

只有详细掌握了这些特性的原理，你才能更好地判断是否使用6.0版本。如果你已经在使用6.0了，也可以看看怎么才能用得更好，少踩坑。

首先，我们来了解下6.0版本中新出的多线程特性。

## 从单线程处理网络请求到多线程处理

**在Redis 6.0中，非常受关注的第一个新特性就是多线程**。这是因为，Redis一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写），但是，从网络IO处理到实际的读写命令处理，都是由单个线程完成的。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erKbqXs1LibG86q2OxHLic21eduYd9JPCf5ZaDlic3Dk7P0rS1n9jjExrvE6tmartuhPQhgSeEHZ1SaQ/132" width="30px"><span>Geek_04f704</span> 👍（24） 💬（4）<div>老师，redis支持多线程后，怎么实现单命令操作原子性的？</div>2020-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg" width="30px"><span>东</span> 👍（17） 💬（1）<div>6.0的权限细粒度控制对我们很有用，以前多个微服务共享同一个redis集群，权限没法隔离，现在可以控制不同的服务使用不同的key前缀，从而很好的隔离了服务，可以有效避免误操作，或者一个服务的bug影响到所有服务。</div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/3a/1a/ae3c1492.jpg" width="30px"><span>🌾🌾🌾小麦🌾🌾🌾</span> 👍（8） 💬（1）<div>请问老师客户端缓存端缓存会不会导致缓存污染及内存泄露问题？</div>2020-12-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/19/61/119cbde2.jpg" width="30px"><span>Dolly</span> 👍（7） 💬（2）<div>客户端缓存那个直接解决redis和本地缓存的一致性问题</div>2020-12-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/71/11/2d5cdb14.jpg" width="30px"><span>pretty.zh</span> 👍（6） 💬（1）<div>老师，redis常量池是什么</div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg" width="30px"><span>Kaito</span> 👍（109） 💬（12）<div>Redis 6.0 的哪些新特性帮助最大？

我觉得 Redis 6.0 提供的多 IO 线程和客户端缓存这两大特性，对于我们使用 Redis 帮助最大。

多 IO 线程可以让 Redis 在并发量非常大时，让其性能再上一个台阶，性能提升近 1 倍，对于单机 Redis 性能要求更高的业务场景，非常有帮助。

而客户端缓存可以让 Redis 的数据缓存在客户端，相当于每个应用进程多了一个本地缓存，Redis 数据没有变化时，业务直接在应用进程内就能拿到数据，这不仅节省了网络带宽，降低了 Redis 的请求压力，还充分利用了业务应用的资源，对应用性能的提升也非常大。</div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg" width="30px"><span>那时刻</span> 👍（19） 💬（14）<div>Redis 6.0增加了IO线程来处理网络请求，如果客户端先发送了一个`set key1 val1`写命令，紧接着发送一个`get key1`读命令。请问老师，由于IO线程是多线程处理的，是否会导致`get key1`读命令 先于 `set key1 val1`写命令执行呢？结果客户端读到了key1的旧值。</div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/fb/ab/c0c29cda.jpg" width="30px"><span>王世艺</span> 👍（15） 💬（4）<div>多线程io和epoll啥区别</div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/dd/61/544c2838.jpg" width="30px"><span>kevin</span> 👍（4） 💬（0）<div>请问下，redis的客户端缓存与业务实例的本地缓存有区别吗？</div>2020-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/22/4c/d413494f.jpg" width="30px"><span>听秋</span> 👍（1） 💬（1）<div>老师，客户端缓存的普通模式，当不在收到服务端的通知时，服务端 的 key 被修改了，应用读的是缓存到本地的数据，那不就读到旧数据了吗？</div>2021-12-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg" width="30px"><span>哦</span> 👍（1） 💬（1）<div>请问，这里Redis6.0的多线程模式是不是可以理解为多Reactor单线程的模式</div>2021-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ba/e4/6df89add.jpg" width="30px"><span>芋头</span> 👍（1） 💬（0）<div>Redis 6.0新特性:1.处理网络IO采用多线程模式2.服务端协助的客户端的缓存（普通模式和广播模式及重定向模式通知客户端key失效的信息）3.实现RESP3 协议，支持多种类型区分编码4.实例的细粒度访问权限控制（不同用户不同权限及用户为粒度的命令权限及支持以key为粒度用户权限）</div>2021-04-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg" width="30px"><span>Kvicii.Y</span> 👍（1） 💬（1）<div>这个多IO线程我没有看懂作用、能解释下吗</div>2021-03-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（1） 💬（3）<div>老师好，我翻了一下6.2的源码，多线程IO处理这个地方，主线程通知IO线程处理数据后，线程好像不算是阻塞状态吧？

int handleClientsWithPendingReadsUsingThreads(void) 函数里，主线程会一次性将多个接收请求分配给多个IO线程，然后一个死循环等待IO线程全部处理完毕，但线程状态应该是运行状态，不是阻塞状态吧？</div>2021-02-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/68/5d/1ccee378.jpg" width="30px"><span>茫农</span> 👍（1） 💬（0）<div>1，主线程等待io线程写完清空队列，队列里存的是什么？
2，等待写完是说主线程是一批一批的处理请求吗，是处理完一批再接一批处理？</div>2021-02-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/95/8d/e27e5c7a.jpg" width="30px"><span>陌上花开</span> 👍（1） 💬（0）<div>主线程接收完请求以后，通过轮询的方式交给IO线程处理，IO处理的速度可能会存在不一致的情况，如果保证主线程在执行命令的时候是按照轮询的顺序？</div>2021-01-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg" width="30px"><span>小耿</span> 👍（0） 💬（0）<div>新特性中对我可能有帮助的：客户端缓存。客户端缓存能够有效降低redis的压力，提高客户端的访问速度，在频繁访问redis的系统中可以有效提高系统性能。</div>2023-10-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/d2/74/7861f504.jpg" width="30px"><span>马听</span> 👍（0） 💬（0）<div>纠错
“设置 io-thread-do-reads 配置项为 yes，表示启用多线程”
这里应该是io-threads-do-reads，不过下面配置文件示例是写对的</div>2023-10-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/d0/32/4777bf94.jpg" width="30px"><span>Geek_bdce73</span> 👍（0） 💬（0）<div>多线程是不是把多路复用epoll模型给去掉了，各位大神怎么看</div>2022-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/6f/e2/f3b05833.jpg" width="30px"><span>A 拽丫头</span> 👍（0） 💬（0）<div>多线程io  和  io多路复用有啥区别？ 我怎么感觉这两个是一个咧</div>2022-08-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg" width="30px"><span>cake</span> 👍（0） 💬（0）<div>客户端需要根据操作的命令或是数据类型自行对传输的数据进行解码，增加了客户端开发复杂度   应该是对传输的数据进行编码叭 0.0？</div>2021-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/bf/4b/2acf59c1.jpg" width="30px"><span>我</span> 👍（0） 💬（0）<div>redis6新的过期key扫描机制，相比于redis4可以有效的防止过期key堆积，可以节约成本。</div>2021-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/93/4f/61edeea6.jpg" width="30px"><span>Ac、</span> 👍（0） 💬（0）<div>对于Redis 6.0 来说，如果开启多 IO 线程的话，就不用 epoll。也就是说，多 IO 线程是 epoll 的一个替代方案？</div>2021-06-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/f7/6c/c5997b0b.jpg" width="30px"><span>Geek_zt</span> 👍（0） 💬（1）<div>客户端？服务端？是指什么，都是redis实例，还是一个后端为客户端，redis实例为服务端</div>2021-05-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（0） 💬（0）<div>Redis 使用多 IO 线程处理网络请求，单线程处理读写命令，这应该是一个很好的 trade-off。

不知道国内公司采用 Redis 6.0 的多不多，对那些做了二次开发的，可能升级会困难一些；相对而言，可能小团队更容易升级。

对于课后题，小白无从解答，只能揣测。

是否需要多线程网络 IO 处理以及服务端协助的客户端缓存，可能需要看具体的业务场景；细粒度的权限控制和 RESP 3 协议感觉似乎比较有用。</div>2021-04-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg" width="30px"><span>浩仔是程序员</span> 👍（0） 💬（0）<div>老师，客户端缓存是要自己根据tracking特性在业务中去实现吗？</div>2021-02-15</li><br/><li><img src="" width="30px"><span>小轨道王子</span> 👍（0） 💬（0）<div>主线程和io线程交互队列类似dpdk的无锁队列吗？io线程怎么感知主线程有消息扔过来了？</div>2021-02-09</li><br/><li><img src="" width="30px"><span>Geek_1e8830</span> 👍（0） 💬（0）<div>权限控制到key这个级别对性能会不会有影响？</div>2021-02-06</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/4qo5a7dgS8002fyNiciczVEWyaHH9Jw0WPoO59aRlIC8XNTRFNuMp3l8ELeC4DSY4yL84klibWIjZaicfL09P2aamA/132" width="30px"><span>Geek_feee06</span> 👍（0） 💬（0）<div>这种监测带有前缀的 key 的广播模式，与etcd的watch --prefix功能类似。不同点在于Redis返回给客户端的是invalidate消息，而etcd是返回更新后的值。所以etcd中这个功能一般用于配置共享与服务发现，而Redis直接返回无效，客户端若想获取最新的值，就得重新读取。有个疑问为什么Redis不像etcd这样也返回更新后的值给客户端呢？</div>2020-12-10</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/4qo5a7dgS8002fyNiciczVEWyaHH9Jw0WPoO59aRlIC8XNTRFNuMp3l8ELeC4DSY4yL84klibWIjZaicfL09P2aamA/132" width="30px"><span>Geek_feee06</span> 👍（0） 💬（0）<div>这种监测带有前缀的 key 的广播模式，和etcd的watch prefix功能一样，不知道底层实现和性能有何差异？</div>2020-12-10</li><br/>
</ul>