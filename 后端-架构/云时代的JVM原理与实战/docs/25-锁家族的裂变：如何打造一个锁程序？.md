你好，我是康杨。

在多线程编程中，锁是一个非常重要的概念。了解不同类型的锁以及它们的特性和使用场合，能够帮助我们编写出高并发、高效率的程序。今天我们来聊聊Java中的各种锁，深入剖析这些锁的工作原理和应用场景，并了解如何使用AQS（AbstractQueuedSynchronizer）构造自定义锁。

## 锁的分类

Java 锁可以根据不同的维度进行分类，这里我列举了几种常见的分类方式。

### 乐观锁和悲观锁

乐观锁和悲观锁是并发控制领域的两种主要策略，它们在处理多线程对共享资源的访问时采用不同的方法。

乐观锁，顾名思义，是一种比较乐观的策略。它假设数据在同一时间被多个线程修改的概率比较小，因此不会在读取操作时对数据加锁。这种锁策略适用于读取操作远多于写入操作的场景。在 Java 中，原子操作类（如 AtomicInteger、AtomicLong 等）就是乐观锁的典型应用。乐观锁的核心思想是，在读取数据时，不考虑数据可能被其他线程修改的情况，只在数据写入时通过版本号机制进行校验。如果发现数据已经被其他线程修改，那么就放弃此次写入，重新读取数据并尝试再次写入。

悲观锁，则是一种比较悲观的策略。它假设数据在同一时间被多个线程访问的概率较大，因此会始终对数据进行加锁保护。这种锁策略适用于数据竞争比较激烈的场景。在 Java 中，同步关键字 Synchronized 或 ReentrantLock 就是典型的悲观锁。悲观锁的核心思想是，在任何时候，只允许一个线程对数据进行操作，其他线程必须等待，直到获得锁。这样就能确保数据在读取和写入过程中的安全性。
<div><strong>精选留言（2）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/28/1d/a9/89f3108a.jpg" width="30px"><span>进德修业</span> 👍（5） 💬（5）<div>独占锁和共享锁代码，怎么看两个除了方法名不一样其他都一样，是不是初始化的时候写错了呀</div>2023-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg" width="30px"><span>peter</span> 👍（0） 💬（0）<div>请教老师两个问题：
Q1：共享锁需要等待的话还怎么共享？
文中这句话“当一个线程想要获取共享锁，但如果当前已经有其他线程持有共享锁，那么这个线程必须等待”，根据这句话，也只能是一个线程能够获取锁，这怎么共享？
Q2：共享锁、独占锁的例子，有什么区别？
Lock exclusiveLock = new ReentrantLock();
Lock sharedLock = new ReentrantLock();
两个定义相同，使用的代码也相同，怎么区分共享与独占？</div>2023-10-25</li><br/>
</ul>