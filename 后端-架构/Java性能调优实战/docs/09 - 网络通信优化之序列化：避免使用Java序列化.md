你好，我是刘超。

当前大部分后端服务都是基于微服务架构实现的。服务按照业务划分被拆分，实现了服务的解耦，但同时也带来了新的问题，不同业务之间通信需要通过接口实现调用。两个服务之间要共享一个数据对象，就需要从对象转换成二进制流，通过网络传输，传送到对方服务，再转换回对象，供服务方法调用。**这个编码和解码过程我们称之为序列化与反序列化。**

在大量并发请求的情况下，如果序列化的速度慢，会导致请求响应时间增加；而序列化后的传输数据体积大，会导致网络吞吐量下降。所以一个优秀的序列化框架可以提高系统的整体性能。

我们知道，Java提供了RMI框架可以实现服务与服务之间的接口暴露和调用，RMI中对数据对象的序列化采用的是Java序列化。而目前主流的微服务框架却几乎没有用到Java序列化，SpringCloud用的是Json序列化，Dubbo虽然兼容了Java序列化，但默认使用的是Hessian序列化。这是为什么呢？

今天我们就来深入了解下Java序列化，再对比近两年比较火的Protobuf序列化，看看Protobuf是如何实现最优序列化的。

## Java序列化

在说缺陷之前，你先得知道什么是Java序列化以及它的实现原理。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg" width="30px"><span>陆离</span> 👍（104） 💬（7）<div>序列化会通过反射调用无参构造器返回一个新对象，破坏单例模式。
解决方法是添加readResolve()方法，自定义返回对象策略。</div>2019-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg" width="30px"><span>密码123456</span> 👍（26） 💬（7）<div>看到提问，才发现这竟然不是单例。回想内容是因为。可以把类路径上几乎所有实现了 Serializable 接口的对象都实例化。还真不知道怎么写？内部私有类实现，这种可以吗？</div>2019-06-08</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（9） 💬（1）<div> 它会在反序列化过程中来验证序列化对象是否加载了反序列化的类，如果是具有相同类名的不同版本号的类，在反序列化中是无法获取对象的。老师，这句话能举个例子么，没太明白</div>2019-09-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e1/df/6e6a4c6b.jpg" width="30px"><span>kevin</span> 👍（8） 💬（1）<div>老师请教下，为什么spring cloud不使用protobuf, thrift等性能更高、支持跨平台的序列化工具，而且使用json？</div>2019-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（7） 💬（2）<div>文中说Java序列化，不会序列化静态变量，这个单例的静态变量会被怎么处理啊?
</div>2019-06-08</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ibvULfLvUITGs8lOOdibnc1loJg1mKhSv8iaZYYcObNmMdHSicNng9ia2nISPYYg1zHZFR0CSLpDia3jcWKcKDMrPVFA/132" width="30px"><span>waniz</span> 👍（6） 💬（2）<div>老师您好，Java序列化将数据转化为二进制字节流，json序列化将数据转化为json字符串。但是在物理层数据都是以电信号或模拟信号传输。那么从应用层到物理层数据的编码状态究竟是怎么变化的?出发点不同，最后都是二进制传输…忘解惑</div>2019-07-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（4） 💬（1）<div>想知道为什么用非Java的序列化方式的也需要实现Serializable接口？</div>2019-12-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（3） 💬（1）<div>课后思考及问题
1：老师能深入细致的讲讲JAVA怎么实现序列化的嘛？比如：一个对象怎么一步步神奇的变成一个字节数组的？对象中的属性、属性值、方法、以及此对象的信息怎么变成一个字节数组的？
2：我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。
这个神奇的构造器的实现原理是啥？一个字节数组他怎么将其转换为一个对象的？很好奇，他知道字节数组多少位表示啥意思？然后一段一段的取，一段的翻译嘛？老师给讲讲呗？
老师深入讲一下原理实现细节，API式的讲解不过瘾，和老师要深入理解的风格也不符呀😄</div>2019-09-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg" width="30px"><span>晓杰</span> 👍（1） 💬（2）<div>不是单例，因为在反序列化的时候，会调用ObjectInputStream的readObject方法，该方法可以对实现序列化接口的类进行实例化，所以会破坏单例模式。
可以通过重写readResolve，返回单例对象的方式来避免这个问题</div>2019-06-08</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（0） 💬（1）<div>序列化对象中加载反序列化的类怎么理解？</div>2020-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/4b/92/03338a22.jpg" width="30px"><span>王圣军</span> 👍（0） 💬（1）<div>我们有时基于网络通讯的传输，有的不是直接使用实例序列化后传输，很多就是字符串转换为二进制流进行传输，这个应该是不涉及到序列化和反序列化的吧？</div>2019-12-26</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132" width="30px"><span>td901105</span> 👍（0） 💬（3）<div>老师我想问一下如果使用非Java的序列化方式的话需要实现Serializable接口吗？</div>2019-12-05</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（0） 💬（1）<div>那么java的NIO用到了java的序列化和反序列化么？有一样的问题么</div>2019-09-14</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（0） 💬（1）<div> 老师，所有在网络中传输信息都是要序列化么</div>2019-09-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/1c/a2/2c3572de.jpg" width="30px"><span>辉</span> 👍（0） 💬（1）<div>hession是通过什么做序列化的？</div>2019-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg" width="30px"><span>undifined</span> 👍（0） 💬（1）<div>老师 我们有一个需求，需要将一些更新前的数据保存起来用于回滚，保存的对象有一个 value 属性是 Object 类型的，赋值 BigDecimal 后使用 FastJson 序列化保存到数据库，回滚的时候再反序列化变成了Integer，考虑将 FastJson 改成 JDK 的序列化，但是又担心会造成性能问题，请问老师有什么建议吗</div>2019-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg" width="30px"><span>Demon.Lee</span> 👍（0） 💬（1）<div>图一中，输入流ObjectInputStream应该是反序列吧，输出流ObjectOutputStream应该是序列化吧，老师我理解错了？</div>2019-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" width="30px"><span>Liam</span> 👍（0） 💬（1）<div>在java序列号安全性那里有个疑问，为什么反序列化会导致hashCode方法的频繁调用呢，反序列化时调用hashCode的作用是</div>2019-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg" width="30px"><span>colin</span> 👍（0） 💬（1）<div>Protobuf的格式感觉喝字节码有点类似</div>2019-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/64/14/2f3263e3.jpg" width="30px"><span>彦峰你要加油啊！</span> 👍（10） 💬（5）<div>稍微看了下评论,解决方法是在被序列化类中重写readResolve方法, 但是通过Jdk源码可以看出,虽然readResolve方法返回实例解决了单例模式被破坏的问题, 但实际上还是实例化了两次,只不过新创建的对象没有被返回而已.  
如果创建对象的动作发生频率加快,就意味着内存分配开销也会随之增大,应该使用注册式单例来解决这个问题.</div>2019-12-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg" width="30px"><span>强哥</span> 👍（7） 💬（0）<div>首先为什么单例要实现Serializable接口呢？如果本身就不合理，那直接删掉Serializable即可，没必要为了本身的不合理，添加多余的方法，除非有特殊场景，否则这么这样的代码指定会被ugly</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/63/85/9ccf1b19.jpg" width="30px"><span>草帽路飞</span> 👍（3） 💬（1）<div>老师，您好。Java 序列化的安全性中，序列化的时候执行按段循环对象链的代码为什么会导致 hashcode 成倍增长呀？</div>2019-06-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg" width="30px"><span>Sdylan</span> 👍（2） 💬（0）<div>2019.10.14 打卡：选择序列化四个原则：编解码效率、所占空间、安全、是否支持多语言</div>2019-10-14</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132" width="30px"><span>张学磊</span> 👍（1） 💬（0）<div>上面说默认序列化方式不会序列化对象的 transient 的实例变量，也不会序列化静态变量，那这个单例的变量是静态的，是不是可以理解序列化成了一个空对象？</div>2019-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/da/9a/ed524797.jpg" width="30px"><span>斯瓦辛武Roy</span> 👍（0） 💬（0）<div>能提供的一个maven插件编译protobuf生成java文件的demo么</div>2023-08-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/62/d3/791d0f5e.jpg" width="30px"><span>胡同学</span> 👍（0） 💬（0）<div>java.io.ObjectInputStream#readObject()反序列化不会调用构造函数</div>2022-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2a/39/6e/0ea71f8a.jpg" width="30px"><span>清风@知酒烈</span> 👍（0） 💬（1）<div>老师，我们项目也是使用dubbo，但是实体类都需要实现java的Serializable接口，不实现就会报错。不是说dubbo默认不使用java的序列化吗，为什么还是要实现Serializable呢？</div>2022-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg" width="30px"><span>keep_it_real</span> 👍（0） 💬（0）<div>Protobuf序列化的时候需要生成相对于的java文件，感觉里面多了好多没用的东西。不知道是不是我没用对。</div>2022-05-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/89/e6/cf1ea14c.jpg" width="30px"><span>NOFX</span> 👍（0） 💬（0）<div>Json、Protocol 反序列化是不是也会存在破坏单例的行为呢？</div>2021-08-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/81/d4/e92abeb4.jpg" width="30px"><span>Jecy-8</span> 👍（0） 💬（0）<div>文中的图，readResolve()方法应该是在反序列化（图中是序列化）之后的操作方法吧，不知道我理解对不对</div>2021-04-15</li><br/>
</ul>