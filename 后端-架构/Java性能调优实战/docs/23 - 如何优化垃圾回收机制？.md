你好，我是刘超。

我们知道，在Java开发中，开发人员是无需过度关注对象的回收与释放的，JVM的垃圾回收机制可以减轻不少工作量。但完全交由JVM回收对象，也会增加回收性能的不确定性。在一些特殊的业务场景下，不合适的垃圾回收算法以及策略，都有可能导致系统性能下降。

面对不同的业务场景，垃圾回收的调优策略也不一样。例如，在对内存要求苛刻的情况下，需要提高对象的回收效率；在CPU使用率高的情况下，需要降低高并发时垃圾回收的频率。可以说，垃圾回收的调优是一项必备技能。

这讲我们就把这项技能的学习进行拆分，看看回收（后面简称GC）的算法有哪些，体现GC算法好坏的指标有哪些，又如何根据自己的业务场景对GC策略进行调优？

## 垃圾回收机制

掌握GC算法之前，我们需要先弄清楚3个问题。第一，回收发生在哪里？第二，对象在什么时候可以被回收？第三，如何回收这些对象？

### 1. 回收发生在哪里？

JVM的内存区域中，程序计数器、虚拟机栈和本地方法栈这3个区域是线程私有的，随着线程的创建而创建，销毁而销毁；栈中的栈帧随着方法的进入和退出进行入栈和出栈操作，每个栈帧中分配多少内存基本是在类结构确定下来的时候就已知的，因此这三个区域的内存分配和回收都具有确定性。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（55） 💬（4）<div>1.7及前的都还好说，毕竟大部分开发都拜读过&lt;深入理解jvm&gt;。
回归整体，记得有点模糊了，如果有错误还请老师指正。首先cms在1.9已经被标记为废弃，主要原因在于标记清除下的悬浮内存，导致内存空间碎片化，进而导致fullGC的发生。不过其并行执行垃圾回收的性能还是值得认可的，至少1.9后主推的G1在常规情况下也是不如它的效率好的。接下来，说下G1，拼G1的堆内存结构比较特殊，虽然也有年代划分，但从物理角度上却不一样。G1将整块内存分配成若干个同等大小的reg。新生代（两个sub区加ed区）和老年代各自由不同数量的reg组成。垃圾回收的算法应该算是标记整理。所以其规避了cms内存碎片化的问题，大大降低了fullGC的频率。所以它虽然常态性能略输于cms但却没有cms特殊情况下的极端性能问题，总体更稳定。值得一提的是G1中各代的内存区域里reg间不一定是连续的，所以对于cpu缓存加载机制并不是特别友好，而且大对象占据超过一个reg时还带来内存浪费的问题。所以总的来说1.8可以用G1但得考虑场景，首先这个内存空间要大，保证每个reg尽量大，以减少内存浪费，保守估计8g以上用g1。实际公司很少会去升级jdk版本，大部分都是1.8，好在oracle一些1.9 10 11 12的特性都有以补丁的方式落到1.8。所以1.8还是比较安全实用的，虽然我们公司还是1.7，推不动哈。</div>2019-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" width="30px"><span>Liam</span> 👍（51） 💬（2）<div>1 minor gc是否会导致stop the world？
2 major gc什么时候会发生，它和full gc的区别是什么？</div>2019-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a2/ec/205fd50c.jpg" width="30px"><span>我又不乱来</span> 👍（21） 💬（2）<div>超哥，我建议可以分享一下那些对象可以作为gc root的对象，为什么这些对象可以做为gc root对象？</div>2019-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（19） 💬（2）<div>G1与CMS的优势在于以下几点：
1、并行与并发：G1能够更充分利用多CPU、多核环境运行
2、分代收集：G1虽然也用了分代概念，但相比其他收集器需要配合不同收集协同工作，但G1收集器能够独立管理整个堆
3、空间管理：与CMS的标记一清理算法不同，G1从整体上基于标记一整理算法，将整个Java堆划分为多个大小相等的独立区域（Region）,这种算法能够在运行过程中不产生内存碎片
4、可预测的停顿：降低停顿时间是G1和CMS共同目标，但是G1追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间不得超过N毫秒。</div>2019-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/58/84/fd5031e5.jpg" width="30px"><span>别忘微笑</span> 👍（10） 💬（2）<div>超哥，一个web应用，多久一次Full GC才算正常呢</div>2019-07-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg" width="30px"><span>K</span> 👍（5） 💬（1）<div>老师好，我有两个问题想问一下。1.比如说看到jvm的参数，-XX:+UseConcMarkSweepGC，这个参数是单独指定了老年代的收集器呢，还是年轻代、老年代都指定了？</div>2019-08-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4c/59/c75cb36d.jpg" width="30px"><span>N</span> 👍（3） 💬（2）<div>老师您好，公司ES服务器设置最大最小堆内存26个G，G1GC,  XX:MaxGCPauseMillis =500，一段时间内old gc 都会稳定在500ms以内，但每天总会有1-2次old gc 时间很长，大概3000ms.请问该如何优化呢？</div>2019-07-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg" width="30px"><span>Evan</span> 👍（2） 💬（1）<div>CMS 收集器 有一个浮动垃圾概念， 可能出现“Concurrent Mode Failure”  导致Full GC， 能否解决一下本质原因？</div>2020-03-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（2） 💬（2）<div>很棒，很清晰的讲明白了什么是垃圾？有几种收集垃圾的方式？有几种具体的垃圾收集器？
请问老师收集垃圾具体是一个什么原理？标记对应的内存可用了，还是将对应的数据都一个个清空了？
</div>2019-09-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg" width="30px"><span>发条橙子 。</span> 👍（2） 💬（1）<div>超哥 我想问下，相同的方法多次执行，再没有JIT编译的前提下，每一次执行都会进行一次解释执行莫？</div>2019-07-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg" width="30px"><span>nightmare</span> 👍（2） 💬（1）<div>老师看完有两个疑问，第一这么查看minor gc回收之后 eden区存活对象的多少，第二 jmap -heap pid在图中只能看年轻代parallel gc看不到老年代的是什么垃圾回收器    对于提问 cms垃圾回收器还是分老年代和年轻代回收分多个阶段有和程序并行的阶段也有stop the world阶段 回收一整块老年代时间比较久，而 gc把年轻代和老年代也有划分，不过拆成一个region了，对region的回收成本低，而且会判断那些region回收的对象更多，而且cms要经过多次full gc才可能把不用的内存归还给操作系统  而g1只需要一次full gc就可以</div>2019-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c2/fe/038a076e.jpg" width="30px"><span>阿卧</span> 👍（1） 💬（1）<div>cms回收器只能在老年代使用吗。</div>2020-02-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg" width="30px"><span>K</span> 👍（1） 💬（1）<div>第二个问题就是，比如说我指定了：-XX:+UseConcMarkSweepGC，也指定了：-XX:+UseParallelOldGC，那么年轻代、老年代分别是用了什么垃圾回收器呢？麻烦老师解答一下，谢谢！</div>2019-08-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg" width="30px"><span>nightmare</span> 👍（1） 💬（2）<div>老师，查看minor gc存活对象的命令是什么呢</div>2019-07-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（1） 💬（1）<div>老师好!Serial Old不是标记整理算法么?Serial new是复制吧。我记得年轻代都是采用复制的，老年代除了CMS是标记清除(存在内存碎片)别的好像都是标记整理整理吧。</div>2019-07-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg" width="30px"><span>Demon.Lee</span> 👍（0） 💬（2）<div>老师，GCViewer中&quot;Event Details&quot;里面的75th, 95th, 99th 是啥意思，没理解。</div>2020-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（0） 💬（1）<div>初始化堆大小和最大堆大小的区别是什么啊？如果设置的初始化堆大小&lt;最大堆大小，那么堆的使用容量达到了初始化大小时候，会自动扩容吗？？</div>2020-01-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg" width="30px"><span>而立斋</span> 👍（0） 💬（1）<div>cms执行垃圾回收的过程:初始标记、并发标记、重新并行标记、执行回收，这就意味着标记了多少垃圾就回收多少，直到回收完为止，典型的标记整理&#47;清除算法
g1回收器的过程类似:初始标记、并发标记、最终标记、选择回收。最后这个选择回收就很有意思，在规定的停顿时间内，我如果回收不完，我就选择性的回收呗。所以这也就是g1为什么能够被1.9当成默认收集器的原因吧</div>2019-12-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg" width="30px"><span>风轻扬</span> 👍（0） 💬（1）<div>老师。我翻阅了&lt;深入理解java虚拟机&gt;。里面提到了，Serial Old的老年代回收算法是：标记整理。不是标记清除。我查阅了oracle官网，看到的答案也是：mark-compact。应该就是标记整理</div>2019-09-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg" width="30px"><span>风轻扬</span> 👍（0） 💬（1）<div>老师。介绍这些垃圾回收器的官方网站，您有吗？</div>2019-09-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg" width="30px"><span>风轻扬</span> 👍（0） 💬（1）<div>老师，我今天监控了一下Idea的启动。然后把Idea启动的gc日志输出到log文件，上传到GC easy了。我年轻代设置的明明是-Xmn2048m，但是GC easy显示的年轻代还是之前的旧值1g，也就是1024。我又用visualVM监控了一下，visualVM显示的就是2048了，这是怎么回事呢?</div>2019-09-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/64/79/f1e1ca76.jpg" width="30px"><span>努力奋斗的Pisces</span> 👍（0） 💬（1）<div>G1已经没有分代可言了</div>2019-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg" width="30px"><span>nightmare</span> 👍（0） 💬（1）<div>老师你的垃圾回收器serial old 和 parallel old都是标记整理算法吧，而图片上写的是标记清除算法？</div>2019-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg" width="30px"><span>FelixFly</span> 👍（15） 💬（5）<div>在 JDK1.8 环境下，默认使用的是 Parallel Scavenge（年轻代）+Serial Old（老年代）垃圾收集器。老师，这个地方你写错了吧，用jinfo -flags 进程ID打印出-XX:+UseParallelGC是使用的这个，这个在官方文档说的是-XX:+UseParallelGC启用，-XX:+UseParallelOldGC这个会自动启用，应该为Parallel Scavenge（年轻代）+Parallel Old（老年代）垃圾收集器
官网参数说明（查看的是linux下的）
-XX:+UseParallelGC
Enables the use of the parallel scavenge garbage collector (also known as the throughput collector) to improve the performance of your application by leveraging multiple processors.

By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM. If it is enabled, then the -XX:+UseParallelOldGC option is automatically enabled, unless you explicitly disable it.</div>2019-11-19</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLmxBGkh4RfIaiakV14ErYFsic0dfQgtZrD5hicVJQn5T5AQ95aqhibBoQVs02OWuFOTWMV1TAYkpX2rw/132" width="30px"><span>Policy</span> 👍（1） 💬（0）<div>老师，这个没懂：所以再发生 Minor  GC 的时间为：两次扫描新生代，即 2T1。是因为时间间隔长了一倍，所以扫描对象的数量多了一倍？</div>2022-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/f6/50/34f89402.jpg" width="30px"><span>🦄</span> 👍（0） 💬（0）<div>我们用的是parallel old垃圾收集器，这个Full GC的触发条件可以配置么？ 老年代内存不停的增加，有没有可能年轻带最后一次回收导致JVM做Fullgc，整个内存不够导致应用直接挂掉呀，我发现了这种现象，就是一直不做fullgc，然后最后做的那一次应用挂了，这种怎么排查问题呀</div>2022-06-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/0e/bb/358c293c.jpg" width="30px"><span>杨雪宁</span> 👍（0） 💬（0）<div>老师，一直有个疑问，有说CMS适用于10G以内的内存，这个说法对吗？</div>2022-03-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg" width="30px"><span>平民人之助</span> 👍（0） 💬（0）<div>像替换架构组件这个问题，如何去推动并且规避人际风险呢？</div>2021-07-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/2c/4c/0eb5d084.jpg" width="30px"><span>刚好</span> 👍（0） 💬（1）<div>老师，请问对象超过多大会被直接放到老年代，请问这个阈值如何设置</div>2021-03-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg" width="30px"><span>惘 闻</span> 👍（0） 💬（0）<div>可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。
这里的T1 不会随着扩容后Minor GC的频率变小而跟着改变吗?
扩容后两个T1,说明600ms进行了两次扫描,那么扫描仍然还是300ms一次.但是GC频率却变成了600ms一次.</div>2020-12-29</li><br/>
</ul>