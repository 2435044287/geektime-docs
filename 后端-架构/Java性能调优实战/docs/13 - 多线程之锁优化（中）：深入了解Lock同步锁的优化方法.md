你好，我是刘超。

今天这讲我们继续来聊聊锁优化。上一讲我重点介绍了在JVM层实现的Synchronized同步锁的优化方法，除此之外，在JDK1.5之后，Java还提供了Lock同步锁。那么它有什么优势呢？

相对于需要JVM隐式获取和释放锁的Synchronized同步锁，Lock同步锁（以下简称Lock锁）需要的是显示获取和释放锁，这就为获取和释放锁提供了更多的灵活性。Lock锁的基本操作是通过乐观锁来实现的，但由于Lock锁也会在阻塞时被挂起，因此它依然属于悲观锁。我们可以通过一张图来简单对比下两个同步锁，了解下各自的特点：

![](https://static001.geekbang.org/resource/image/8e/3d/8ec55dc637830f728e505c673fefde3d.jpg?wh=1238%2A660)

从性能方面上来说，在并发量不高、竞争不激烈的情况下，Synchronized同步锁由于具有分级锁的优势，性能上与Lock锁差不多；但在高负载、高并发的情况下，Synchronized同步锁由于竞争激烈会升级到重量级锁，性能则没有Lock锁稳定。

我们可以通过一组简单的性能测试，直观地对比下两种锁的性能，结果见下方，代码可以在[Github](https://github.com/nickliuchao/syncLockTest)上下载查看。

![](https://static001.geekbang.org/resource/image/5c/b4/5c71e1402407e8970f51f9253fb716b4.jpg?wh=2120%2A922)

通过以上数据，我们可以发现：Lock锁的性能相对来说更加稳定。那它与上一讲的Synchronized同步锁相比，实现原理又是怎样的呢？
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" width="30px"><span>Liam</span> 👍（69） 💬（3）<div>StampLock不支持重入，不支持条件变量，线程被中断时可能导致CPU暴涨</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg" width="30px"><span>我知道了嗯</span> 👍（24） 💬（2）<div>可重入锁是什么？另外什么场景下会使用到？</div>2019-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（18） 💬（1）<div>老师好!读写锁那个流程图看不太明白，没有写线程的时候，判断不是当前线程在读就会进入CLF阻塞等待。
问题1:不是可以并发读的嘛?按这图读线程也要阻塞等待的意思么?
问题二:CLF阻塞队列里是读写线程公用的么?队列里，读写交替出现。那不就没法并发读了么?</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg" width="30px"><span>密码123456</span> 👍（13） 💬（1）<div>为什么？因为锁不可重入？</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/4b/92/03338a22.jpg" width="30px"><span>王圣军</span> 👍（10） 💬（1）<div>老师这里说的公平锁和非公平锁让我想起两者是获取方式不同，非公平锁是首先就CAS来获取一次，成功就拿到锁，失败就放入队列；公平锁不会有这步操作，直接放入队列</div>2019-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg" width="30px"><span>码农Kevin亮</span> 👍（7） 💬（4）<div>请问老师，在读写锁的场景中，我在读操作时为什么还要加锁？直接读不就可以了？如果担心数据不刷新，那在变量加volatile是不是就可以满足？请解惑</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" width="30px"><span>张三丰</span> 👍（6） 💬（1）<div>获取读锁的流程图有问题吧，应该是判断写锁是否为当前线程，而不是判断读锁。</div>2020-04-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（5） 💬（1）<div>StampedLock在写多读少的时候性能会很差吧</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg" width="30px"><span>你好旅行者</span> 👍（4） 💬（1）<div>老师我有几个问题：
1.在ReentrantLock中，state这个变量，为0的时候表示当前的锁是没有被占用的。这个时候线程应该用CAS尝试修改state变量的值对锁进行抢占才对呀，为什么在您的图里当state=0的时候还需要判断是否为当前线程呢？
2.老师提到读写锁在读多写少的情况下会使得写线程遭遇饥饿问题，那我是不是只需要将锁设置为公平锁，这样先申请写锁的线程就可以先获得锁，从而避免饥饿问题呢？
3.StampedLock中引入了一个stamp版本对版本进行控制，那么对这个stamp变量进行写入的时候是否需要使用CAS操作？如果不是，那如何保证对stamp变量的读写是线程安全的呢？
谢谢老师！
</div>2019-06-18</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/icHicAP9M4M4DIjAvlj5FDdFxIeA0pR3J15QdvVjXQXbznwunDN8OvrYqnsFchtBTNrZCCfGTE2RpPzIxjkvFAKg/132" width="30px"><span>奋斗的小白鼠</span> 👍（3） 💬（1）<div>老师，lock锁中的线程阻塞进行的上下文切换会设计系统内核态和用户态的转换吗？啥时候会引起系统内核态和用户态转换成啊？.io流编程中会出现吗</div>2019-11-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg" width="30px"><span>欧星星</span> 👍（3） 💬（1）<div>sync使用的是操作系统的Mutex Lock来实现的锁，Lock是使用线程等待来实现锁的，线程也会存在用户态内核态的切换，这样理解对吗？</div>2019-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg" width="30px"><span>又双叒叕是一年啊</span> 👍（2） 💬（1）<div>RRW 加写锁 和 读锁 都需要判断低16位？ 这块写锁是不是应该判读的是高16位有没有读锁，从而判断有没有冲突？</div>2019-11-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg" width="30px"><span>考休</span> 👍（1） 💬（1）<div>老师，公平锁因为要维持一个线程执行的顺序，是不是性能相对非公平锁弱一些？</div>2019-11-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（1） 💬（1）<div>课后思考及问题
1：公平锁和非公平锁具体指什么？怎么体现？

2：锁的状态可中断和不可中断具体是指什么意思？

晚上加班状态可能不太好，感觉老师主要讲解了几种同步锁的实现原理，以及特点，如果能列个二维表就更好啦!</div>2019-09-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（1） 💬（1）<div>我觉的票据本来就是读写锁升级版，性能绝逼是优于读写锁的。硬要说不如，不允许锁重入和阻塞时调用interrupt()有CPU彪高的bug算是存在的问题吧。前者，毕竟票据和读写都是用于读多写少的场景，所以互斥锁重入这块感觉量不大，没了倒也无伤大雅。而后者bug就是bug没得说。其实如果是写多读少的场景，隐式锁会比这些读写锁性能更好。重点还是根据具体的业务场景去选择。

</div>2019-06-18</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132" width="30px"><span>张学磊</span> 👍（1） 💬（1）<div>老师，tryOptimisticRead操作获取的不应该叫乐观读锁，应该是乐观读，是无锁的；StampedLock名字中没有Reentrant，所以不支持重入；StampedLock也不支持条件变量。</div>2019-06-18</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132" width="30px"><span>null</span> 👍（0） 💬（1）<div>老师，RRW 获取读锁流程图，对 state 低 16 位为 0 的判断，2个判断流程反了吧！高读低写，如果低 16 位为 0，说明高位不为 0，此时有读锁，需要判断读锁是否为当前线程持有。
能否更正一下流程图，谢谢！</div>2021-04-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（0） 💬（1）<div>老师在文章中说：如果多个线程仅仅是读取共享资源，那么这种情况下其实没有必要对资源进行加锁。可是获取读锁的流程图中，在获取读锁的时候，仍然需要竞争，竞争失败还会进行休眠，之后再竞争，这好像不符合上文说的“没必要对资源进行加锁&#39;这句话啊</div>2020-04-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" width="30px"><span>张三丰</span> 👍（0） 💬（1）<div>return Math.sqrt(currentX * currentX + currentY * currentY);
 如果执行到这个步骤的时候，写锁突然被其他线程获取到并且修改了X,Y，此时也无法校验了，算出的数还是错的，这个怎么办？</div>2020-04-10</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xibh27ZicBhXls5KsPibBXZI4RKlR0MUbUiaEuOS2ORibKaxWSicpIjd4lvWUWqtNAde7EeDDTpWKAiapGdHeaiaDqczWQ/132" width="30px"><span>。。。。。</span> 👍（0） 💬（1）<div>老师，请问一下，
问题一：那两个流程图，为什么同样是判断state低16位是否为0，为否时，一次是判断获取写锁的线程是否为当前线程，一次是判断获取读锁的线程是否为当前线程
问题二：当中间某一步就可以知道锁获取失败（比如获取读锁流程中，state低16位不为0，且获取写锁的不是当前线程），不是就直接可以放入队列了吗，为什么还要判断是否为公平锁</div>2020-01-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg" width="30px"><span>风轻扬</span> 👍（0） 💬（1）<div>老师，隐式锁只有synchronized这一种吗?</div>2019-08-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/1c/a2/2c3572de.jpg" width="30px"><span>辉</span> 👍（0） 💬（1）<div>一直不明白老师说的CAS是啥东东。具体描述下</div>2019-07-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg" width="30px"><span>嘉嘉☕</span> 👍（0） 💬（1）<div>老师好，请问
获取写锁的流程，文字描述和流程图，有个地方不太一样，判断“获取写锁的次数”还是“获取读锁的次数”？？
谢谢老师</div>2019-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" width="30px"><span>任鹏斌</span> 👍（0） 💬（1）<div>老师好，1. 读写锁 ReentrantReadWriteLock获取写锁的时候也需要等待读锁释放后才能真正获取到是吗？</div>2019-07-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/a7/49/9a2c8cfd.jpg" width="30px"><span>木木</span> 👍（0） 💬（1）<div>老师，读锁是一个共享锁，而写锁是一个独占锁，这个在文章中哪一部分有讲解呢？看了两遍不是很理解。</div>2019-07-03</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132" width="30px"><span>Geek_ebda96</span> 👍（0） 💬（1）<div>老师，RRW锁的读锁在获取锁的时候如果没有写锁，直接就可以获取到锁，只不过获取锁的过程中要用到CAS操作，相比于stampedlock，这个的乐观锁操作其实没用到任何锁操作，try的过程只是判断有没有写锁，没有则把共享变量的值拷贝到栈里面，后面的validate操作，也是再判断有没有写锁，没有则继续操作，这样理解对吗？那思考题里的问题，是因为乐观锁的过程除了try和validate操作判断有没有写锁，实际更新共享变量的值过程中没有cas和锁的操作，乐观锁的过程中其他线程还是可以获取到写锁，没法操作结果一定正确

最后还有一个问题这两种锁的读锁的cas操作只是在保证获取锁的过程和更新锁状态的过程吧，加锁的过程本身是要把内存中共享变量的值更新到栈中，共享变量本身不用volatie修饰？</div>2019-06-28</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132" width="30px"><span>Geek_ebda96</span> 👍（0） 💬（1）<div>老师好，请问一下为什么rrw获取锁的时候，state状态为0还是需要把当前线程先加入clh等待队列，不直接去cas更新状态获取锁，为了公平性吗，是根据参数设置的值判断的吗</div>2019-06-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f0/2e/b3c880b8.jpg" width="30px"><span>余冲</span> 👍（0） 💬（1）<div>老师，你那个rrw获取写锁时的图，第一个判断及其后面的判断，直线的逻辑，应该是:是。否才加入clh队列。</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/1e/9e/abb7bfe3.jpg" width="30px"><span>小布丁</span> 👍（0） 💬（1）<div>老师我有一个问题，RRW在没有写锁的情况下，可以并发读，既然可以并发读为什么还要获取锁呢？是不是意味着读锁是可以被很多线程同时拥有的？而写锁就是独占的？</div>2019-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg" width="30px"><span>小橙橙</span> 👍（0） 💬（2）<div>老师好！为什么读写锁判断state的地方要使用高低位这种设计呢，直接使用0、1、2这样的枚举判断理解上不是要更简单吗？</div>2019-06-22</li><br/>
</ul>