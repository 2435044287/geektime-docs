你好，我是刘超。

不知道你是否跟我有过同样的经历，那就是作为一个开发工程师，经常被DBA叫过去“批评”，而最常见的就是申请创建新的索引或发现慢SQL日志了。

记得之前有一次迭代一个业务模块的开发，涉及到了一个新的查询业务，需要根据商品类型、订单状态筛选出需要的订单，并以订单时间进行排序。由于sku的索引已经存在了，我在完成业务开发之后，提交了一个创建status的索引的需求，理由是SQL查询需要使用到这两个索引：

> select * from order where status =1 and sku=10001 order by create\_time asc

然而，DBA很快就将这个需求驳回了，并给出了重建一个sku、status以及create\_time组合索引的建议，查询顺序也改成了 sku=10001 and status=1。当时我是知道为什么要重建组合索引，但却无法理解为什么要添加create\_time这列进行组合。

从执行计划中，我们可以发现使用到了索引，那为什么DBA还要求将create\_time这一列加入到组合索引中呢？这个问题我们在[第33讲](https://time.geekbang.org/column/article/113440)中提到过，相信你也已经知道答案了。通过故事我们可以发现索引知识在平时开发时的重要性，然而它又很容易被我们忽略，所以今天我们就来详细聊一聊索引。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（79） 💬（6）<div>回答老师问题：
按照老师的操作了一遍，实验小部分区间是会走order_id索引的，但是查询范围继续增大 ，反而不走索引而是全表扫描，大概我估摸着的是小于全表5分之一区间能够走索引，超过5分之一会全表扫描，可以使用force index（索引名）强制使用该索引，这就是有些sql表开始跑的挺快的，后面越来越慢的原因吧。。但不清楚mysql优化器为啥要这样选择，希望老师解惑？</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/26/61e46afe.jpg" width="30px"><span>CCC</span> 👍（24） 💬（1）<div>对索引进行函数操作或者表达式计算也会导致索引的失效</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg" width="30px"><span>Loubobooo</span> 👍（17） 💬（3）<div>我的想法是，可以利用子查询去减少回表操作，既然有主键自增id，便可以利用聚簇索引的优势来强制走索引。代码方法如下：select * from order_detail where id in (select id from order_detail where order_id between 5000 and 10000)</div>2019-08-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" width="30px"><span>张三丰</span> 👍（13） 💬（2）<div>”如果不存在辅助索引，此时会通过查询聚簇索引来统计行数，如果此时正好存在一个辅助索引，则会通过查询辅助索引来统计行数，减少 I&#47;O 操作。“
这有什么区别吗？都是通过索引统计行数</div>2019-10-04</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132" width="30px"><span>张学磊</span> 👍（13） 💬（1）<div>由于是select *操作，所以每条记录都需进行回表，当server层分析器发现between的范围太大时，使用辅助索引存在大量回表操作，所以觉得得不偿失，故而直接使用主键索引。如果想使用我们期望的索引，需要给server层分析器一个hint，force index(idx_order_id)</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/62/49/6332c99b.jpg" width="30px"><span>man1s</span> 👍（7） 💬（1）<div>走主键索引，优化器认为5000数据+回表5000次性能消耗要大于全表扫描
force index </div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg" width="30px"><span>考休</span> 👍（6） 💬（2）<div>为什么innodb存储引擎没有支持哈希索引？</div>2020-03-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a2/7f/cf86eef9.jpg" width="30px"><span>某、 </span> 👍（5） 💬（2）<div>使用某个字段中字符串的前几个字符建立索引？这句不是很明白，能否细讲一下，能否以身份证这个字段作个栗子？
</div>2019-12-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/af/34/c7081824.jpg" width="30px"><span>Charles</span> 👍（5） 💬（3）<div>想问下老师为什么回表查询的速度会慢于直接用主键查询，因为回表也是使用主键ID去查询的，就算查询的数据量大，用不用子查询都是使用主键ID去回表或是查询，速度应该一样吧</div>2019-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/40/c3/e545ba80.jpg" width="30px"><span>张振宇</span> 👍（4） 💬（2）<div>老师，没明白开头那段，为什么要添加 create_time 这列进行组合索引啊</div>2020-03-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（4） 💬（1）<div>如果查询条件中使用 or，且 or 的前后条件中有一个列没有索引，那么涉及的索引都不会被使用到。想知道为什么涉及到的索引都不会被用到，原理是什么呢？</div>2020-01-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（2） 💬（1）<div>SELECT  COUNT(*) 时，如果不存在辅助索引，此时会通过查询聚簇索引来统计行数，如果此时正好存在一个辅助索引，则会通过查询辅助索引来统计行数，减少 I&#47;O 操作。 这里说的正好存在一个辅助索引，指的是where条件中正好存在辅助索引吗？</div>2020-01-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b2/af/81303f5a.jpg" width="30px"><span>行者</span> 👍（2） 💬（1）<div>索引失效一句话总结，字段a有索引，那么只能匹配字段a，除此之外均会导致索引失效，比如所有对字段a的函数计算（如reverse、crc32），类型转换（如bigint转vachar，也就是SQL中有没有单引号），前置模糊搜索（like &quot;%张三&quot;，因为后置模糊匹配可以使用前缀索引），where子句的多条件组合不当（需要根据情况的分析是否会用索引）</div>2020-01-03</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKdbP3ib8aoBDIbzaDXM9YzyowcJDTnCOLNJc3CP6dCYVmibHe7LMK37WXSicsFMicLuLBw/132" width="30px"><span>Geek__ad4af7fe01f4</span> 👍（2） 💬（1）<div>请问老师，既然使用辅助索引效率低，mysql默认超出20%又使用主键索引优化，而优化的效果又变低，为何还要强制使用辅助索引？

这里强制使用辅助索引的优化 和下面您的描述不是冲突吗？

因为order_id索引不能覆盖我们要查询的信息，所以在对order_id查询之后还需要一次回表来查找到整行数据，虽然order_id索引是顺序存放的，但是相对于主键id存放的数据顺序是不一致的，所以存在每次回表都是随机获取整行数据，如果在获取大量数据时，通过这种方式获取数据性能肯定是不理想</div>2019-08-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/1e/98/51a2bb5f.jpg" width="30px"><span>传传传传传传奇</span> 👍（1） 💬（1）<div>来晚了
有一事不明，通过创建覆盖索引（如文中将商品编码、名称、价格作为一个组合索引）在某些情况下可以避免回表。但是非主键索引存储的却是主键的值，并以此来作为指向行的指针。在查询商品编码的时候，怎么理解避免回表吗？</div>2019-11-05</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（1） 💬（2）<div> 老师，你这个表里的order id和id不是一起递增的么？如果orderid也是递增的，那情况又是怎呢</div>2019-09-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg" width="30px"><span>我行我素</span> 👍（1） 💬（1）<div>老师，想请问下InnoDB引擎下使用HASH索引也可以啊，但是文中的图InnoDB索引Hash是no</div>2019-08-13</li><br/><li><img src="" width="30px"><span>Geek_521fd2</span> 👍（0） 💬（1）<div>sql执行的时候如何选择表中索引，会自动合并多个吗？</div>2020-05-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（0） 💬（1）<div>在对“QQ怪”的回复中，老师说：在查询少量数据的情况下，使用辅助索引性能更加，而查询大量数据时，就未必了。为什么？</div>2020-01-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg" width="30px"><span>阿杜</span> 👍（0） 💬（2）<div>status这种字段也需要加入到联合索引中吗？比如查询status和code，是建status+code的联合索引好还是只建立code索引？</div>2019-12-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（0） 💬（1）<div>老师，请问存储引擎具体判断使用什么索引的原则是啥?大体的原则肯定是怎么快怎么走?不过也存在一定的误判，请问老师清楚误判的原因和具体都有那些场景嘛？</div>2019-09-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/43/3e/960d12cb.jpg" width="30px"><span>DY</span> 👍（0） 💬（2）<div>老师，你好。 select * from order_detail where id in (select id from order_detail where order_id between 5000 and 10000)； 这种优化方式我试了试， 没起到什么优化作用。问了下DBA，说都回表了， 先查询主键ID也回表， 感觉和自己理解的不一样，但是又没法反驳。看了下执行计划这条sql也确实回表了</div>2019-09-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg" width="30px"><span>密码123456</span> 👍（0） 💬（1）<div>我这一直用的都是oracle，看到mysql就想，快快跳过。后来发现，和数据库关系不大，很多都是通用的。</div>2019-08-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg" width="30px"><span>新世界</span> 👍（0） 💬（1）<div>查询用order_id索引，然后进行回表查询</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg" width="30px"><span>许童童</span> 👍（0） 💬（2）<div>请问该查询选择的索引是什么？有什么方式可以强制使用我们期望的索引呢？
会直接查询主键索引进行全表扫描，因为数据库优化器在判断SQL语句执行使用哪个索引时会计算代价，如果使用主订单 id 索引回表太多，代价太大，还不如用主键索引进行全表扫描。
我觉得SQL改为以下方式可以使用主订单 id 索引，并提高查询效率。
select * from order_detail where id in (select id from order_detail where order_id between 5000 and 10000)</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg" width="30px"><span>undifined</span> 👍（0） 💬（1）<div>可以用子查询实现，因为order_id 的索引中有主键id，先使用order_id 的索引查询到主键id，然后通过主键再从表里查询
SELECT *
FROM order_detail
WHERE id IN (SELECT id FROM order_detail WHERE order_id BETWEEN 5000 AND 10000);
</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（0） 💬（1）<div>索引失效:这个操作在索引树上满足不了需求。就会导致索引失效，b+树的特性就是有序(最左可以理解为高位有效)。
课后习题，感觉老师这么问肯定不会走主订单id的索引了，原因待老师解答。
如果有分布式id生成系统能保证生成的id有序递增的话。可以不用自增的id做主键，直接用生成的oreder_id做主键，可少一次回表。愚见期待老师的答案</div>2019-08-10</li><br/><li><img src="" width="30px"><span>Geek_xbye50</span> 👍（0） 💬（1）<div>看查询优化器计算出来的代价！不知道数据量小的时候会不会直接使用id索引这样相比order_id而言是少了回表的代价！正常情况应该还是使用主订单id的索引！最终还是需要结合执行计划看下是不是可以优化或者说指定需要查询出来的列而不是*。强制使用某个索引是force index吧</div>2019-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（3） 💬（1）<div>order 表中建立一个复合索引 idx_user_order_status(order_no, status, user_id)，使用 order_no+user_id 组合查询，只有order_no会用到索引，user_id并不会</div>2020-01-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/0a/75/24764b3f.jpg" width="30px"><span>哦</span> 👍（1） 💬（0）<div>老师，在测试使用 status、status+user_id 查询，仍然能够使用索引树，只不过type=index，是因为高版本mysql优化了吗</div>2021-01-08</li><br/>
</ul>