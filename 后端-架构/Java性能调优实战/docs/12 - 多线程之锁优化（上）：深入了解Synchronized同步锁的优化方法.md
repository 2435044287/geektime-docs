你好，我是刘超。从这讲开始，我们就正式进入到第三模块——多线程性能调优。

**在并发编程中，多个线程访问同一个共享资源时，我们必须考虑如何维护数据的原子性。**在JDK1.5之前，Java是依靠Synchronized关键字实现锁功能来做到这点的。Synchronized是JVM实现的一种内置锁，锁的获取和释放是由JVM隐式实现。

到了JDK1.5版本，并发包中新增了Lock接口来实现锁功能，它提供了与Synchronized关键字类似的同步功能，只是在使用时需要显式获取和释放锁。

Lock同步锁是基于Java实现的，而Synchronized是基于底层操作系统的Mutex Lock实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销。因此，在锁竞争激烈的情况下，Synchronized同步锁在性能上就表现得非常糟糕，它也常被大家称为重量级锁。

特别是在单个线程重复申请锁的情况下，JDK1.5版本的Synchronized锁性能要比Lock的性能差很多。例如，在Dubbo基于Netty实现的通信中，消费端向服务端通信之后，由于接收返回消息是异步，所以需要一个线程轮询监听返回信息。而在接收消息时，就需要用到锁来确保request session的原子性。如果我们这里使用Synchronized同步锁，那么每当同一个线程请求锁资源时，都会发生一次用户态和内核态的切换。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg" width="30px"><span>bro.</span> 👍（99） 💬（6）<div>Synchronized锁升级步骤

1. 偏向锁:JDK6中引入的一项锁优化,它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能 ,
2. 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁
3. 当锁对象第一次被线程获取的时候，线程使用CAS操作把这个锁的线程ID记录再对象Mark Word之中，同时置偏向标志位1。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。
4. 如果线程使用CAS操作时失败则表示该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁的所有权。当到达全局安全点（safepoint，这个时间点上没有正在执行的字节码）时获得偏向锁的线程被挂起，膨胀为轻量级锁（涉及Monitor Record，Lock Record相关操作，这里不展开），同时被撤销偏向锁的线程继续往下执行同步代码。
5. 当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束 
6. 线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录(Lock Record)的空间，并将对象头中的Mard Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果自旋失败则锁会膨胀成重量级锁。如果自旋成功则依然处于轻量级锁的状态
7. 轻量级锁的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中赋值的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了，如果替换失败，就说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程
8. 轻量级锁提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的（区别于偏向锁）。这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢
简单概括为:
1. 检测Mark Word里面是不是当前线程ID,如果是,表示当前线程处于偏向锁
2. 如果不是,则使用CAS将当前线程ID替换到Mark Word,如果成功则表示当前线程获得偏向锁,设置偏向标志位1
3. 如果失败,则说明发生了竞争,撤销偏向锁,升级为轻量级锁
4. 当前线程使用CAS将对象头的mark Word锁标记位替换为锁记录指针,如果成功,当前线程获得锁
5. 如果失败,表示其他线程竞争锁,当前线程尝试通过自旋获取锁 for(;;)
6. 如果自旋成功则依然处于轻量级状态
7. 如果自旋失败,升级为重量级锁
   - 索指针:在当前线程的栈帧中划出一块空间,作为该锁的锁记录,并且将锁对象的标记字段复制到改锁记录中!
</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b7/cb/18f12eae.jpg" width="30px"><span>不靠谱～</span> 👍（21） 💬（1）<div>1.课后作业：实际对象锁和类对象锁的区别，锁对象不一样。
2.  1.8后CurrentHashmap已经不用segment策略了，想请教一下老师1.8后是怎样保证性能的呢？
3.对锁升级不太了解的同学可以看一下《Java并发编程的艺术》。里面有很详细的介绍，不过也是比较难理解，多看几遍。</div>2019-06-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（15） 💬（1）<div>老师在其他的回复中提到：synchronized锁只会升级，不会降级。如果系统只在某段时间高并发，升级到了重量级锁，然后系统变成低并发了，那还是重量锁，那岂不是很影响性能。</div>2020-04-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg" width="30px"><span>承香墨影</span> 👍（15） 💬（2）<div>老师，对我 waitSet 的理解也有歧义。
按您的在留言中的说法以及本文的内容，那等于进入 waitSet 会有两种情况，竞争 Monitor 失败，以及调用了 wait() 方法。
那何时会唤醒呢？
竞争 Monitor 失败的线程会在之前线程退出 Monitor 的时候再去竞争 Monitor，但是因外 wait() 方法也会进入 waitSet 的线程，就需要等待有线程退出的时候调用 notify() 方法，这一部分的细节和数据转换是怎么一回事？如何保证两种情况进入 waitSet 的线程，都拥有再次竞争 Monitor 的权利？</div>2019-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg" width="30px"><span>苏志辉</span> 👍（14） 💬（7）<div>entrylist和waitset那个地方不太理解，monitorenter失败后会进入entrylist吧，只有调用wait方法才会进入waitset吧，还请老师指点下</div>2019-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/97/98/5ef15aa0.jpg" width="30px"><span>浩瀚有边</span> 👍（13） 💬（6）<div>老师，您好，synchronized锁只会升级，不会降级吧？如果系统只在某段时间高并发，升级到了重量级锁，然后系统变成低并发了，就一直是重量级锁了吗？请老师解惑，谢谢🙏</div>2019-07-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（11） 💬（1）<div>偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法。对此，有疑问，全局安全点指的是什么？什么情况下会出现暂停了该线程，该线程还在执行该方法？</div>2020-04-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" width="30px"><span>张三丰</span> 👍（7） 💬（1）<div>entryList有序吗？感觉这个结果多余，sync没有实现公平锁。</div>2020-04-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/3a/6d/8b417c84.jpg" width="30px"><span>Wheat Liu</span> 👍（6） 💬（1）<div>老师您好，想问一下，偏向锁的撤销为什么要在SafePoint暂停该线程呢，是因为要改变锁对象的头信息吗，那在线程运行时撤销偏向锁会出现什么问题呢</div>2020-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/b9/71/f6bf2b61.jpg" width="30px"><span>张海鹏</span> 👍（4） 💬（3）<div>老师，您文中提到的锁消除一块没有十分理解，意思是若只有一个线程正在使用同步块，synchronized关键字就不被编译，就不加锁，当有新的线程也调用这个代码块的时候再加锁，是这样么？另外这个“借助了一种被称为逃逸分析的技术”可以扩展讲解一下么？</div>2019-09-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg" width="30px"><span>晓杰</span> 👍（4） 💬（2）<div>感觉讲得有点晦涩啊，不知道其他人什么感觉</div>2019-06-16</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（3） 💬（1）<div>老师，sychronized底层实现是操作系统里的mutex lock，这个和反汇编后的monitorenter monitorexit指令有什么关系么</div>2020-03-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b6/b3/f626885f.jpg" width="30px"><span>Young</span> 👍（3） 💬（2）<div>请问老师，如果取消自旋，那轻量级锁和重量级锁还有什么区别吗</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" width="30px"><span>任鹏斌</span> 👍（3） 💬（1）<div>普通方法中锁的是当前对象，静态方法锁的是静态类</div>2019-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg" width="30px"><span>拉可里啦</span> 👍（3） 💬（3）<div>在使用偏向锁中，进行cas替换失败的原因是什么？我认为有两点：1.被替换的线程目前还在执行中 2.被替换的线程已执行完毕，但是有其它线程同时获取到了偏向锁。 不知我理解的是否合理，还请老师指点。</div>2019-06-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg" width="30px"><span>-W.LI-</span> 👍（3） 💬（1）<div>老师好!获取偏斜锁和轻量级锁的时候使用的CAS操作预期值传的是null(希望锁已释放)，替换后值是当前线程什么?</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg" width="30px"><span>纯风</span> 👍（2） 💬（2）<div>老师 cas操作是什么 不能理解</div>2020-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg" width="30px"><span>SDL</span> 👍（2） 💬（2）<div>默默问句怎么减少锁竞争呢？</div>2019-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg" width="30px"><span>Demon.Lee</span> 👍（2） 💬（1）<div>“JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。”
---------------
老师，这里的对象实例指的是共享资源吧，也就是那个被锁的对象，即文中代码synchronized (o) 中的o，那Monitor对象又是哪个？</div>2019-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/26/78/ed0252c2.jpg" width="30px"><span>ddddd🐳</span> 👍（1） 💬（2）<div>偏向锁真的没理解，cas更新线程ID什么情况下认为失败？</div>2019-08-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg" width="30px"><span>发条橙子 。</span> 👍（1） 💬（1）<div>老师， 前面的 Monitor 对象看懂了 ， 后面的锁优化也看懂了 ，但是我没有理解二者的联系。 再 1.6 后引入锁优化， 但是编译成字节码还是存在   monitorenter 和 monitorexit 。 那过程还是线程先去争取 Monitor 对象，和优化有什么关联么， 还是这个指令的含义变成了 锁优化的过程？？？？</div>2019-07-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg" width="30px"><span>拉可里啦</span> 👍（1） 💬（1）<div>老师你好，在偏向锁中，如果另一个线程通过cas获取到了偏向锁，那么之前获取到的偏向锁的线程还在执行中，是否被中断了，还是执行完</div>2019-06-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg" width="30px"><span>汤小高</span> 👍（1） 💬（1）<div>老师，请教一个问题：是不是多个线程执行同步代码时，这些线程一开始都是先进入entrylist，然后执行monitorenter指令向操作系统申请monitor对象，申请成功的获取代码执行权，申请失败的其他线程都进入waitset。如果已经申请到monitor的线程执行wait方法也会进入waitset。如果释放锁了就应该从entrylist移出，再次申请锁时也是先进入entrylist，执行monitorenter，申请失败进入waitset...</div>2019-06-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" width="30px"><span>峰</span> 👍（1） 💬（1）<div>普通方法是获取的是该对象的管程，静态方法获取的是该类对象的管程。
问题： 同步块中调用wait进入waitset，那么waitset和entryset不是都在等锁释放吗，为什么老师第一个图中有个waitset到entryset的箭头？ 难道对象在这个过程中会转移？</div>2019-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a0/9f/71345740.jpg" width="30px"><span>黑崽</span> 👍（1） 💬（1）<div>锁升级的图中显示markword是否存储线程ID的图中，两个路径是与不是，是不是画反了？是的话，要cas替换成自己。不是，那么就直接获取偏向锁</div>2019-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg" width="30px"><span>陆离</span> 👍（1） 💬（1）<div>用户态和内核态的切换，是不是也类似于一种中断？
由于需要保护现场，遂将该线程的相关信息入栈，等到再执行的时候出栈？
这个动作很消耗系统资源吗？</div>2019-06-15</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ONIogicHLw4qYdzjVlm5SS87r47Y0nKibEdIBqIVSed56mjSPhyy1bRTVHhxK9M18cTo5xeK03gg2tQr4iclmAicuw/132" width="30px"><span>HYS</span> 👍（0） 💬（1）<div>Synchronized 锁竞争 有了 _EntryList 集合存放竞争的线程，为什么还要有ContentionList 呢？分两个列表设计的意义是什么呢？</div>2020-05-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4c/89/e698c0a9.jpg" width="30px"><span>gerry pang</span> 👍（0） 💬（1）<div>老师，您画的mark word结构中的无锁、偏向锁和轻量级锁标志位有点问题，无锁和偏向锁应该是01吧。轻量级锁是00吧</div>2020-04-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg" width="30px"><span>慌张而黑糖</span> 👍（0） 💬（1）<div>对于图中先判断目前锁状态，偏向锁却在无锁状态的下面，是说偏向锁不算真正意义上的锁吗？</div>2020-04-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/ec/e8/41a9d0d8.jpg" width="30px"><span>蘭</span> 👍（0） 💬（1）<div>Synchronized 不是悲观锁吗，这么会有CAS操作</div>2020-03-27</li><br/>
</ul>