你好，我是刘超。

通过上一讲的讲解，相信你对上下文切换已经有了一定的了解了。如果是单个线程，在 CPU 调用之后，那么它基本上是不会被调度出去的。如果可运行的线程数远大于 CPU 数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其它线程能够使用 CPU ，这就会导致上下文切换。

还有，在多线程中如果使用了竞争锁，当线程由于等待竞争锁而被阻塞时，JVM 通常会将这个线程挂起，并允许它被交换出去。如果频繁地发生阻塞，CPU 密集型的程序就会发生更多的上下文切换。

那么问题来了，我们知道在某些场景下使用多线程是非常必要的，但多线程编程给系统带来了上下文切换，从而增加的性能开销也是实打实存在的。那么我们该如何优化多线程上下文切换呢？这就是我今天要和你分享的话题，我将重点介绍几种常见的优化方法。

## 竞争锁优化

大多数人在多线程编程中碰到性能问题，第一反应多是想到了锁。

多线程对锁资源的竞争会引起上下文切换，还有锁竞争导致的线程阻塞越多，上下文切换就越频繁，系统的性能开销也就越大。由此可见，在多线程编程中，锁其实不是性能开销的根源，竞争锁才是。

第11～13讲中我曾集中讲过锁优化，我们知道锁的优化归根结底就是减少竞争。这讲中我们就再来总结下锁优化的一些方式。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/b8/76/6f0c39c2.jpg" width="30px"><span>Geek_1f1a07</span> 👍（60） 💬（1）<div>Zed说的不对，首先，所有的锁，无论synchronize还是lock，如果发生竞争条件，都可能造成上下文切换，优化锁的目的是为了尽量降低发生锁竞争的概率，synchronize做的优化都是把竞争的可能消灭在前期的偏向锁，轻量级锁，把会造成上下文切换的“脏活”留在最后。lock的乐观锁大体思路也是一样的，不到万不得已，不会轻易调用park方法。但是本质上java目前都是利用内核线程，所以都会有上下文切换。除非使用协程的技术，这个以前有green thread，后来不用了，期待老师后面对协程的讲解。</div>2019-06-25</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132" width="30px"><span>尔东橙</span> 👍（19） 💬（1）<div>volitile的读写不会导致上下文切换，操作系统层面怎么理解呢</div>2019-09-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/14/b7/bb6a1fd4.jpg" width="30px"><span>Zed</span> 👍（17） 💬（1）<div>回答趙衍同学

如你所说，synchronized主要是因为有用户态和内核态的交互所以能到进程级别。

而Lock是通过AQS的state状态来判断是否持有锁，整个过程都是在用户态或者说纯java实现。

最后lock.await()也是把当前线程放到当前条件变量的等待队列中并让出cpu。顺便提下，lock支持多条件变量。</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" width="30px"><span>QQ怪</span> 👍（14） 💬（3）<div>我觉得有些人建议使用notifyall的原因是使用notify需要有十足的把握去确认哪条线程需要唤醒，因为一不留神就容易搞错，为了优化而优化最后事倍功半，所以大家才会使用notifyall一劳永逸，我其实挺认同老师的观点，老师，全部唤醒会导致更多的上下文切换，是否要优化这点，我觉得还是得看个人了吧😂</div>2019-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg" width="30px"><span>你好旅行者</span> 👍（11） 💬（2）<div>老师好！在synchronized中，“挂起”这个动作是由JVM来实现的，获取不到锁的线程会被迫让出CPU，由于synchronized是基于操作系统的mutex机制，所以会产生进程的上下文切换。我想请问老师，在JDK的Lock中，或者AQS中，线程“挂起”这个动作又是怎么实现的呢？为什么不会产生进程级别的上下文切换呢？</div>2019-06-25</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132" width="30px"><span>td901105</span> 👍（6） 💬（1）<div>老师,是不是使用Lock锁机制不会有用户态和内核态的切换?还是Lock本身锁机制是不涉及用户态到内核态的切换的,只是在未获取锁的时候需要使用内核态的方法比如park方法进行线程的挂起?</div>2019-12-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg" width="30px"><span>K</span> 👍（5） 💬（2）<div>老师好，我有个特别简单的小问题不太明白。既然用了vector，为什么还要用synchronize锁起来啊，vector本身不就是线程安全的？谢谢老师回答。</div>2019-07-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg" width="30px"><span>WL</span> 👍（5） 💬（1）<div>老师请问一下, JVM在操作系统层面是一个进程还是多个进程, 如果是一个进程的话, 那synchronize和park()方法发生的是进程级别的状态切换的话是指操作系统不运行JVM了吗?</div>2019-06-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a6/10/3ff2e1a5.jpg" width="30px"><span>皮皮</span> 👍（4） 💬（1）<div>老师您好，一直有个疑问想请教，就是JDK1.5引入的lock锁底层实现也是调用了lockhelper的park和unpark方法，这个是否也涉及到系统的上下文切换，用户态和内核态的切换？</div>2019-06-25</li><br/><li><img src="" width="30px"><span>奇奇</span> 👍（3） 💬（1）<div>代码写错了
while(pool.isEmpty())不能放在同步代码块的外面
假设此时pool不为空容量为1，此时10个线程的pool.isEmpty都为false，此时全部跳出循环。
全部执行pool.remove(0) 错误</div>2019-07-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg" width="30px"><span>梁中华</span> 👍（2） 💬（2）<div>原文：“而移动内存对象就意味着这些对象所在的内存地址会发生变化，因此在移动对象前需要暂停线程，在移动完成后需要再次唤醒该线程”。 这句话是不是不太严密？每次ygc都会导致年轻代内存地址变化，这也会导致暂停线程吗？如果是的话，那线程切换也太频繁了，似乎和事实不符啊。 </div>2019-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（1） 💬（1）<div>老师在回复中说：AQS挂起是通过LockSupport中的park进入阻塞状态，这个过程也是存在进程上下文切换的。但被阻塞的线程再次获取锁时，不会产生进程上下文切换。
为什么再次获取锁时，不会产生上下文切换，代码里可以看出来吗？
</div>2020-04-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b6/b3/f626885f.jpg" width="30px"><span>Young</span> 👍（1） 💬（1）<div>请问老师，线程wait区分是由于等待超时重新运行为什么不需要再去重新获取锁呢，我的理解是，wait后锁被释放了，那线程重新恢复运行后无论什么情况下都应该先去获取锁</div>2019-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（1） 💬（2）<div>这节很不错，不过疑问还是有的
感觉老师没有完全讲清楚进程的上下文切换和线程的上下文切换？另外，老师对于什么是进程？什么是线程？他们之间的区别与联系也是没有讲的比较细致？这两个概念非常重要，不过能通俗易懂的讲明白的不多。另外，不管进程还是线程我认为若想被CPU执行，少不了要进入内核态。进进出出比较费劲但又不得不进，那就减少进进出出的次数，少进为妙，少进的方法就是少触发那些进进出出的条件。比如：减少锁持有时间，减少锁粒度，少触发锁竞争，减少FULL GC，减少IO阻塞，创建合适的线程数等等。</div>2019-09-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg" width="30px"><span>undifined</span> 👍（1） 💬（1）<div>老师，在并发编程那个专栏第 6 讲中老师提到：notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程；即使使用 notifyAll()，也只有一个线程能够进入临界区；但是 notify() 的风险在于可能导致某些线程永远不会被通知到；所以除非有特殊考虑，否则尽量使用notifyAll() 

如果现在又考虑到锁，应该怎么做选择</div>2019-06-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（1） 💬（1）<div>g1并行垃圾回收。不一定会上下文切换吧。至于上下文切换这个，java还有信号量的实现。</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg" width="30px"><span>天天向上</span> 👍（0） 💬（1）<div>在多线程中如果使用了竞争锁，当线程由于等待竞争锁而被阻塞时，JVM 通常会将这个锁挂起，并允许它被交换出去。如果频繁地发生阻塞，CPU 密集型的程序就会发生更多的上下文切换。这个被交换出去是什么意思?</div>2020-04-23</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/15f3b4YrvPL8qaqoMbFzukJbYR5DNVS5HayqBWXZnicTTGhetlA6q1XycfzoXgQ2uO9tPIMDDE8lwiaYm01RBqSQ/132" width="30px"><span>vivi</span> 👍（0） 💬（1）<div>请问，那事物的开启和锁的持有时间该如何权衡？例如我方法里设计到三个不同表的插入更新操作，其中一个是库存表，是该把锁加在事物外面还是在事物中进行库存表的加锁操作</div>2019-09-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3f/ee/5ed997a6.jpg" width="30px"><span>devin.ou</span> 👍（0） 💬（1）<div>老师，能给出wait&#47;notify优发后的代码么</div>2019-07-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg" width="30px"><span>Demon.Lee</span> 👍（0） 💬（1）<div>1.  ‘’在 JDK1.6 中，JVM 将 Synchronized 同步锁分为了偏向锁、轻量级锁、偏向锁以及重量级锁，优化路径也是按照以上顺序进行。‘’
 这句话里面有两个偏向锁，后一个是不是“自旋锁”呀

2. 老师只说了减少垃圾回收频率可以减少上下文切换，没说如何减少回收频率。感觉不是个好问题，算了，我还是先去Google下找答案吧。</div>2019-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg" width="30px"><span>旭东(Frank)</span> 👍（0） 💬（1）<div>在 JDK1.6 中，JVM 将 Synchronized 同步锁分为了偏向锁、轻量级锁、偏向锁以及重量级锁，优化路径也是按照以上顺序进行。JIT 编译器在动态编译同步块的时候，也会通过锁消除、锁粗化的方式来优化该同步锁。

老师，这个只是JDK1.6的优化，还是1.6以后都是这么优化的？</div>2019-07-04</li><br/><li><img src="" width="30px"><span>奇奇</span> 👍（0） 💬（1）<div>不同时执行remive 但是也会进去执行remove(0)也是不符合语义的</div>2019-07-03</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWicx6gYmNqGYC8V9xo31w9hjsJrZB1fogG6ibBc0KObo2q3n1xndl6BcriahzHKnGvWy3sgCxVlH1w/132" width="30px"><span>CRann</span> 👍（0） 💬（1）<div>老师，请问一下如果有多个线程wait()的时候notify()怎么唤醒指定线程？</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/48/f3/65c7e3ef.jpg" width="30px"><span>cricket1981</span> 👍（0） 💬（2）<div>怎样监控上下文切换？为什么有的并发书建议用notifyAll而不是notify？</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg" width="30px"><span>WL</span> 👍（12） 💬（2）<div>老师请问一下在一段程序中除了工作线程之外还有很多守护线程, 这些线程加起来的数量必然比cup的数量会多很多, 那么为什么创建线程池的时候要参考CPU的数量呢, 为什么不把守护线程也考虑进去呢?</div>2019-06-25</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132" width="30px"><span>ヾ(◍°∇°◍)ﾉﾞ</span> 👍（3） 💬（0）<div>多个软件共同运行也有可能导致上下文切换，有些软件考虑使用绑定固定cpu核方式运行</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg" width="30px"><span>欧星星</span> 👍（1） 💬（0）<div>sync在使用重量级锁的时候会有上下文切换，lock由于内部是Java实现，锁的等待是基于park来的，所以在lock中只会有线程切换带来的CPU上下文切换，没有锁竞争的上下文切换，比sync少一次CPU上下文切换</div>2019-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg" width="30px"><span>杯莫停</span> 👍（0） 💬（0）<div>notify和notifyall各有各的好处，用notify有可能造成线程姬饥饿。</div>2022-07-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg" width="30px"><span>keep_it_real</span> 👍（0） 💬（0）<div>频繁IO就是诱因，频繁的数据库操作，各种拷贝，都是大量的上线文切换。</div>2022-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg" width="30px"><span>Bumblebee</span> 👍（0） 💬（2）<div>争议点

文中说到Object.notify() 替代Object.notifyAll()。 因为 Object.notify() 只会唤醒指定线程，不会过早地唤醒其它未满足需求的阻塞线程，所以可以减少相应的上下文切换。

但是，Object.notify() 是会随机地通知等待队列中的一个线程，而 Object.notifyAll() 会通知等待队列中的所有线程。从感觉上来讲，应该是 notify() 更好一些，因为即便通知所有线程，也只有一个线程能够进入临界区。但那所谓的感觉往往都蕴藏着风险，实际上使用 notify() 也很有风险，它的风险在于可能导致某些线程永远不会被通知到（此观点来源于极客时间另一个专栏）。

希望老师解惑</div>2022-05-14</li><br/>
</ul>