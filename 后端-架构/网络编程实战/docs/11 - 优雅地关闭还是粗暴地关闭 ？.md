你好，我是盛延敏，这里是网络编程实战第11讲，欢迎回来。

上一讲我们讲到了TCP的四次挥手，其中发起连接关闭的一方会有一段时间处于TIME\_WAIT状态。那么究竟如何来发起连接关闭呢？这一讲我们就来讨论一下。

我们知道，一个TCP连接需要经过三次握手进入数据传输阶段，最后来到连接关闭阶段。在最后的连接关闭阶段，我们需要重点关注的是“半连接”状态。

因为TCP是双向的，这里说的方向，指的是数据流的写入-读出的方向。

比如客户端到服务器端的方向，指的是客户端通过套接字接口，向服务器端发送TCP报文；而服务器端到客户端方向则是另一个传输方向。在绝大多数情况下，TCP连接都是先关闭一个方向，此时另外一个方向还是可以正常进行数据传输。

举个例子，客户端主动发起连接的中断，将自己到服务器端的数据流方向关闭，此时，客户端不再往服务器端写入数据，服务器端读完客户端数据后就不会再有新的报文到达。但这并不意味着，TCP连接已经完全关闭，很有可能的是，服务器端正在对客户端的最后报文进行处理，比如去访问数据库，存入一些数据；或者是计算出某个客户端需要的值，当完成这些操作之后，服务器端把结果通过套接字写给客户端，我们说这个套接字的状态此时是“半关闭”的。最后，服务器端才有条不紊地关闭剩下的半个连接，结束这一段TCP连接的使命。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg" width="30px"><span>卫江</span> 👍（129） 💬（7）<div>问题一，为什么调用exit以后不需要调用close，shutdown？因为在调用exit之后进程会退出，而进程相关的所有的资源，文件，内存，信号等内核分配的资源都会被释放，在linux中，一切皆文件，本身socket就是一种文件类型，内核会为每一个打开的文件创建file结构并维护指向改结构的引用计数，每一个进程结构中都会维护本进程打开的文件数组，数组下标就是fd，内容就指向上面的file结构，close本身就可以用来操作所有的文件，做的事就是，删除本进程打开的文件数组中指定的fd项，并把指向的file结构中的引用计数减一，等引用计数为0的时候，就会调用内部包含的文件操作close，针对于socket，它内部的实现应该就是调用shutdown，只是参数是关闭读写端，从而比较粗暴的关闭连接。
第二个问题，信号的处理有三种，默认处理，忽略处理，自定义处理。默认处理就是采用系统自定义的操作，大部分信号的默认处理都是杀死进程，忽略处理就是当做什么都没有发生。</div>2019-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/f0/ca/4560f06b.jpg" width="30px"><span>zhchnchn</span> 👍（33） 💬（2）<div>请问老师一个问题，像FIN，ACK等报文并不属于“数据”是么？比如对于4次挥手中，发起关闭的客户端在发送FIN报文后，表明客户端不再发送“数据”了（可以读数据），之后在服务端也发送FIN报文后，客户端还是会发送一个ACK报文给服务端。这里的最后一个ACK报文，并不属于“数据”是吗？T或者CP中这些所有的控制报文包都不属于所谓的“数据”吗？</div>2019-09-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/f1/02/96082034.jpg" width="30px"><span>Guchen</span> 👍（20） 💬（4）<div>老师我这个理解有问题么？
客户端调用close并发送了FIN包，服务端接收到FIN包会将连接状态设置为对端已关闭写端，服务端在向客户端回送FIN包之前可以向对端发送数据也不可不发送，实例程序就是发送了数据，第一次发送数据对端会返回个RST包（因为客户端close已经关闭了读端），服务端调用read会返回-1，设置errno，此时服务端了解到客户端也不会再读数据了，如果服务端还是强行再次向客户端发送数据包，调用write后，协议栈会发现用户进程向一个没有读用户的管道做写操作，那么会触发SIGPIPE信号执行默认操作关闭用户进程。</div>2020-10-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg" width="30px"><span>skye</span> 👍（12） 💬（1）<div>那请问老师,什么情况下用close，什么情况下用shutdown？谢谢！</div>2019-12-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg" width="30px"><span>W.jyao</span> 👍（9） 💬（3）<div>SUG_IGN是忽略信号吧，老师是不是代码有问题啊，SIG_DFL才是默认处理，示例中那样写不是应该是忽略了SIGPIPE信号么。</div>2019-08-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg" width="30px"><span>传说中的成大大</span> 👍（8） 💬（1）<div>然后又引申了fin包和read返回0是怎样的关系呢？</div>2019-08-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg" width="30px"><span>忆水寒</span> 👍（7） 💬（1）<div>close关闭比较粗暴，如果想要优雅的关闭，等处理完数据再关闭可以使用shutdown设置参数。
实际上在tcp协议中有个参数so_linger也可以设置比较优雅（规定时间处理缓冲区的字节，超时则清空缓冲区）的关闭tcp的socket。</div>2020-03-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg" width="30px"><span>传说中的成大大</span> 👍（4） 💬（2）<div>今天我也写了代码测试上面的例子同时也想起了网上一句话 close是关闭掉socket 并且回收了socket相关资源,而shutdown一般只是关闭连接并不会关闭socket 这也是为啥调用close服务器端在进行写数据的时候会触发sigpipe信号,而shutdown却不会触发,那么调用shutdown关闭的套接字怎么回收呢？是由内核回收还是？ 服务器端和客户端又是怎样回收的呢？</div>2019-08-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg" width="30px"><span>W.jyao</span> 👍（4） 💬（1）<div>老师，调用shutdown不会释放套接字资源，那么应该怎么处理呢</div>2019-08-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/d4/39/a980c04d.jpg" width="30px"><span>Sun</span> 👍（3） 💬（2）<div>close 关闭两个方向的数据流时。输入方向，系统内核会将该套接字设置为不可读，任何读操作都会返回异常。在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，那对端已经不可读了，这些数据该如何处理？</div>2020-04-25</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132" width="30px"><span>雷刚</span> 👍（2） 💬（1）<div>老师在文中提到的一个问题：close 函数只是把套接字引用计数减 1，未必会立即关闭连接。有可能进程 A 在关闭 socket，而进程 B 却仍然在进行 socket I&#47;O 操作，如何才能保证一旦调用 socket.close 方法，所有的进程（线程）都不能进行 I&#47;O 操作呢？

Java nio 对 close 进行了优化，采用经典的 two-step 处理方案，即 dup close 来关闭连接。比如 Java GC 中的标记清除算法，CHL 无锁队列中的标记删除算法，都是这种思想：先标记元素不可能用，再进行删除。dup close 方案同样如此，具体参考：&lt;https:&#47;&#47;www.oschina.net&#47;question&#47;138146_26027&gt;。

1. socket 在初始化时就会生成一个半关闭的连接，这个半关闭的 socket 连接相当于一个清除标记。
2. 当调用 close 时，先会调用 nd.preClose() 方法将原先的 socket 替换为这个已经半关闭的连接。这样其它进程在进行 socket I&#47;O 操作时就会报错（EOF 或者 Pipe Error），read 或 write 方法里会检测这些状态做相应处理。
3. 当所有的进程都调用 close 后，就没有进行再使用这个 socket，最后一个使用的线程调用 nd.close() 真正关闭 socket。</div>2020-04-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7a/fe/abb7bfe3.jpg" width="30px"><span>胡波 allenhu</span> 👍（2） 💬（2）<div>老师你好, 上面的例子中有两个地方不是很清楚:
(1) close: client调用close后, 不是会马上关闭两个方向的连接吗, 那为啥&quot;Hi, data1&quot;还能被收到并显示?
(2) shutdown: client调用shutdown只是关闭写方向的连接, 是不是client不能发了只能收?那为啥server能读到EOF并发送&quot;FIN&quot;给client?</div>2019-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/57/bd/acf40fa0.jpg" width="30px"><span>lwenbin</span> 👍（1） 💬（1）<div>这里服务器signal 里 SIG_PIPE 应该是 SIG_DFL, github 里是对的，不然会 ignore，然后print &quot;error write&quot;.
对于close的情况下，server 发送第一个write 是可以的，不会返回-1，应该成功写入了缓冲区。但是感觉发送后client会通知server协议栈RST。第二次server再 write 的时候就收到了 SIGPIPE 了。
这里不管 close 还是 shutdown, client 都会发送 FIN 到客户端，在 shutdown 情况下 server 还是能够 read 和 write，只有 read 完缓冲区后才会收到 0，这时候 server 才会去exit&#47;close&#47;shutdown。
所以感觉对于server 收到 FIN 后，write 除非收到了 RST然后 SIG_PIPE，不然还是可以写。当然如果server read 到了 EOF，应该关闭当前socket。
</div>2021-10-15</li><br/><li><img src="" width="30px"><span>晚风·和煦</span> 👍（1） 💬（2）<div>close那里的输入和输出方向没太理解😂</div>2020-04-03</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7cOHiaxJBPvdic53UfP4VC2P4EsyYOGNEwhgYsrP4kw7MFhI7fKQ0GnIiadIHUEYVD85AkrcGv5DLg/132" width="30px"><span>burner</span> 👍（1） 💬（2）<div>关于文中EOF的含义不是特别理解，意思是说表示发送数据结束标记？
最近看请求公司内部服务的日志，发现客户端会由于收到EOF而请求服务失败，但是不是经常出现，也不是在业务高峰期出现，咨询下老师，这种情况意味着什么？</div>2020-03-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/41/af/4307867a.jpg" width="30px"><span>JJj</span> 👍（1） 💬（1）<div>第一个差别：close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源。--------------------请问下，shutdown两个方向也不会释放套接字资源吗？那什么时候释放的</div>2020-01-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/dc/a6/6c2728b9.jpg" width="30px"><span>乔克叔叔</span> 👍（0） 💬（1）<div>老师 有个疑惑 调用close是粗暴关闭连接 是不走四次挥手的意思？</div>2022-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/6b/fd/14e1f6bb.jpg" width="30px"><span>大乌贼 (\(●-●)/)</span> 👍（0） 💬（1）<div>为啥第二个例子在shutdown之后还能打印出服务端返回的数据？不是shutdown后会关闭读，把对端发过来的数据回复个ack，然后默默丢弃么？</div>2022-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/28/03/9c/5a0b8825.jpg" width="30px"><span>Bin Watson</span> 👍（0） 💬（1）<div>老师，如果client的shutdown是shut_rd格式，那么会发送一个fin给服务器吗？如果不会，那么正常情况下，服务器不会主动发送FIN包吧？</div>2022-01-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/ea/43/f831afcc.jpg" width="30px"><span>Frank</span> 👍（0） 💬（1）<div>输入分向和输出方向怎么理解，为什么输入对应的是读操作而不是写操作</div>2022-01-01</li><br/><li><img src="" width="30px"><span>Geek_648160</span> 👍（0） 💬（1）<div>老师 压测过程中jmeter报java.net.SocketException: Socket is closed，有啥解决思路吗？</div>2021-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/a4/9d/95900f70.jpg" width="30px"><span>T------T</span> 👍（0） 💬（1）<div>老师好，有一些疑问。
客户端调用了shutdown 对应于4次挥手 客户端发出了FIN吧。
然后服务端再调用shutdown 就对英语4次挥手，服务端发出了FIN？</div>2021-11-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/62/78/6e7642a3.jpg" width="30px"><span>王蓬勃</span> 👍（0） 💬（1）<div>FD_ZERO(&amp;allreads);    
FD_SET(0, &amp;allreads); 

这两个操作有什么区别？</div>2021-10-28</li><br/><li><img src="" width="30px"><span>Geek_e43e33</span> 👍（0） 💬（1）<div>老师您好，对于优雅&#47;粗暴的关闭有一些疑问：
1. 首先调用close()完成关闭双方连接一定会导致粗暴的关闭吗？因为客户端调用close()之后接收到的服务器数据不会接收，这种情况是粗暴的关闭。但如果客户端调用close()后服务器并不向客户端传数据而是直接发送ACK+FIN报文客户端是否会接收？即是否属于优雅的关闭？
2. 粗暴的关闭：使用shutdown()将选项设置为SHUT_RDWR是否会导致粗暴的关闭？
</div>2021-10-23</li><br/><li><img src="" width="30px"><span>Geek_e43e33</span> 👍（0） 💬（1）<div>老师您好，请问使用close()一定会导致连接被粗暴的关闭吗？因为一端直接关闭后就不再接收数据了，对之后的数据直接发RST。另外shutdown采用同时关闭读端和写端的选项时应该也是粗暴的关闭吧。</div>2021-10-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/57/bd/acf40fa0.jpg" width="30px"><span>lwenbin</span> 👍（0） 💬（1）<div>老师，在 shutdown 情景下服务器是通过read 返回 EOF 然后 error(1, 0, &quot;client closed \n&quot;); 间接 exit 吧，这时候 shell 里error code 是1，不是0.
sig_int function 不会被调用吧？
</div>2021-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2a/64/0a/74cb1c66.jpg" width="30px"><span>李恒</span> 👍（0） 💬（1）<div>在收到客户端的FIN包时，服务端会自己自动向对方发送一个FIN吗？还是说服务端只会在调用close或shutdown时才会发送FIN包？</div>2021-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/5d/51/87fc7ef9.jpg" width="30px"><span>Issac慜</span> 👍（0） 💬（1）<div>调用exit退出程序时，操作系统会自动释放套接字等占用的资源</div>2021-09-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/6b/a7/0ef65704.jpg" width="30px"><span>即墨</span> 👍（0） 💬（1）<div>所以为了保证FIN报文被发出，一般先shutdown再close，是这样吗</div>2021-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/37/4b/e0b13df2.jpg" width="30px"><span>随先生</span> 👍（0） 💬（2）<div>老师，请问close为什么会导致客户端回应服务器RST呢？服务器发来信息客户端读，照文章前面说的如果关闭读，则服务器发来的数据会被直接丢弃并返回ACK，没有说到会产生RST，是符合之前文章说的RST产生的三个条件中的哪个条件呢？</div>2021-01-13</li><br/>
</ul>