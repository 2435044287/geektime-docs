你好，我是海纳。

在[第3节课](https://time.geekbang.org/column/article/431904)，我们讲到线性地址空间按照功能的不同，可以分为不同的区域。同时，我们还简单介绍了，如何使用sbrk和mmap这两个系统调用，向操作系统申请堆内存。

其实，堆内存是程序员打交道最多的一块区域，无论是哪种编程语言，正确合理并高效地使用堆内存，都是极具挑战的一件事情。对程序调优是系统程序员常见的工作任务，而堆内存的管理和分配恰恰是最容易出现性能瓶颈的模块。

不过，sbrk和mmap这两个系统调用分配内存效率比较低，我们在[第5节课](https://time.geekbang.org/column/article/435493)讲过，进程的内核态和用户态的区别，执行系统调用是要进入内核态的，运行态的切换会耗费不少时间。为了解决这个问题，人们倾向于使用系统调用来分配大块内存，然后再把这块内存分割成更小的块，以方便程序员使用，这样可以提升分配的效率。

在C语言的运行时库里，这个工作是由malloc函数负责的。但有时候C语言的原生malloc实现还是不能满足特定应用的性能要求，这就需要程序员来实现符合自己应用要求的内存池，以便自己进行内存的分配和释放。

这节课，我们就一起来学习，如何对通过系统调用申请来的大块内存进行更精细化的管理。通过这节课的学习，你将了解到堆内存管理的常用方法，以及内存泄露、double free等常见的内存问题产生的原因和排查方法，从而提高自己分析和解决内存问题的能力。
<div><strong>精选留言（13）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/14/99/f2/c74d24d7.jpg" width="30px"><span>大豆</span> 👍（13） 💬（1）<div>老师，我有个疑问，通过mmap分配的内存是在进程的映射区还是堆中，还是都有？</div>2021-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg" width="30px"><span>qinsi</span> 👍（8） 💬（1）<div>看完感觉自己可以实现个valgrind了，不过又觉得少了亿点点细节。于是查了下valgrind的实现，发现只有用到了preload这点是一样的。剩下的部分valgrind相当于实现了一个虚拟机，将机器指令转成虚拟机IR，插桩，再通过JIT生成机器指令执行。这样看来Java字节码增强就是个弟弟阿…

另外llvm因为本身就有IR，所以就可以直接在IR上做，据说asan就是这么实现的。</div>2021-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg" width="30px"><span>LDxy</span> 👍（2） 💬（2）<div>老师，为什么很多用C语言做开发的人都说glibc里面的内存分配malloc的性能不行，所以要自己实现一个动态内存管理机制。可我也没看出glibc里面的malloc有啥大问题，自己去重新实现一套内存管理，真的能比标准库的性能提升吗？而且究竟该怎么测试动态内存管理机制的性能，似乎也无从下手。而且，好像就只有C程序员在意动态内存分配的性能问题，其他语言比如C++，Java的程序员就不怎么关心动态内存分配的性能问题。</div>2021-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg" width="30px"><span>慢动作</span> 👍（2） 💬（1）<div>error里也有地址，这额外日志没有给出额外的信息？</div>2021-11-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg" width="30px"><span>郑童文</span> 👍（1） 💬（1）<div>请问老师malloc函数用mmap向系统申请一大块内存的时候，这一大块内存就已经映射到物理内存了吗？ 还是在malloc从这一大块内存中分配一小块内存给进程时，才会把这一小块内存映射到物理内存？ </div>2021-12-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/3b/2a/f05e546a.jpg" width="30px"><span>🐮</span> 👍（1） 💬（2）<div>老师，你好，请教个问题，之前函数重载这块使用比较多的是通过编译器wrap方式重载，但这块只能对可执行文件进行重载，不能实现glibc重载，这里所说的LD_PRELOAD是不是也只是针对可执行文件进行重载不能实现像动态库重载，如果是某个glibc中的函数使用malloc，这种方案是不是不能进行重载的；</div>2021-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg" width="30px"><span>流浪地球</span> 👍（0） 💬（4）<div>请问老师，tcmalloc的线程本地缓存会不会导致相同的一份代码产生的进程，分配的虚拟内存空间会大一些呢？看描述像是增加预分配了一些空间</div>2021-11-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg" width="30px"><span>骨汤鸡蛋面</span> 👍（1） 💬（1）<div>void* p1 = malloc(16);
free(p1)
free的时候，根据参数知道从地址p1开始free，那如何知道free 16个字节呢？</div>2022-07-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/ce/87/41c44923.jpg" width="30px"><span>会爆炸的小米Note</span> 👍（1） 💬（0）<div>老师好！mmap是相当于只修改了页表项，把相应页面的页表项修改成已分配未缓存的状态，然后在访问的时候通过缺页中断加载到物理内存中吗？
第一节课中吊打面试官的部分中说通过mmap构建映射后通过遍历访问才能让内存commit
请教下老师有什么高效的方法来进行访问吗 </div>2022-03-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3e/3c/fc3ad983.jpg" width="30px"><span>佳伦</span> 👍（1） 💬（0）<div>malloc通过mmap从操作系统申请一块比较大的内存再精细化管理，但是mmap申请到的内存对于操作系统来说，也需要伙伴算法来管理。所以，内存管理经历了好几个层面，操作系统层面、用户层面，在硬件层可能还有类似的管理方法。所以套了这么多层效率肯定会受影响</div>2022-03-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/7a/20/081982a7.jpg" width="30px"><span>五岛晚邮。</span> 👍（0） 💬（0）<div>在实现malloc的dlsym的时候需要注意两点：1. 不能使用printf作为日志输出的函数，需要使用fprintf(stderr,xxx)。这是因为printf内部也调用了malloc，会实现递归造成stackoverflow。2.对于定位到某个具体的函数时，可以使用gcc内建函数__builtin_return_address（level），确认哪里调用了malloc</div>2023-12-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2a/1a/3b/363561e5.jpg" width="30px"><span>gover</span> 👍（0） 💬（0）<div>包装malloc和free函数，在malloc记录增加分配的内存，在free的时候记录减少分配的内存
最后剩下的大于0的部分就是</div>2023-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg" width="30px"><span>罗杰</span> 👍（0） 💬（0）<div>两个问题，一是我按照上面的代码来跑测试，未按预期运行，打印了一堆 ready to do free: (nil)，然后 Segmentation fault 了（复制老师提供的代码，运行结果是一致的）；二是提供的代码仓库中没有这份代码。</div>2022-03-18</li><br/>
</ul>