你好，我是海纳。

今天是我们的第1节课，我想用一个比较有趣的、很多人都遇到过的问题作为我们这门课的开场，带你正式迈入计算机内存的学习课堂。

我不知道在你刚接触计算机的时候，有没有这么一个疑问：“为什么我的机器上只有两个G的物理内存，但我却可以使用比这大得多的内存，比如256T？”

反正我当时还是挺疑惑的，不过现在我可以来告诉你这个答案了。这个问题背后的机制是十分复杂的，但它的核心是计算机中物理内存和虚拟内存的关系，尤其是虚拟内存的运行原理。只要你搞懂了它们，这个问题也就迎刃而解了。

不止如此，虚拟内存的运行原理还是打开计算机底层知识大门的钥匙，只有掌握好它，我们才能继续学习更多的底层原理。我们整个课程的目的，就是让你在遇到进程崩溃、内存访问错误、SIGSEGV、double free、内存泄漏等与内存相关的错误时，可以有的放矢，把握分析问题的方向。而今天的第一课就是把打开这扇门的钥匙交到你手上。

在回答虚拟内存的相关问题之前，我们需要先看看物理内存的含义。

## 物理内存

计算机的物理内存，简单说就是那根内存条，你的内存条是1G的，那计算机可用的物理内存就是1G。这个内存条加电以后就可以存储数据了，CPU运算的数据都是存储在主存里的。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/11/3b/84/abb7bfe3.jpg" width="30px"><span>niucheng</span> 👍（25） 💬（2）<div>后面的面试题目中，服务程序内部使用的数据存储格式，尽可能使用数组类型、或者压缩列表这类内存紧凑的数据结构，因为数组对CPU告诉缓存支持更友好，缓存命中率会更高，这样会提高数据访问速度？如果使用链式或者树形的数据结构来存储数据，会不会更容易触发缺页中断？</div>2021-11-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg" width="30px"><span>郑童文</span> 👍（24） 💬（5）<div>请问老师，每个进程的页表是保存在操作系统所占的内存地址空间还是该进程自己的地址空间？进程切换将对页表产生什么影响？关于每个进程的堆和栈的起始和终止地址又是保存在哪儿的呢？ 谢谢！</div>2021-10-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/29/79/54/42528d8c.jpg" width="30px"><span>压根就是咯</span> 👍（20） 💬（2）<div>为什么虚拟内存远超物理内存，却能正常映射存储，没太看懂？</div>2021-11-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/ef/94/968c937f.jpg" width="30px"><span>MetMan</span> 👍（11） 💬（1）<div>海老师，请教既然有虚拟内存机制，为何程序仍然可能出现out of memory运行错误，是因为物理内存不够了，但能利用局部性原理在物理内存中只放入一定数据不超出限制吗</div>2021-10-26</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132" width="30px"><span>dog_brother</span> 👍（9） 💬（1）<div>老师好，每个进程都有页目录表和页表，每个 CPU 都有一个页目录基址寄存器。我的问题是，页目录基址寄存器可以保存多少个页目录基址呀？</div>2021-12-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" width="30px"><span>Linuxer</span> 👍（6） 💬（2）<div>有两个问题请教:
1. 不同进程页表起始地址存哪呢？
2. 一个物理页面分配给了一个进程，另一个进程怎么掌握这个信息呢？</div>2021-11-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/f0/19/9d754804.jpg" width="30px"><span>牧野</span> 👍（6） 💬（2）<div>&lt;无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的&gt;   这句话没看懂,进程程序本身不就在内存中吗</div>2021-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（5） 💬（2）<div>虚拟地址空间往往与机器字宽有关系
-----------------
为什么要有这一层关系呢？</div>2021-10-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg" width="30px"><span>D</span> 👍（4） 💬（4）<div>“CPU 运算的数据都是存储在主存里的。”， 这句话不是太准确啊，CPU 不是直接从主存拿数据啊，中间还有寄存器，高速缓存啊。</div>2021-10-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/92/58/b4f6365d.jpg" width="30px"><span>小北</span> 👍（4） 💬（2）<div>语速稍微快了点</div>2021-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg" width="30px"><span>小苗晓雪</span> 👍（3） 💬（2）<div>1.请问老师是如何从空间局部性与时间局部性得到 &quot;无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的&quot; 这个结论的啊?  
是不是任意时刻体现了时间局部性 , 那凭什么说某个进程访问一段内存 那么他附近的位置也很可能即将被访问就可以得到这个进程所需的物理内存很少这个结论啊?
难道说一段内存 0x100到0x200 这段内存能反复被一个进程访问啊? 一个进程 所需 4 个 G 那难道这 4 个 G 能反复映射到 0x100 到 0x200 这段位置啊? 
我有点不太理解 , 比如我运行某个代码编辑器 , 这个 编辑器 占用了 16 个 G 的内存 , 难道我电脑内存只有 8 个 G 也能让它跑起来么? 如果真是能跑起来是不是就说这个内存的某些区段是反复被我的这个编辑器使用的? </div>2021-11-09</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eorbckvhLliahdDbuorLB5E1NhQddskOybChBic2Kf9FmF3Vr0aQnrmCT2JwVADWY3iapkRbXDmKI6gQ/132" width="30px"><span>Geek_fd760d</span> 👍（3） 💬（1）<div>如果一个程序在运行中因为调用一个函数需要分配很大的虚拟内存，函数运行结束后，这些分配的虚拟内存也会回收吗？什么时候回收？</div>2021-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/3c/92/81fa306d.jpg" width="30px"><span>张Dave</span> 👍（2） 💬（3）<div>一个 32 位的虚拟地址可以拆成 10 位，10 位和 12 位三段。
那64位系统的4级分段，这个位数是怎么分配的呢？</div>2021-11-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg" width="30px"><span>流浪地球</span> 👍（2） 💬（1）<div>请问老师每个进程可以使用的虚拟内存空间是128T还是256T呢？课程中一开始讲是128t，后面讲64位寻址空间是256t，有点迷惑</div>2021-10-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/a3/61/5fbfe632.jpg" width="30px"><span>Zombie</span> 👍（1） 💬（2）<div>完了 听不大懂   需要先去看点什么 再来看这个课程</div>2021-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/b8/ae/085484e7.jpg" width="30px"><span>Insomnia</span> 👍（0） 💬（1）<div>老师，val a=f(x), val b=f(a) 和 val b=f(f(x)) ，在操作系统层面，后面链式调用的函数中的中间结果a会被写入主存么？</div>2021-12-19</li><br/><li><img src="" width="30px"><span>稽山的柚子</span> 👍（0） 💬（1）<div>老师  还有一个问题请教，虚拟内存有未映射页面的概念，那未映射的页面内的数据存放在哪里呢？</div>2021-12-15</li><br/><li><img src="" width="30px"><span>稽山的柚子</span> 👍（0） 💬（2）<div>页表的本质是页表项 (Page Table Entry, PTE) 的数组，虚拟空间中的每一个页在页表中都有一个 PTE 与之对应

请问老师，&quot;虚拟空间中的每一个页&quot; 这里的页是指什么页呢？</div>2021-12-14</li><br/><li><img src="" width="30px"><span>Geek_091ae4</span> 👍（0） 💬（1）<div>请问老师，每个进程的页表不一致，是由内核保证的吗，它们如何做到不同进程间的页表不一致呢？</div>2021-12-10</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132" width="30px"><span>ZR2021</span> 👍（0） 💬（4）<div>老师，那个换入换出的前提是得开swap分区的吧，但是swap分区开的一般比较少吧，就怕有内存泄漏问题;还有，不同进程的虚拟地址范围都一样，所以不同进程的页表实际上只有那个cr3的页目录基址不一样吧？</div>2021-12-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2b/b1/62/c00ccbb5.jpg" width="30px"><span>侠客行</span> 👍（0） 💬（1）<div>请问老师，我们的进程是如何提交给操作系统让它进行映射的呢？谢谢老师！</div>2021-12-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/e0/e2/6054de3f.jpg" width="30px"><span>*回眸*·wdlcoke</span> 👍（0） 💬（1）<div> 我是小白：请问老师这种说法对？
     电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张</div>2021-11-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9e/50/21e0beca.jpg" width="30px"><span>kylin</span> 👍（0） 💬（2）<div>感谢海纳老师的分享，刚刚在分析CPU如何利用MMU根据页表通过虚拟内存计算物理内存的过程中，有一个疑惑，就是如果两个进程的虚拟内存地址一样，那不就映射到相同的物理内存了吗？后面看了评论才清楚原来每个进程都会在自己的内存空间维护一个多级页表，不同进程的页表是独立且不同的。那请问海纳老师，进程是怎样在建立页表的时候保证独立于其它进程的页表呢？</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg" width="30px"><span>我是内存</span> 👍（0） 💬（4）<div>假如进程 A 一开始将虚拟内存的 0 至 4K，映射到物理内存的 0 至 4K 空间。基于局部性原理，4K 以后的虚拟地址大概率是不会被访问的，我们可以让程序一直运行。直到程序开始访问 4K ~ 8K 之间的虚拟地址了，我们就可以将现在的物理地址里的内容换出到磁盘的 swap 区域，然后再将虚拟内存的 4K ~ 8K 这一个区域映射到 0~4K 的这一块物理内存。
------请问一下，这里在第一次使用虚拟地址0-4k时，它映射的是4k-8k的物理地址空间。然后访问虚拟地址空间4k-8k的地址时，怎么还是访问被映射到0-4k的物理呢？不是应该改成其他的物理地址范围吗？这样是不是有两个不同的虚拟地址映射到了同一块物理地址范围里面了呢？</div>2021-11-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg" width="30px"><span>小苗晓雪</span> 👍（0） 💬（2）<div>请问老师，64位操作系统指向内存的只有48位，另外16位指向了其他什么位置或者操作去了？！</div>2021-11-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/66/e9/814d057a.jpg" width="30px"><span>小陈</span> 👍（0） 💬（2）<div>老师，一个页表项对应着一个大小为 4K 的页，所以 1024 个页表项所能支持的空间就是 4M。这种最好有个单位，不然看起来就是一个数量</div>2021-10-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" width="30px"><span>李</span> 👍（0） 💬（1）<div>页表的数据是不是还是要存在物理内存里？</div>2021-10-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/83/dd/86468048.jpg" width="30px"><span>九夏对三冬</span> 👍（0） 💬（2）<div>上面图片：128B&#47;TS是啥啊</div>2021-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/26/dd/d58156b1.jpg" width="30px"><span>一粒</span> 👍（11） 💬（1）<div>&#47;proc&#47;{pid}&#47;maps文件各字段含义：地址范围、访问权限、文件等中的偏移量、设备、inode、支持映射的文件路径名；
&#47;proc&#47;{pid}&#47;smaps文件记录的是内存映射的详细信息：第一行同maps文件，其余行表示：内存大小、Rss、Pss、Shared_Clean、Shared_Dirty、Private_Clean、Private_Dirty、Referenced、Anonymous、AnonHugePages、ShmemHugePages、ShmemPmdMapped、Swap、KernelPageSize、MMUPageSize、Locked、ProtectionKey、VmFlags等。</div>2021-10-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/b8/ae/085484e7.jpg" width="30px"><span>Insomnia</span> 👍（3） 💬（1）<div>老师，请教一个问题，kafka 中使用顺序写，这样消费者在读的时候充分利用了PageCache红利以提高机械盘的读写能力。
我在看它写文件的源码时，它使用了Java 的filechannel的write 底层使用了OS 的pwrite来写，但我不理解的是数据落到pagecache后，是由OS来控制落盘的，怎么能确保在磁盘上是一定落在连续的扇区的呢？如果不连续，那么读的时候不还是会发生缺页中断么？</div>2022-01-25</li><br/>
</ul>