你好，我是海纳。

上一节课，我们了解到函数在执行的时候，就会在栈上创建栈帧，那么函数执行的上下文都将保存在栈帧里。今天，我们就再来进一步分析，栈切换在计算机系统设计中所发挥的重要作用。

几乎所有的程序员都会遇到并发程序。因为多进程或者多线程程序可以并发执行，充分利用多CPU多核的计算资源来完成任务，会大大提升应用程序的性能。

所以，我相信你在工作中也遇到过多线程程序，但不知道你是否考虑过进程和线程是如何切换的呢？很多文章都介绍了，操作系统为了避免频繁进入内核态，会把很多工作都尽量放在用户态。那么你有没有仔细思考过内核态、用户态到底意味着什么呢？

要回答上面的问题，我们就要理解这些概念背后最重要的一个步骤：对执行单元的上下文环境进行切换。它就是由栈这个核心数据结构支撑的，这也是我们今天学习的重点内容。

通过今天的学习，你将掌握协程的基本知识，这样，你在C++中使用各种协程库，或者在Lua、Go等语言中使用原生协程的时候，就能理解它们背后发生了什么，也可以帮你写出正确的IO程序。你还将深入理解操作系统用户态和内核态，这样，你在做架构的时候，就能正确评估操作系统进入内核态的开销是多少。

在讲解执行单元的切换与栈的关系之前，我们先来给出它的准确定义。
<div><strong>精选留言（26）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg" width="30px"><span>linker</span> 👍（12） 💬（1）<div>思考题：线程的用户栈是pthread函数提前创建的吗？</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg" width="30px"><span>pedro</span> 👍（10） 💬（1）<div>fork 系统调用，只会新建一个子进程调用栈，并向其拷贝父进程调用栈数据，所以父子进程保存了同样的寄存器数据，因此造成了 fork 调用一次，而返回两次的现象。

由于 fork 本质会将父进程拷贝一份，作为子进程，这样就会有大量的拷贝工作，fork 会很慢，同时子进程可能不需要这么多的资源，会造成资源浪费，因此主流操作系统，比如 linux 都实现 COW 机制，即写时复制，fork 时对栈以外的资源都先映射到地址空间中，文件、socket 等句柄资源引用计数+1，待子进程访问这些地址时会触发缺页中断，此时内核再来为其分配真正的物理页，这样就节省了时间和空间。</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg" width="30px"><span>鵼</span> 👍（8） 💬（3）<div>补充一下：关于coroutine,在优化O1下，因为没有基地址的入栈出栈操作，所以 代码只用删除coroutine下的基地值入栈操作：stack_pointer -= 1; *stack_pointer = (long) base; 就可以了</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg" width="30px"><span>姑射仙人</span> 👍（4） 💬（1）<div>进程有两种栈，用户态栈和内核态栈。之前以为一直有一个内核进程在运行，发起系统调用相当于用户进程和内核进程在通信。是不是可以这样理解，进程执行的代码是包含内核代码和用户代码，当执行内核代码时需要进入内核态，当执行用户代码时在用户态。所以各进程的虚拟内存中就包含两部分，内核空间和用户空间，分别存放内核代码和用户代码。感觉理解的很零碎，老师帮看看哪块理解的不对。</div>2021-11-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg" width="30px"><span>陈狄</span> 👍（3） 💬（1）<div>mov    %rdi,-0x8(%rbp)
mov    %rsi,-0x10(%rbp)
mov    -0x10(%rbp),%rax
mov    (%rax),%rax
mov    -0x8(%rbp),%rdx
mov    %rsp,(%rdx)
请问老师，这段汇编，明明rdi和rsi可以直接拿来用，为什么要先存到栈里面，然后再从栈里面取出来访问，要绕一道？</div>2021-11-23</li><br/><li><img src="" width="30px"><span>Geek_27eb54</span> 👍（3） 💬（1）<div>海纳，老师，根据之前学的物理地址和虚拟地址，共享内存实际上可不可以理解成虚拟地址到物理地址的转换规则是一致的，私有地址中转换规则不一致？那么在一个进程中的多个线程中的私有内存，会不会有相同的地址呢？或者说我这样理解有问题呢？希望老师可以解答一下</div>2021-11-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg" width="30px"><span>流浪地球</span> 👍（2） 💬（1）<div>用户态的协程栈是分配在堆空间的吗？看代码是使用了malloc函数。协程的stackful和非stackful是什么却区别呢？</div>2021-11-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg" width="30px"><span>鵼</span> 👍（2） 💬（2）<div>对于学java的我看懂这段c++代码真不容易啊，好歹看懂了 。最难懂的应该是 协程a了，一开始一直觉得参数NULL，那个stack_pointer就是个null，后来查查资料，指针变量在声明的时候已经分配内存地址了，所以a的stack_pointer就是内存中的一块地址，只是它指向 的是NULL，本身还是一个内存地址。它的作用其实就是为了保存mian函数的rsp，所以才不用赋值（或者说给指定的地址）。
关于思考题：我觉得应该类似于进程那种按需写时复制。原因我认为的比较浅显，也比较尴尬，因为fork和pthread_create都是调用的clone（😅😅），其次线程的资源都是 共享的父亲 ，页表、虚拟地址 、文件描述符啥的应该都是同一个。不对 ，pthread_create的时候是有 参数的，fork没有。那应该是类似协程那种提前创建好的方式，用于保存参数数据。</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/94/6d/5cd6e8c7.jpg" width="30px"><span>张贺</span> 👍（1） 💬（1）<div>每个线程都可以分配一个内核栈吗？</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/94/6d/5cd6e8c7.jpg" width="30px"><span>张贺</span> 👍（1） 💬（1）<div>用户态内核态切换的时候，线程切换了吗？</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/2a/58/fabdfe69.jpg" width="30px"><span>Jerry_Yuan</span> 👍（0） 💬（2）<div>请问老师一下，在最后讲用户态内核态切换的时候，内核为了切换进程，保存用户进程的寄存器现场以及pc寄存器值，然后执行调度相关的系统调用。是不是可以理解成 每一个用户进程都有一个kernel stack（内核地址空间栈的一部分），存放用户进程的寄存器上下文以及返回地址。等到系统调用结束之后，再将之前保存到内核栈上的用户进程的状态通过mov指令重新放到寄存器上？</div>2021-12-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg" width="30px"><span>余生</span> 👍（0） 💬（1）<div>老师，这里提到的TSS，跟linux里面的pt_reg那个结构体是同一个东西吗？</div>2021-11-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg" width="30px"><span>姑射仙人</span> 👍（0） 💬（1）<div>之前听说goroutine既实现了协程，也对用户态的IO进行了完整的实现，其他语言的协程实现都是缺失的，说明了golang的强大。老师后面会讲这块IO这块吗？</div>2021-11-13</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eorbckvhLliahdDbuorLB5E1NhQddskOybChBic2Kf9FmF3Vr0aQnrmCT2JwVADWY3iapkRbXDmKI6gQ/132" width="30px"><span>Geek_fd760d</span> 👍（0） 💬（1）<div>对于协程的案例中，如果start_b函数中并没有切换回协程a的代码，那么这个函数执行完后还能进入主函数吗？具体会发生什么？</div>2021-11-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/c2/19/16863a09.jpg" width="30px"><span>独孤</span> 👍（0） 💬（1）<div>下面这段代码中co-&gt;stack_pointer的值为什么会存到寄存器%rax中？这是约定的吗？
void yield_to(coroutine* old_co, coroutine* co) 
{    __asm__ (        &quot;movq %%rsp, %0\n\t&quot;        
                           &quot;movq %%rax, %%rsp\n\t&quot;       
                            :&quot;=m&quot;(old_co-&gt;stack_pointer):&quot;a&quot;(co-&gt;stack_pointer):);
}</div>2021-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg" width="30px"><span>费城的二鹏</span> 👍（0） 💬（1）<div>“其实，这段程序最难理解的是第 6 行，为什么一次 fork 后，会有两种不同的返回值？这是因为 fork 方法本质上在系统里创建了两个栈，这两个栈一个是父进程的，一个是子进程的。”

fork 后，父进程与子进程会有单独的栈与公用栈，我想了解下这个地方的数据结构是怎样的？栈空间一般是连续的，如果有公用部分的栈，那部分栈在内存中如何存储？如何能同时在父子进程延伸出独立的栈？如何实现写时复制？</div>2021-11-03</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/4C2AgnHBt1qmRSiaqPQfEPicCdEJp6IgLC1wsVJPa1zQoRztNaZcqiaRXIblkRc1sgn7dUdPmrE011uFbibEQtia3bg/132" width="30px"><span>石天兰爱学习</span> 👍（4） 💬（0）<div>老师的文章又干又硬，啃的我牙疼&#47;(ㄒoㄒ)&#47;~~</div>2022-01-17</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132" width="30px"><span>Geek_a5edac</span> 👍（3） 💬（0）<div>作为后端开发，日常工作更多偏向设计模式、领域模型、上层架构的设计。但也一直对底层原理感兴趣，我认为在“设计”上很多思想是想通的，互相借鉴并融会贯通方可游刃有余，本章节深入了底层细节我总算是啃透了，现在如果让我讲一下进程、线程、协程的调度过程，脑子里已经能自行构建出对应的核心流程来了，感谢老师。</div>2022-07-24</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoumSwq5zGN1j0oB2WFIqlumZTmBH1yu18MvtZnXHDW2eo19f1ylhmsSgGyxicDratO0TuL42lsUnA/132" width="30px"><span>HowardLee</span> 👍（0） 💬（0）<div>中断发生时，CPU 根据需要跳转的特权级，去一个特定的结构中（不同的 CPU 会有所不同，比如 i386 就存在 TSS 中，但不管是什么 CPU，一定会有一个类似的结构），取得目标特权级所对应的 stack 段选择子和栈顶指针，并分别送入 ss 寄存器和 rsp 寄存器
----这个时候rsp已经换成内核栈指针了，那后面再去中断服务程序中保存用户态上下文的话，又怎么获取到用户态ss3和rsp3的值呢？</div>2025-02-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg" width="30px"><span>Geek_zbvt62</span> 👍（0） 💬（0）<div>coroutine的例子看得很吃力，但弄懂后发现实际上原理挺简单的，作者应该先介绍一下大致的思路做铺垫，不要想当然大家都能看懂</div>2023-08-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/49/68/bef5f7d3.jpg" width="30px"><span>metalmac.kyle</span> 👍（0） 💬（0）<div>这节课需要反复咀嚼理解啊，几节课啃下来结合CSAPP（深入理解计算机系统）这本书有种豁然开朗的感觉，特别是映射到汇编那一级 继续啃</div>2023-03-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/2a/1a/3b/363561e5.jpg" width="30px"><span>gover</span> 👍（0） 💬（1）<div>协程会用到多核吗</div>2023-03-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/9f/60/2a571b12.jpg" width="30px"><span>流光</span> 👍（0） 💬（0）<div>一直都没搞明白，栈的基地址是由ss 和sp 共同决定，这里为啥只改变sp的值，就能指向正确的地址？</div>2022-12-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/8d/d2/498cd2d1.jpg" width="30px"><span>程序员班吉</span> 👍（0） 💬（1）<div>golang的内存管理很大程度上依赖堆，但是为了利用CPU的多核特性要将协程调度到不同的核上，这里我一直有几个疑问。
1.golang是单进程的吗？因为不同的协程可以访问同一块堆上的内存。
2.如果是单进程的，那么如何能让golang发挥cpu多核的优势呢？难道同一个进程里的不同线程M可以被调度到不同的CPU核心上吗？
</div>2022-06-19</li><br/><li><img src="" width="30px"><span>Geek_d797a2</span> 👍（0） 💬（2）<div>老师好，想问下 yield to 方法的汇编码中，为什么最后恢复栈的语句中好象缺少了 mov %rbp, %rsp，函数调用的最后三行汇编不是都有这句吗？</div>2021-12-06</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132" width="30px"><span>Geek_a5edac</span> 👍（0） 💬（2）<div>老师，文中 co_a = new coroutine(NULL); 这段代码没看懂，我看入参是Null，按构造函数的写法：
if (entry == NULL) { stack = NULL; stack_pointer = NULL; return; } 所以我看co_a并没有初始化栈空间啊，那后面co_a的栈怎么能存储rsp相关的上下文信息的</div>2021-11-29</li><br/>
</ul>