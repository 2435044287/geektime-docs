上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。

今天，我们按照上节课给出的灰度组件的设计思路，讲解如何进行编码实现。不过今天对实现的讲解，跟前面两个实战项目有所不同。在前面两个项目中，我都是手把手地从最基础的MVP代码讲起，然后讲解如何review代码发现问题、重构代码解决问题，最终得到一份还算高质量的代码。考虑到已经有前面两个项目的学习和锻炼了，你应该对开发套路、思考路径很熟悉了，所以，今天我们换个讲法，就不从最基础的讲起了，而是重点讲解实现思路。

话不多说，让我们正式开始今天的学习吧！

## 灰度组件功能需求整理

针对上两节课给出的开发需求和设计思路，我们还是按照老套路，从中剥离出V1版本要实现的内容。为了方便我讲解和你查看，我把灰度组件的开发需求和设计思路，重新整理罗列了一下，放到了这里。

### 1.灰度规则的格式和存储方式

我们希望支持不同格式（JSON、YAML、XML等）、不同存储方式（本地配置文件、Redis、Zookeeper、或者自研配置中心等）的灰度规则配置方式。实际上，这一点跟之前的限流框架中限流规则的格式和存储方式完全一致，代码实现也是相同的，所以在接下来的讲解中，就不重复啰嗦了，你可以回过头去看下[第92讲](https://time.geekbang.org/column/article/243961)。
<div><strong>精选留言（28）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/1d/35/60/d3e723a7.jpg" width="30px"><span>Jagger</span> 👍（14） 💬（1）<div>DarkLaunch 构造器包含定时轮询，会不会影响单元测试？</div>2020-08-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/12/3b/969eedf2.jpg" width="30px"><span>robincoin</span> 👍（8） 💬（2）<div>mq和数据库灰度是不是要对mq和数据库再封装一层，方便aop处理？</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg" width="30px"><span>汝林外史</span> 👍（1） 💬（2）<div>好像dark方法中没有对区间的规则进行处理</div>2020-07-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg" width="30px"><span>小晏子</span> 👍（46） 💬（1）<div>这个DarkFeature类中灰度规则的解析代码不优雅的地方在于不够灵活，如果有新的灰度规则要加入，就需要再添加if else作处理，破坏了开闭原则，为了解决这一问题，可以使用工厂模式➕策略模式来保证开闭原则和消除if&#47;else，使用工厂模式来实现针对每个灰度规则的处理，使用“查表法”的策略模式来消除if&#47;else！</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/98/d7/7f7a0e6f.jpg" width="30px"><span>Lee</span> 👍（19） 💬（1）<div>可以使用解释器模式，将不同类型的规则解析拆分到不同的类中。</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg" width="30px"><span>tingye</span> 👍（16） 💬（0）<div>可以考虑用职责链模式，将不同规则字符串的解析抽象为单独的handle类，依次解析直到完成处理，也方便扩展对新规则编写语法的解析</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg" width="30px"><span>Heaven</span> 👍（7） 💬（0）<div>在此类场景下,我们可以简单的使用工厂类去封装规则的解析,
但是我个人觉着,应该以配置文件中配置的规则为主,所以,第二版需要在配置文件中写上实现接口的全限定类名,反射获取实例,同样支持更新,这样配置文件的Map就可以移除了,而且可以将简单的原生三种解析规则也抽象为接口,利用策略类进行区分调用
</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg" width="30px"><span>强哥</span> 👍（5） 💬（0）<div>这个灰度组件感觉适用简单场景，规则之间的表达式、优先级等组合方式不支持，规则的定义很重要。热更新可以通过zk下放到服务器上，通过sdk将配置信息加载到内存中。</div>2020-06-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（5） 💬（0）<div>1.定时任务在方法内部创建和使用，这样就没办法手动调定时任务的退出方法了。

2.感觉业务接口的路由规则的选型和路由规则的具体实现应该分离。DarkFear里面应该只要表明，哪个业务接口用哪个灰度规则，这个意图就好。至于灰度规则的具体实现，包括dsl的解析和灰度规则的执行都应该剥离出来单独封装。</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg" width="30px"><span>gogo</span> 👍（5） 💬（0）<div>可以考虑引入策略模式和工厂模式，消除if else</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg" width="30px"><span>djfhchdh</span> 👍（3） 💬（0）<div>DarkFeature类扩展性、灵活性都较弱，如果feature配置新增了字段，那么就要修改类内部的解析代码，不满足开闭原则。可以把parse函数单独拿出来，抽象成一个Parser接口，针对不同的feature配置格式，实现不同的parser。这样的话，对于配置格式的改动，只要修改或扩展相应的parser类就行了，不用改动DarkFeature类的代码，达到了对于修改的隔离。</div>2020-09-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg" width="30px"><span>罗 乾 林</span> 👍（2） 💬（0）<div> “DarkFeature 类中，灰度规则的解析代码“，是我能想到最直接简单的方式。我想可以抽象出规则解析类，对规则的解析交个解析类处理，将解析类对象注入到DarkFeature 类中。这样DarkFeature职责更单一</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg" width="30px"><span>test</span> 👍（2） 💬（0）<div>parsedarkrule的代码可以单独出来</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/83/37/7e18b532.jpg" width="30px"><span>果果果</span> 👍（1） 💬（0）<div>感谢王争老师，看完这本书后的最大收获是，自己动手完成了一个功能更为丰富的灰度组件，支持动态数据源、以及数据源的扩展、支持规则执行结果跟踪。
github地址
https:&#47;&#47;github.com&#47;TangGuoGuoR&#47;ab-gray</div>2021-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg" width="30px"><span>Yeyw</span> 👍（1） 💬（0）<div>规则扩展复杂的话可以用解释器，但是加载配置的话 我觉得定时会重复加载，定时加载加个判断吧，也可以暴露重新加载配置的方法，供开发提供自己自主刷新的接口</div>2021-05-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg" width="30px"><span>Leaf</span> 👍（1） 💬（0）<div>如果要集成到 spring 框架中，有些地方的设计和实现是否需要调整？比如：
1. ruleUpdateInterval 是要放到配置中，这样便于依赖注入？
2. loadRules 是否使用 spring 的 configuration 来替代？
3. addProgrammedDarkFeature 是否需要做成配置的方式？
</div>2021-01-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg" width="30px"><span>忆水寒</span> 👍（1） 💬（0）<div>震撼，其实思考方式就是最大的收获，这是作者多年的经验。</div>2020-09-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg" width="30px"><span>Tobias</span> 👍（1） 💬（0）<div>问：在 DarkFeature 类中，灰度规则的解析代码设计的不够优雅，你觉得问题在哪里呢？又该如何重构呢？
答：首先，parseDarkRule方法可读性和可测试性不好：方法代码偏多，if-else比较多。其次，可扩展性不好，如果将来又新增一种规则格式，需要在parseDarkRule插入代码解析规则，违背开闭原则。
解决方法：将parseDarkRule规则解析继续拆分成更小的类，每个类对不同的规则定义进行解析(e.g. 范围规则，百分比规则 etc.) 。相信解析器模式可以很好的解决这个问题。</div>2020-08-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg" width="30px"><span>公号-技术夜未眠</span> 👍（1） 💬（0）<div>利用spi机制+热加载实现编程规则会更加优雅写</div>2020-07-04</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/TEzJ59GslVXQeZqwFgGhABF7K8bFFlud2pcsEPvEyruP7NGQTuh38IbiajdVYUSViaDJrIkJVnv3vdjPA9YENp5w/132" width="30px"><span>leezer</span> 👍（1） 💬（0）<div>解析规则可以参考之前，使用工厂模式回去解析器，通过对应的解析器进行解析对应的配置文件.</div>2020-06-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/7c/63/115a4b23.jpg" width="30px"><span>静海</span> 👍（0） 💬（0）<div>前端灰度发布呢</div>2023-05-28</li><br/><li><img src="" width="30px"><span>Geek_7e0e83</span> 👍（0） 💬（0）<div>问题在于 和解析的逻辑 硬编码了 如果发生变动 或者解析的逻辑过于复杂都可能导致darkFeature的逻辑 变得臃肿。可以使用解释器模式来重构代码

实现可以参考这个 欢迎学习和交流
https:&#47;&#47;github.com&#47;yukunqi&#47;designPattern&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;darklunch
</div>2022-12-29</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Ff70ZuQbiaP0aUkNPasRkHfyIEyGLsMBd1EYQgQYZRoH85c4SsibWHJgA3u0X4Z8QyxHs17ausF2V4oN9hdYyfRg/132" width="30px"><span>郑卫林</span> 👍（0） 💬（0）<div>打开完成！
</div>2022-09-21</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132" width="30px"><span>idiot</span> 👍（0） 💬（0）<div>darkrule和darkfeature的包含关系不明显，要仔细看注释或者说明才知道。第一个改darkrules，或者第二个改darkruleoffeature？</div>2021-12-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg" width="30px"><span>Z宇锤锤</span> 👍（0） 💬（0）<div>可以抽象出一个解析接口，解析实现类，外部依赖注入到dark future。</div>2021-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg" width="30px"><span>makermade</span> 👍（0） 💬（0）<div>有GitHub仓库链接吗</div>2021-10-06</li><br/><li><img src="" width="30px"><span>Geek_3b1096</span> 👍（0） 💬（0）<div>舍不得结束</div>2020-08-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/af/ce/d7ae8da9.jpg" width="30px"><span>学渣！！！</span> 👍（0） 💬（0）<div>更新的查询的并发冲突问题是指的什么呢？新建一个对象赋值就可以解决</div>2020-07-05</li><br/>
</ul>