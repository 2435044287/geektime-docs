关于SOLID原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面几节课中，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：

- “依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？
- 我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？
- 如果你熟悉Java语言，那Spring框架中的IOC跟这些概念又有什么关系呢？

看了刚刚这些问题，你是不是有点懵？别担心，今天我会带你将这些问题彻底搞个清楚。之后再有人问你，你就能轻松应对。话不多说，现在就让我们带着这些问题，正式开始今天的学习吧！

## 控制反转（IOC）

在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是Inversion Of Control，缩写为IOC。此处我要强调一下，如果你是Java工程师的话，暂时别把这个“IOC”跟Spring框架的IOC联系在一起。关于Spring的IOC，我们待会儿还会讲到。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/14/7a/0c/5abd1cf9.jpg" width="30px"><span>thomas</span> 👍（29） 💬（3）<div>DIP原则有点嘎然而止的感觉，缺少了一个具体的例子。</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/be/c8/7c5f324f.jpg" width="30px"><span>港岛妹夫</span> 👍（2） 💬（1）<div>想知道争哥的英文原文都是从哪里读来的. 如果是书的话, 可以推荐一些嘛~</div>2020-06-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg" width="30px"><span>沉淀的梦想</span> 👍（2） 💬（1）<div>SOLID 的最后一个原则D，我看好多书上说是 迪米特法则 啊，为什么文章里没有提呢？</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg" width="30px"><span>JRich</span> 👍（1） 💬（1）<div>控制反转定义里是程序执行流程的控制权反转，而依赖注入讲的是对象的创建由外部创建好通过构造方法或setter方法注入进来，感觉两个讲的不是一个意思，虽然依赖注入也有控制反转的意思，但是对象的创建和获取的权利被反转，更确切的理解应该是2个场景吧。</div>2020-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg" width="30px"><span>JRich</span> 👍（1） 💬（1）<div>基于接口而非实现编程使用了依赖注入编程技巧。因为基于接口而非实现编程使用了面向对象的多态特性来提高代码扩展性，必然不可能在类内部创建对象，只能从外部注入。区别就是依赖注入不仅可以使用接口，还可以使用类。</div>2020-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg" width="30px"><span>程晓擘</span> 👍（1） 💬（1）<div>高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。  不太明白，为什么叫依赖倒置呀？倒置啥呢？ 我可能会取名，依赖抽象原则，哈哈。</div>2020-01-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/29/d2/475ee8e7.jpg" width="30px"><span>青子</span> 👍（1） 💬（3）<div>JunitApplication.register(new UserServiceTest();
在控制反转中执行这句话会执行该类中的final修饰的main方法吗</div>2020-01-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg" width="30px"><span>|･ω･｀)</span> 👍（1） 💬（1）<div>关于最后一个依赖反转能再举个简单的代码例子吗？Tomcat的案例没懂˙Ⱉ˙ฅ</div>2019-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg" width="30px"><span>堵车</span> 👍（1） 💬（1）<div>老师，今天怎么没更新，我已经迫不及待了。隔壁那本DDD好多词汇难理解，我受了打击，过来找安慰。</div>2019-12-17</li><br/><li><img src="" width="30px"><span>开心小毛</span> 👍（0） 💬（3）<div>底层模块依赖上层模块的抽象是否提倡？</div>2020-01-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg" width="30px"><span>小晏子</span> 👍（391） 💬（9）<div>课后思考：
“基于接口而非实现编程”与“依赖注入”的联系是二者都是从外部传入依赖对象而不是在内部去new一个出来。
区别是“基于接口而非实现编程”强调的是“接口”，强调依赖的对象是接口，而不是具体的实现类；而“依赖注入”不强调这个，类或接口都可以，只要是从外部传入不是在内部new出来都可以称为依赖注入。</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg" width="30px"><span>下雨天</span> 👍（151） 💬（1）<div>区别:
1.依赖注入是一种具体编程技巧，关注的是对象创建和类之间关系，目的提高了代码的扩展性，我们可以灵活地替换依赖的类。
2.基于接口而非实现编程是一种设计原则，关注抽象和实现，上下游调用稳定性，目的是降低耦合性，提高扩展性。

联系:
都是基于开闭原则思路，提高代码扩展性！</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" width="30px"><span>Smallfly</span> 👍（115） 💬（11）<div>依赖倒置原则概念是高层次模块不依赖于低层次模块。看似在要求高层次模块，实际上是在规范低层次模块的设计。

低层次模块提供的接口要足够的抽象、通用，在设计时需要考虑高层次模块的使用种类和场景。

明明是高层次模块要使用低层次模块，对低层次模块有依赖性。现在反而低层次模块需要根据高层次模块来设计，出现了「倒置」的显现。

这样设计好处有两点：

1. 低层次模块更加通用，适用性更广
2. 高层次模块没有依赖低层次模块的具体实现，方便低层次模块的替换

思考题：

基于接口而非实现编程，是一种指导编码的思想。依赖注入是它的一种具体应用。

个人理解，仅供参考~</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg" width="30px"><span>辣么大</span> 👍（44） 💬（3）<div>1⃣️控制反转是一种编程思想，把控制权交给第三方。依赖注入是实现控制反转最典型的方法。
2⃣️依赖注入（对象）的方式要采用“基于接口而非实现编程”的原则，说白了就是依赖倒转。
3⃣️低层的实现要符合里氏替换原则。子类的可替换性，使得父类模块或依赖于抽象的高层模块无需修改，实现程序的可扩展性。</div>2019-12-16</li><br/><li><img src="" width="30px"><span>Maurice</span> 👍（35） 💬（2）<div>“相对于细节的多变性,抽象的东西要稳定的多”，个人认为吃透这句话就够了。</div>2020-01-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg" width="30px"><span>javaadu</span> 👍（28） 💬（2）<div>课堂讨论：这两个概念没什么关系，讲的不是一个事。依赖注入讲的是一个对象如何获得它运行所依赖的对象，所谓依赖注入就是不需要自己去new，让框架注入进来；基于接口而不是实现编程讲的是抽象思维的应用，利用编程，可以屏蔽掉底层具体实现改变导致上层改变的问题。

文中的那个例子，只是恰好同时使用了依赖注入这个编程技巧，同时也实践了基于接口而非实现编程这个原则。</div>2019-12-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg" width="30px"><span>业余爱好者</span> 👍（28） 💬（8）<div>原来的模式是一个spring开发的项目放在Tomcat中，控制权在Tomcat手中。现在微服务兴起，大家都用springboot开发。此时是Tomcat在springboot项目当中。控制权在springboot手中，虽然只是表面上。这便是控制反转。

这是一场控制权争夺之战。</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/fe/a6/bb3d76e6.jpg" width="30px"><span>KIM</span> 👍（16） 💬（5）<div>感觉比head first设计模式讲的清晰</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg" width="30px"><span>大力水手Jerry</span> 👍（15） 💬（2）<div>从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？
A：依赖注入是一种具体编码技巧，其主要目的有两点：
1.	将依赖关系建立的位置，从类的内部向上移动到类的入口（构造函数，或非构造函数的其他方法的参数），或者放到框架层面来支持（框架支持依赖关系的配置，对象创建，管理对象声明周期——根据对象被引用的记数实现）。
2.	通过改变依赖关系建立的位置，将创建被依赖对象的任务移动到类的外部，从而简化了类的作者的负担：一方面是创建对象的负担，另一方面是管理依赖的负担
“基于接口而非实现编程“是一种编程原则，通过接口引入中间层，实现依赖关系的解耦。这是一个非常宽泛的原则，可以细化为多项原则，比如接口隔离原则（强调接口的功能单一特性，即通过分解支持功能的灵活细粒度扩展），里氏替换原则（强调接口的行为一致性，保证接口上层代码逻辑的简单性），开闭原则（强调接口的抽象特性，即通过多态特性实现功能的扩展）。
用一句话来概括：“基于接口而非实现编程”是让依赖变弱，而“依赖注入”是让依赖转移，两者相互补充，可以方便的结合起来使用。</div>2020-10-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg" width="30px"><span>Ken张云忠</span> 👍（9） 💬（0）<div>区别:
基于接口而非实现编程:是面向对象编程的一种方式.减少对外部的依赖,还可以提升代码的灵活性,扩展及修改时可以控制风险的传播,符合开闭原则.
依赖注入:是一种具体的编码技巧,属于编程规范的范畴.不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。
联系:
两者结合在一起可以实现代码的灵活性,减少对外部的依赖,提升代码的可维护性&#47;可扩展性.
课外感想:
非常喜欢王争老师这样有深度内涵的课程,概念理解深入透彻,宏观方向把握准确,跟着老师的课程更有信心去挑战阿里这样一流企业的工作.报告老师,我归队了.</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg" width="30px"><span>帆大肚子</span> 👍（7） 💬（1）<div>在我看来，“依赖注入”是“基于接口而非实现编程”的一个实践。
“基于接口而非实现编程”是一条设计原则，可以帮助我们诞生更多类似于“依赖注入”的实践</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg" width="30px"><span>程序袁帅</span> 👍（6） 💬（0）<div>基于接口中的接口不是特指是编程语言中的接口，代表的是抽象。

1. 面向抽象编程，它强调的核心是抽象思维，解决的核心问题是程序的可扩展性。
2. 依赖注入，它强调的核心对象的管理，解决的核心问题释放程序员生产力，程序员不用花太多经历管理琐碎的对象创建和生命周期管理，将精力花在具有价值的业务上。</div>2020-02-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg" width="30px"><span>pines</span> 👍（6） 💬（0）<div>控制反转：控制指的是程序流程的控制，反转是指程序的流程的控制权由程序员转移到框架
依赖注入：上层类依赖底层类执行业务，以前往往将底层类作为上层类的成员变量，在上层类的内部声明底层类。注入就是底层类在外边声明，通过接口的方式注入到上层类中
依赖反转原则：我的理解是模块的解耦。上层模块依赖于低等模块，通过抽象出一套规则或者接口，使得上层业务依赖于抽象规则，低层业务实现规则。

我觉得基于接口编程与依赖反转原则比较类似，区别的话，依赖反转原则，依赖的不一定非得是接口，也许是一套规则，比如老师举的tomcat与java服务的例子</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg" width="30px"><span>progyoung</span> 👍（6） 💬（0）<div>依赖注入标价 25 美元，实际上只值 5 美分。形象啊，不能被貌似高大上的概念给唬住了，产生畏难心理。</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/91/54/007a667e.jpg" width="30px"><span>奥利奥，晴天。</span> 👍（5） 💬（0）<div>依赖注入的方式 特别好，结合开闭原则，很容易写出可测试的代码，以前写go语言，写个单元测试，引入数据库配置，引入配置文件，非常难测试，后来学了依赖注入这个东西，感觉代码测试，清爽干净简单了。。。</div>2020-06-04</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg" width="30px"><span>木子00</span> 👍（5） 💬（3）<div>还是没有彻底搞懂!!!
只是懂了文字上.</div>2020-02-14</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（5） 💬（0）<div>控制反转的本质是分拆控制代码和具体执行代码，控制代码放在较高的层次上，也可能交给第三方类库，实现代码放在较低的层次上，通常是一个接口的实现。

依赖反转本质是分拆类中的new语句，因为new语句引入了对实现类构造函数的依赖，属于很强的依赖。分拆之后构造和实现放在另外一个类里（通常交给第三方类库），使用的地方引用接口。依赖反转可以拆分类的依赖关系，可以减少实现类的引用，用接口取代，实现接口和实现的分离。依赖反转和基于接口而非实现的原则类似，两者都倾向于依赖接口而非具体类。不同点在于，前者更关注类层次中的依赖关系以及对构造函数的依赖，尽量避免高层次的类依赖底层的实现，尽量避免对构造函数的依赖。后者，更强调类的使用的地方，尽量使用更抽象更宽泛的接口，而非更具体更细节的实现，使得信息隐藏和抽象。

控制反转和依赖反转都是有成本的，会破坏代码的内聚性和简洁性，需要权衡使用。
</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/af/c9/d9c72c60.jpg" width="30px"><span>MindController</span> 👍（5） 💬（1）<div>深夜打卡</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg" width="30px"><span>冰糕不冰</span> 👍（4） 💬（0）<div>这个专栏确实讲解的非常细致！争哥确实是用心做专栏！以前对很多类似的概念都没理解透彻，通过这个专栏完全明白了！</div>2019-12-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/8f/c3/02801527.jpg" width="30px"><span>Scorpion 刘波</span> 👍（3） 💬（0）<div>看了三遍不知道说的啥，直到我百度了一下看到这篇，我悟了 https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;33492169</div>2022-04-14</li><br/>
</ul>