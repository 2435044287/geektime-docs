我们常把23种经典的设计模式分为三类：创建型、结构型、行为型。前面我们已经学习了创建型和结构型，从今天起，我们开始学习行为型设计模式。我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。

行为型设计模式比较多，有11个，几乎占了23种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

今天，我们学习第一个行为型设计模式，也是在实际的开发中用得比较多的一种模式：观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。今天我会重点讲解原理、实现、应用场景。下一节课，我会带你一块实现一个基于观察者模式的异步非阻塞的EventBus，加深你对这个模式的理解。

话不多说，让我们正式开始今天的学习吧！

## 原理及应用场景剖析

**观察者模式**（Observer Design Pattern）也被称为**发布订阅模式**（Publish-Subscribe Design Pattern）。在GoF的《设计模式》一书中，它的定义是这样的：
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/19/c7/02/8346ebf6.jpg" width="30px"><span>Chris</span> 👍（11） 💬（1）<div>生产-消费模型 是不是可以算是 观察者模式的一种异步非阻塞的实现呢</div>2020-08-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg" width="30px"><span>Laughing</span> 👍（2） 💬（1）<div>1. 生产消费应该是多对多的关系。
2. 消息通知、推送，应该都是基于这种设计模式应用而来的。</div>2020-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg" width="30px"><span>JerryZhu</span> 👍（1） 💬（1）<div>这个实际开发 真的超级超级常用！ 希望大家都能吃透了</div>2020-11-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/e7/48/df149c8d.jpg" width="30px"><span>。。。。</span> 👍（0） 💬（3）<div>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。这一段是怎么注册进来的，不是很明白</div>2020-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8d/ed/ea2cbf3a.jpg" width="30px"><span>Sinclairs</span> 👍（187） 💬（4）<div>发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现。
生产-消费模型，是多对多的关系，一般以异步的方式实现
两者都可以达到解耦的作用</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg" width="30px"><span>小兵</span> 👍（103） 💬（4）<div>区别在于生产消费模型以异步形式实现，消费者之间存在竞争关系。发布订阅以同步或异步的方式实现，订阅者之间没有竞争关系。联系在于两者在流程上都有先后关系。</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg" width="30px"><span>Jxin</span> 👍（81） 💬（4）<div>1.生产消费，一条消息只会被一个消费者消费（评论有人提多对多，确实是区别，但感觉有点误导）。发布订阅，一条消费可以被多个消费者共同消费。
2.两者都是行为模式，其实都是切分发布和消费这两个行为。就生产和发布这两个行为来说，只是换了名字，本质上是一样的。而消费和订阅，其实也都是消费消息，只是前者只能有一人来消费，后者是订阅的每个人都可以来消费。

3.状态机，状态流转的事件发布。（各种有状态业务线都可以用到）。</div>2020-03-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/98/af/3945cea4.jpg" width="30px"><span>一剑</span> 👍（76） 💬（2）<div>发布订阅和生产消费模型最大的区别在于：发布者（可观测对象）是知道订阅者（观察对象）的存在，因为它需要遍历订阅列表去发布事件；而生产消费模型因为有中间消息代理的存在，生产者和消费者完全不知道对方的存在，完全解耦！</div>2020-03-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/9a/d7/d8520096.jpg" width="30px"><span>Yeoman</span> 👍（35） 💬（5）<div>一路学来，看着下面的评论越来越少，终于跟上进度，继续加油。小争哥的栏目做的真的很好，干货满满，与看书感觉完全不同，关键是对读者的思想启发深远。</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg" width="30px"><span>忆水寒</span> 👍（27） 💬（2）<div>我负责的软件是一个网关软件，主要是协议转换并且与外部不同厂商的系统进行数据交换。
我目前采用分进程的方式，各个接口进程启动的时候会连接主进程，并在主进程进行注册。
主进程在有内容更新的时候会采用观察者模式群发给需要的接口进程。由接口进程去完成协议转换并发给外部厂商。</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg" width="30px"><span>西门吹牛</span> 👍（12） 💬（0）<div>生成-消费者模型：意图是保证生产消费，按节奏进行，可以通过阻塞队列和限流器控制节奏的快慢，更加关注的是生产和消费的数据；
观察者模式：更加倾向的是通知的行为，意图就是通知为主。</div>2020-07-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg" width="30px"><span>gogo</span> 👍（12） 💬（1）<div>个人认为，广义上，&quot;生产者-消费者&quot;模型属于观察者模式</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" width="30px"><span>Monday</span> 👍（11） 💬（10）<div>问题：
创建型模式4种，结构型7种，行为型11种，共22种，23种从哪来的？</div>2020-03-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg" width="30px"><span>Darren</span> 👍（10） 💬（3）<div>目前Java响应式编程中的RxJava和Vert.X都是基于观察者模式实现的，且都是异步方式。</div>2020-04-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg" width="30px"><span>传说中的成大大</span> 👍（7） 💬（2）<div>今天学了观察者模式过后
我觉得平时工作当中还是用了很多的设计模式,只是我们自己不知道而已</div>2020-03-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg" width="30px"><span>L🚲🐱</span> 👍（5） 💬（0）<div>消息队列就是用了观察者模式</div>2020-03-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg" width="30px"><span>www</span> 👍（4） 💬（0）<div>Youtube订阅发布机制也是很好的例子：普通用户订阅youtuber的频道，一旦youtuber发布新视频，普通用户收到频道更新的通知</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg" width="30px"><span>snake</span> 👍（3） 💬（1）<div>没太看懂setRegObservers 方法在哪里使用的，怎么把上面两个observier添加进来的</div>2021-03-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg" width="30px"><span>Remember九离</span> 👍（3） 💬（0）<div>PHP 实现的简易版本:https:&#47;&#47;github.com&#47;wuqinqiang&#47;php-design-patterns&#47;tree&#47;master&#47;src&#47;object&#47;patterns&#47;Observer</div>2020-03-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/9f/a4/a68e8403.jpg" width="30px"><span>小七</span> 👍（3） 💬（5）<div>看了适配器模式，观察者模式感觉代码结构的组织上区别不大啊，有种换汤不换药的感觉，如何区分到底是啥模式，总不能说你给方法赋予了一个接收和响应的语义他就是观察者模式了，换个语义就成了另一种设计模式了吧，请老师赐教</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg" width="30px"><span>Frank</span> 👍（3） 💬（0）<div>打卡 今日学习观察者模式，收获如下：观察者模式在开发中比较常见，小到代码层面的解耦，大到架构层面的系统结构设计，或者是一些产品的设计思路。之前在学习ActiveMQ的发布订阅模型的时候，就对观察者模式有过了解，但是只知道它使用到了观察者模式这种设计思路。通过今天的学习进一步理解了为什么需要总结出这么多的设计模式，回归到本质上还是为了写出“高质量”的代码，即满足单一职责，开闭原则、高内聚松耦合等特性，依次来控制和应对代码的复杂性，提高代码的可扩展性，可读性等。事件是不是也可以理解为观察者模式的一种实现？在JavaBeans的的架构中，事件是其核心特征之一, 在实际开发中事件也比较常见，比如AWT ，Netty编程中的IO事件，Spring和SpringBoot中的事件等。</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg" width="30px"><span>小晏子</span> 👍（3） 💬（0）<div>生产者消费者模型和观察者模型的相同之处是一方数据状态变化，另一方获取通知并做相关工作，不同之处是生产者消费者模型是个异步模型，生产者不知道有多少消费者消费消息，而观察者模型是个同步模型，而且被观察者知道有有多少观察者观察它的状态变化。应用场景除了文中提到的，还有微博用户关注等。</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg" width="30px"><span>Michael</span> 👍（2） 💬（0）<div>我们现在源数据后台系统在治理平台发布批量接口，导出数据，目标系统在治理平台订阅批量接口，数据导出后就会推送到目标系统，只不过中间的推送动作是ADE中间系统处理的，源系统只负责推送到ADE目标目录，ade触发推送数据住订阅系统.
还有我们系统用的发布服务订阅服务也是类似观察者模式，只不过是双向服务，主题发布订阅是单向服务而已</div>2020-03-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg" width="30px"><span>Heaven</span> 👍（2） 💬（0）<div>对于第一个问题,两者之间没有太大的联系,只能说,在异步实现观察者模式的时候,可以选择使用生产者消费者模式,当然也可以不选择这种模式,直接使用线程也行,而且生产者消费者之间可以做到多对多,解耦更加具体,更加适合于对于系统压力的降低
对于第二个问题,在某个云平台开发一个创建云服务器的逻辑,要求是可以在一个请求中创建多个云服务器,大概的实现是这样的,前端在发送一个请求给后端服务器,并创建一个websocket连接,客户可以无需等待了,后端会根据创建的数量开启countDownLatch,然后异步的发送创建请求,等创建完成后,会将计数器减一,直到计数器归零,就会通过websocket将哪些创建成功的消息推给网页,然后提示客户</div>2020-03-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg" width="30px"><span>Jackey</span> 👍（2） 💬（0）<div>个人认为观察者模式的应用范围更广吧，两者的目的都是解耦，生产-消费模型主要用于系统间解耦。而观察者模式既可以用于线程内代码解耦（同步阻塞），也可以用于线程间解耦（异步非阻塞），还可以用于进程间解耦（RPC或生产-消费模型）</div>2020-03-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg" width="30px"><span>小马哥</span> 👍（1） 💬（0）<div>回答问题1: 请对比一下“生产者 - 消费者”模型和观察者模式的区别和联系。
首先说区别: 
1, 生产者-消费者模型是一种代码模型, 观察者是一种设计模式;模型可以使用模式来实现;
2, 生产者-消费者模型天然解耦的, 解耦的手段是使用了队列, 或者是阻塞队列; 观察者模式的角色可以解耦, 也可以不解耦;

两者之间的联系: 
都可以实现发布订阅功能.</div>2022-07-05</li><br/><li><img src="" width="30px"><span>零零玲</span> 👍（1） 💬（1）<div>仅从语法上看，观察者模式的经典实现方式很像职责链模式啊</div>2021-01-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg" width="30px"><span>大力水手Jerry</span> 👍（1） 💬（0）<div>生产者-消费者模型更具一般性，观察者模式是生产者-消费者的一种特定实现。有些同学说采用队列也是观察者模式不能说不对，不过我还是倾向于将没有队列的情况下，在原始服务类（即Obserable）中组合能实施触发行为对象（即Observer）的这种原教旨形式称为观察者模式。</div>2020-12-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg" width="30px"><span>懒散</span> 👍（1） 💬（1）<div>功能代码和行为代码是什么区别呢？</div>2020-06-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/e6/e8439f9a.jpg" width="30px"><span>ttxser</span> 👍（1） 💬（0）<div>没有什么区别</div>2020-04-15</li><br/>
</ul>