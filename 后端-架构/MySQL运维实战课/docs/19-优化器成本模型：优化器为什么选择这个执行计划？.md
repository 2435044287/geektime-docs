你好，我是俊达。

上一讲中，我们通过四十多个SQL，演示了MySQL各种不同的执行计划。对于给定的一个SQL语句，MySQL为什么选择了某一个执行计划，而没有采用其他的执行计划呢？优化器会评估每一个可能的执行计划的成本，从中选择一个成本最低的作为最终的执行计划。这一讲中我们就来聊一聊执行计划的成本是怎么计算的。

## SQL预处理

一个SQL，在进行具体的成本计算之前，会先进行一系列的预处理。首先需要对SQL文本进行词法分析和语法解析，生成语法树。然后基于关系代数的一些基本规则，对SQL语句进行转换和改写。

常见的改写有以下几种方式。

- 等值条件传播

如果A=B，并且B=C，则A=C。

下面这个SQL中，原始条件是t1.a = t2.a and t2.a = t3.a，转换后，得到t1.a = t2.a and t1.a = t3.a，观察执行计划中的ref列就可以看到这一点。

```plain
mysql> explain select * from tab t1, tab t2, tab t3 
  where t1.a = t2.a 
  and t2.a = t3.a;

+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+-------+
| id | select_type | table | type | possible_keys | key     | key_len | ref      | rows | filtered | Extra |
+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+-------+
|  1 | SIMPLE      | t1    | ALL  | idx_abc       | NULL    | NULL    | NULL     | 9913 |   100.00 | NULL  |
|  1 | SIMPLE      | t2    | ref  | idx_abc       | idx_abc | 4       | rep.t1.a | 3304 |   100.00 | NULL  |
|  1 | SIMPLE      | t3    | ref  | idx_abc       | idx_abc | 4       | rep.t1.a | 3304 |   100.00 | NULL  |
+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+-------+
```
<div><strong>精选留言（3）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/15/8d/4d/992070e8.jpg" width="30px"><span>叶明</span> 👍（1） 💬（1）<div>  
另外，我看 gh-ost 的实现方式是另外一种，从左右边界和联合主键中字段之间的区间来考虑
  1. 最左边的边界: id1=&#39;a&#39; and id2=&#39;a&#39; and id3=&#39;1&#39;，可以通过这个查询条件来拿到最左边界的记录
  2. 联合主键 (id1, id2, id3) 中 id1 处于索引中第一列，因此 id1 是有序的，查询条件 id1&gt;&#39;a&#39; 拿到除 id1=&#39;a&#39; 之外的所有记录
  3. 步骤2完成后，只需要考虑 id1=&#39;a&#39; 的最后一条记录与第一条记录 (id1=&#39;a&#39;, id2=&#39;a&#39;, id3=&#39;1&#39;) 这段范围的记录了
  4. 当 id1=&#39;a&#39; and id2=&#39;a&#39; 时，要想访问 id3 的所有记录，查询条件得为 id3 &gt; &#39;1&#39;，这样就能拿到 id1, id2 为固定值时，id3 &gt; &#39;1&#39; 的所有记录，id3 = 1 的边界值在步骤 1 中已经拿到了
  5. 步骤4完成后，满足 id1=&#39;a&#39; and id2=&#39;a&#39; 条件的所有记录已经能拿到了，接下来，拿 id1 = &#39;a&#39; 时，id2 &gt; &#39;a&#39; 的所有记录，这样，id1=&#39;a&#39; 的所有记录就都能拿到了

select
  &#47;* gh-ost `test`.`t_business` iteration:0 *&#47; `id1`,
  `id2`,
  `id3`
from
  `test`.`t_business`
where
  (
    (`id1` &gt; _binary &#39;a&#39;)
    or (
      ((`id1` = _binary &#39;a&#39;))
      AND (`id2` &gt; _binary &#39;a&#39;)
    )
    or (
      (
        (`id1` = _binary &#39;a&#39;)
        and (`id2` = _binary &#39;a&#39;)
      )
      AND (`id3` &gt; _binary &#39;1&#39;)
    )
    or (
      (`id1` = _binary &#39;a&#39;)
      and (`id2` = _binary &#39;a&#39;)
      and (`id3` = _binary &#39;1&#39;)
    )
  )
  and (
    (`id1` &lt; _binary &#39;d&#39;)
    or (
      ((`id1` = _binary &#39;d&#39;))
      AND (`id2` &lt; _binary &#39;a&#39;)
    )
    or (
      (
        (`id1` = _binary &#39;d&#39;)
        and (`id2` = _binary &#39;a&#39;)
      )
      AND (`id3` &lt; _binary &#39;9990&#39;)
    )
    or (
      (`id1` = _binary &#39;d&#39;)
      and (`id2` = _binary &#39;a&#39;)
      and (`id3` = _binary &#39;9990&#39;)
    )
  )
order by
  `id1` asc,
  `id2` asc,
  `id3` asc
limit
  1
offset
  99</div>2024-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/8d/4d/992070e8.jpg" width="30px"><span>叶明</span> 👍（0） 💬（1）<div>联合主键的最小和最大值比较容易确定，比如我这里的最小值 (&#39;a&#39;, &#39;a&#39;, &#39;1&#39;)，最大值 (&#39;d&#39;, &#39;a&#39;, &#39;9990&#39;)，不能通过 id1&gt;=&#39;a&#39; and id2&gt;=&#39;a&#39; and id3&gt;=&#39;1&#39; 以及 id1&lt;=&#39;d&#39; and id2&lt;=&#39;a&#39; and id3 &lt;= &#39;9990&#39; 来进行数据分片，
这是因为这三个字段作为联合主键，三个字段作为一个整体是有序的，但细化到 id2, id3 字段，则是当前面字段的值固定时，后面的字段才是有序的，如果按照 id1&gt;=&#39;a&#39; and id2&gt;=&#39;a&#39; and id3&gt;=&#39;1&#39; 去匹配，那么会漏掉一些数据。
我想到的一种方式是将联合字段作为一个整体去匹配，例如 (id1, id2, id3) &gt;= (&#39;a&#39;, &#39;a&#39;, &#39;1&#39;)。</div>2024-10-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/46/4d/161f3779.jpg" width="30px"><span>ls</span> 👍（0） 💬（1）<div>循环主键，根据主键去批量更新1000行，每1000行提交一次。是不是就可以了</div>2024-10-09</li><br/>
</ul>