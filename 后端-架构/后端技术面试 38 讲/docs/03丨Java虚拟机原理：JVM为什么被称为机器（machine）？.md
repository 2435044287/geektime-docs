人们常说，Java是一种跨平台的语言，这意味着Java开发出来的程序经过编译后，可以在Linux上运行，也可以在Windows上运行；可以在PC、服务器上运行，也可以在手机上运行；可以在X86的CPU上运行，也可以在ARM的CPU上运行。

因为不同操作系统，特别是不同CPU架构，是不可能执行相同的指令的。而Java之所以有这种神奇的特性，就是因为Java编译的字节码文件不是直接在底层的系统平台上运行的，而是在Java虚拟机JVM上运行，JVM屏蔽了底层系统的不同，为Java字节码文件构造了一个统一的运行环境。JVM本质上也是一个应用程序，启动以后加载执行Java字节码文件。JVM的全称是Java Virtual Machine，你有没有想过，这样一个程序为什么被称为机器（Machine）呢？

其实，如果回答了这个问题，也就了解了JVM的底层构造了。这样在进行Java开发的时候，如果遇到各种问题，都可以思考一下在JVM层面是如何的？然后进一步查找资料、分析问题，直至真正地解决问题。

## JVM的组成构造

要想知道这个问题的答案，我们首先需要了解JVM的构造。JVM主要由类加载器、运行时数据区、执行引擎三个部分组成。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/19/7c/03/2941dea7.jpg" width="30px"><span>幸福来敲门</span> 👍（65） 💬（2）<div>老师，内存溢出和内存泄漏有什么区别，以java为例？？</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/77/61/adf1c799.jpg" width="30px"><span>KL3</span> 👍（8） 💬（4）<div>请问老师，关于类加载，对象方法和类方法都是放在方法区吗？ </div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg" width="30px"><span>乘坐Tornado的线程魔法师</span> 👍（5） 💬（4）<div>存活对象从From区复制到To区之后，在交换名称之前，是不是要把From区的那些不存活对象全部回收？（保证交换名字之后，To区永远是空白的）</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg" width="30px"><span>乘坐Tornado的线程魔法师</span> 👍（5） 💬（1）<div>操作系统处理线程栈这个场景是不是可以想象成，高并发场景下，每一个请求都要压入操作系统的线程栈，请求返回后，执行这个请求的线程才能从操作系统的线程栈中出栈？</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4a/80/9c038b01.jpg" width="30px"><span>AidenLiang</span> 👍（4） 💬（7）<div>老师你好
1.为什么新生代要设置3个区域呢？只有from和to不行吗？
2.多线程执行的时候，栈帧在栈上如何分配空间的，是分多个java栈吗？</div>2019-11-23</li><br/><li><img src="" width="30px"><span>我爱布丁</span> 👍（4） 💬（4）<div>老师，第一讲中谈到当操作系统载入编译后程序时，会在内存中建立进程，划分代码段，堆，栈等。那么当操作系统运行JAVA虚拟机加载类文件时，在虚拟机中的Java堆，栈是否会直接map到JAVA虚拟机进程的堆，栈呢？从操作系统看一个JAVA虚拟机进程，和一个普通的编译后程序进程结构上有区别吗？</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/27/e8/f4a29498.jpg" width="30px"><span>李怡尚</span> 👍（0） 💬（2）<div>文中垃圾回收只说了堆内存的回收，没有说方法区和栈内存的回收？</div>2021-03-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/25/35/14/901812fe.jpg" width="30px"><span>花不不</span> 👍（0） 💬（1）<div>如果在方法内创建了一个对象实例，这个对象实例信息将会被存放到堆里，而对象实例的引用，也就是对象实例在堆中的地址信息则会被记录在栈里。
- - - -
堆里面存储的对象实例在复制的过程中地址信息不会变化吗？如果变化了怎么通知到java栈呢</div>2021-02-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg" width="30px"><span>席席</span> 👍（0） 💬（1）<div>老师，你说Service和Dao都被设计成无成员变量，所以线程安全，这里的Service和Dao指的是接口还是实现类，如果是实现类那么必然会有成员变量呀，有点疑惑🤔</div>2021-02-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg" width="30px"><span>miracle</span> 👍（0） 💬（4）<div>虽然这个对象被放置在堆中，但是这个对象不会被其他线程访问到，也是线程安全的。

请问下，多个线程都可以访问这个方法，进而可以操作堆中的对象，为什么是线程安全的</div>2019-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg" width="30px"><span>[耶]友超</span> 👍（11） 💬（1）<div>老师，好强大的内功</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/51/de/990fd4f2.jpg" width="30px"><span>好好先生</span> 👍（5） 💬（0）<div>老师，你讲的真清晰，我背了面试题以后，很多地方一知半解，你这个专栏给了我补充说明，真是太强了</div>2020-03-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4f/b2/1e8b5616.jpg" width="30px"><span>老男孩</span> 👍（5） 💬（7）<div>虽然之前学习过相关的知识，老师讲的不敢说是最全面的，但是非常易于理解，我对jvm相关知识又有了新的认识！受益匪浅！
1）如果能把类加载机制说的更详细一点就更好了。因为以前我遇到过一个问题，就是tomcat启动后无法访问，一看日志报了一个PermGen空间不足的error，后来重新设置了一下就好了。原因可能是加了很多依赖jar包导致PermGen空间不足了。当时没有再多想。加载类信息以及静态常量是启动的时候一把加载进来？还是执行的过程中用到哪个类的时候再加载？如果不是一把加载进来，为什么tomcat启动后就报空间不足？
2）关于集合容器中元素导致的内存泄露问题，看了老师的文章我觉得如果map在方法中定义应该问题不大，但如果map是类的属性或者是一个静态属性的话就要小心了。不用元素一定要记得remove，或者可以使用弱引用的集合容器。</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg" width="30px"><span>杯莫停</span> 👍（4） 💬（2）<div>我记得刚工作的时候，写了一个ConcurrentHashMap 去缓存东西。结果最后去了数据没有显式的去清除，导致内存占用率越来越大，最终导致OOM。还好在测试的时候发现了问题。我想这就是一个内存泄漏的例子吧。从那以后，遇到类似缓存问题，我首先想到的就是会不会导致内存泄漏，尽量不写全局的集合，尽量少new对象，尽量使用有淘汰策略的缓存机制。

这篇我看了将近两天，画了JVM知识体系的思维导图，还是有很多细节的东西需要自己补充。</div>2020-08-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg" width="30px"><span>escray</span> 👍（2） 💬（0）<div>想要真的搞懂 JVM 虚拟机原理，那么估计还是得去看周志明的《深入理解 Java 虚拟机》（2019 年出到第 3 版），或者是隔壁的专栏《深入拆解 Java 虚拟机》。

不过李老师的这篇应该也算是深入浅出，典型 Java 程序的运行过程讲的很清楚，和整个专栏的风格比较搭。

Java 用的不够多，所以没怎么遇到与 JVM 底层相关的问题。

不过关于 OutOfMemoryError、StackOverflowError 和程序运行卡顿响应延迟较大的调试策略，对我来说很有启发。</div>2020-09-20</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBHy0D2KUZwOGHRG8qloicx2V4E4mImsPIiavPfr12BZB6QyUlHNdmOohC3EbsgnM2QNBeoqu82Grw/132" width="30px"><span>皮卡卡</span> 👍（1） 💬（0）<div>讲的真的好顺畅啊，佩服</div>2021-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1f/75/7d/1283991d.jpg" width="30px"><span>北岸大法师</span> 👍（1） 💬（0）<div>无论什么样的垃圾收集器应该都有stw吧，而不只是串行和并行收集器</div>2020-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg" width="30px"><span>杯莫停</span> 👍（1） 💬（0）<div>方法区存放的是类的元数据，类加载过程可知，字节码通过类加载器变成byte[]，加载到方法区，然后在堆中开辟一个对应的Class对象。
栈里面放的是执行方法的数据，局部变量，引用变量，入参，返回地址等。调用一个方法生成一个栈帧压栈，等线程结束执行，会出栈。栈是线程所有的，一个萝卜一个坑，互不影响，所以不会有数据安全问题。当然如果方法内有对静态成员操作的情况除外。
另外程序计数器寄存器存放的是指令执行行号，一个线程执行到方法的某一行，让出了CPU，下次继续运行的时候就要访问该寄存器了。</div>2020-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg" width="30px"><span>杯莫停</span> 👍（1） 💬（0）<div>关于三种回收算法：
标记清除：查找到垃圾对象，进行标记，然后进行清除。缺点是会产生内存碎片，导致内存浪费。
复制：将堆内存分为两块，即文章中提到的From和To区（还有别的叫法），优点是不会产生内存碎片。缺点是分两块势必会有一半的内存空间是空着的，比较浪费空间。一般用于年轻代GC。
压缩：或者也叫标记整理算法，事实上会分两步，标记和整理。先将垃圾标记，然后将存活对象整理移动到一端，再将标记的垃圾对象清除。特点是不会产生内存碎片，缺点是比较耗时。一般用在老年带的垃圾回收。</div>2020-08-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4e/83/88151c5f.jpg" width="30px"><span>Caliven</span> 👍（1） 💬（0）<div>看完第一节在看这一节有种恍然大悟的感觉</div>2019-12-14</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（1） 💬（0）<div>Java虚拟机是操作系统之上的操作系统：
操作系统是加载可执行文件执行，JVM是加载class文件执行。操作系统可以调度进程和线程，JVM主要调度线程。操作系统有堆栈作为存储，JVM也有堆栈，而且还可以回收堆中的内存。另外一个角度讲操作系统是jvm的基础，jvm是操作系统运行的众多进程之一，jvm屏蔽了操作系统的底层细节，才得以跨平台的</div>2019-12-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg" width="30px"><span>学习学个屁</span> 👍（1） 💬（1）<div>老师能多讲讲类加载吗，这儿只知道jvm加载class字节码，在深入就不懂了，谢谢老师。</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg" width="30px"><span>乘坐Tornado的线程魔法师</span> 👍（1） 💬（1）<div>老师好，有关JVM运行前的编译过程，请问HotSpot编译器和IDEA编译器的区别是什么？</div>2019-11-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/b8/21/f692bdb0.jpg" width="30px"><span>路在哪</span> 👍（0） 💬（0）<div>实用！</div>2022-09-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/80/2b/ef1581b5.jpg" width="30px"><span>米兰的小铁匠</span> 👍（0） 💬（0）<div>思考总结：本篇主要介绍了JVM
1、Jvm构造：程序计数器、虚拟机栈、堆、方法区、运行时常量池、本地方法栈
2、垃圾回收：
划分：新生代（Eden、from、to）、老年代
算法：复制（from-to）、标记-清除、标记-整理（压缩应该一致吧）（老年代）
垃圾收集器：Serial（串行）、Parallel（并行）、CMS（并发）、G1</div>2021-06-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg" width="30px"><span>曹翔</span> 👍（0） 💬（0）<div>jvm不仅仅是java专属，java只是语言，jvm上可以跑kotlin,Scala,JRuby,Jython等等语言</div>2021-03-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg" width="30px"><span>piboye</span> 👍（0） 💬（0）<div>回收阶段比较耗时，因为涉及到复制，标记阶段的优化没怎么讲</div>2020-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg" width="30px"><span>piboye</span> 👍（0） 💬（0）<div>标记还会stop all world吧？</div>2020-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg" width="30px"><span>kimoti</span> 👍（0） 💬（0）<div>做Java开发的时候有一个问题非常烦人那就是报ClassNotFound Exception。有时候在开发工具里运行是可以的,但打成一个Jar包独立运行就出问题,请问老师怎么看一个Jar包的类路径是什么？</div>2020-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg" width="30px"><span>杯莫停</span> 👍（0） 💬（0）<div>看了第一部分 栈，我就想，为什么学JVM困难，大概是因为我们的思维方式是跟设计者反着来的。我们学习之初大概很少有人一开始就站在设计者的角度思考，如果让我来设计这样一个线程执行模型，该怎样去做，该选哪种数据结构。而我们最开始学虚拟机大概都是先从虚拟机结构开始的，然后知道里面用到栈了，最后才知道这个栈是用来做什么的。然后再出来一个堆，完蛋了，好复杂。
认识了Java栈的使用之后，才意识到，这个设计巧妙的应用了栈这种数据结构先进后出的特点。以后开发中很可能会遇到类似的场景，是不是就可以用栈来解决了。</div>2020-08-07</li><br/>
</ul>