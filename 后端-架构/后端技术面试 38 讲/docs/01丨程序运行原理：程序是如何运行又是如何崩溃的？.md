软件的核心载体是程序代码，软件开发的主要工作产出也是代码，但是代码被存储在磁盘上本身没有任何价值，软件要想实现价值，代码就必须运行起来。那么代码是如何运行的？在运行中可能会出现什么问题呢？

## 程序是如何运行起来的

软件被开发出来，是文本格式的代码，这些代码通常不能直接运行，需要使用编译器编译成操作系统或者虚拟机可以运行的代码，即可执行代码，它们都被存储在文件系统中。不管是文本格式的代码还是可执行的代码，都被称为**程序**，程序是静态的，安静地呆在磁盘上，什么也干不了。要想让程序处理数据，完成计算任务，必须把程序从外部设备加载到内存中，并在操作系统的管理调度下交给CPU去执行，去运行起来，才能真正发挥软件的作用，程序运行起来以后，被称作**进程**。

进程除了包含可执行的程序代码，还包括进程在运行期使用的内存堆空间、栈空间、供操作系统管理用的数据结构。如下图所示：

![](https://static001.geekbang.org/resource/image/89/98/89c6e3bbc44cdc042e7a8bcddb3b4398.png?wh=920%2A852)  
操作系统把可执行代码加载到内存中，生成相应的数据结构和内存空间后，就从可执行代码的起始位置读取指令交给CPU顺序执行。指令执行过程中，可能会遇到一条跳转指令，即CPU要执行的下一条指令不是内存中可执行代码顺序的下一条指令。编程中使用的循环for…，while…和if…else…最后都被编译成跳转指令。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg" width="30px"><span>斐波那契</span> 👍（106） 💬（5）<div>在java里 锁是通过cas把当前线程id刷新到对象的头信息里 在获取锁时会去头信息里拿这个信息 如果没有 则会cas刷新进去 刷新成功就获取到锁 刷新失败就表明有别的线程也在尝试刷新这个信息 在操作系统层面 有pv操作保证原子性 而pv操作也是利用cpu中原语指令 在获取锁时保证不会被别的指令打断（或被重排序）</div>2019-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg" width="30px"><span>Luciano李鑫</span> 👍（40） 💬（9）<div>“不管你是否有意识，你开发的 web 程序都是被多线程执行的，web 开发天然就是多线程开发。”这个会不会绝对了一些，比如go或者c++开发的没有额外创建线程的web程序呢？</div>2019-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg" width="30px"><span>Allen_</span> 👍（24） 💬（7）<div>有些地方可能不是很到位，欢迎补充
小结：
1. 我们平时开发出来的程序是文本格式代码，但只是在硬盘中还只是一个程序，只有加载到内存里面通过cpu执行成为进程才是发挥了程序作用。
2.进程里面有堆，栈，可执行代码和进程数据结构。
3.cpu分时共享技术进行并发操作，进程切换效率不高，所以有了线程切换
4.因为线程安全问题引入锁，不过也引入了更多造成阻塞的可能
5.线程阻塞可能是I&#47;O,锁，网络请求，数据库链接获取
6利用分布式系统架构来减缓高并发的性能不佳</div>2019-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg" width="30px"><span>蚂蚁内推+v</span> 👍（15） 💬（2）<div>李老师好：我想请教下，一个JVM 是一个进程。JVM 上跑 tomcat，tomcat 可以部署多个应用？那每个跑在tomcat 上的应用是一个线程吗？那一个应用crash了，其他应用也会crash.这块感觉有点问题。不知道老师方便解释下吗？</div>2019-11-18</li><br/><li><img src="" width="30px"><span>我爱布丁</span> 👍（12） 💬（1）<div>老师，看完文章，联想到两个关于协程的问题：

1. 使用协程在出现IO等待时，程序会自己调度去执行其他的(CPU)任务。理论上这样可以避免额外的IO等待导致的线程间切换。我的问题是从系统的角度上看，使用协程可以抢占到更多的CPU时间片吗？

2. 感觉系统崩溃（除人为Bug外) 主要是系统资源不足导致的。那么即使用轻量级的协程也不会变得更好。因为当协程数量过多，导致event loop过大，变慢，系统还是要崩溃的对吗？
</div>2019-11-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/81/18/f3642be3.jpg" width="30px"><span>雷咏</span> 👍（12） 💬（3）<div>我们用文本格式书写的程序有三种执行方式:
1.解释执行。例子是脚本语言书写的程序或类似于BASIC语言书写的程序。著名的PYTHON也属于这种情况。
2.编译执行。通常C&#47;C++程序属于这种情况。文本格式书写的程序称之为源程序，需要编译器编译成机器语言代码，称之为可执行程序一或目标程序。
3.虚拟机执行。将文本格式的程序先编译成一种中间代码，然后由驻留在计算机中的虚拟机解释执行。例子是通常的JAVA程序。
</div>2019-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg" width="30px"><span>探索无止境</span> 👍（6） 💬（1）<div>希望老师在第二节课可以谈谈上一节课留下的思考题，您是怎么理解分析的</div>2019-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg" width="30px"><span>peter</span> 👍（4） 💬（2）<div>一直以为tomcat是一个独立的进程。根据本文所述，tomcat只是一个线程，是虚拟机进程中的一个线程。是这样吗？</div>2019-11-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/10/5a/3411221e.jpg" width="30px"><span>Heidi</span> 👍（4） 💬（3）<div>你好，想提个问题。文章中大部分知识点都掌握，但是遇到问题的时候没有从这些角度出发，只是跟着一些关联去分析问题，对遇到的问题反应比较慢。这种情况是不是知识没有成体系？那么怎样建立比较完整的知识体系呢？</div>2019-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/57/40/6dcefbd5.jpg" width="30px"><span>Tobe24</span> 👍（4） 💬（3）<div>您好，老师，这节课太适合我这种新手了，这里有三个不太明白的地方，希望老师能够解惑。
问题1：CPU 分时共享技术同时执行进程的数量，取决于什么？
问题2：为什么线程切换的代价更小？
问题3：进程切换是不是必须要等到线程切换完毕后进行？如果不是，优先级是由什么决定的？
一点小建议：
有一些表达程度的词，如果能用数据举例简单说明一下，对于我们理解会更有帮助。比如2问题中，代价更小，小到什么程度，是进程切换速度的几倍?
思考题：
作为小白，我的思路是这样，锁是在线程的临界区，线程是在进程的线程栈，而 一个 cpu 同时只能运行一个进程，所以本质上都是轮流执行的……于是，只要保证在获取锁的时候，锁不在正在获取或已经被获取的状态即可，进而推断线程中会有一片内存区域用来存这些状态信息。
😂不知道这个思路对不对。
最后谢谢老师。</div>2019-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg" width="30px"><span>布拉姆</span> 👍（1） 💬（2）<div>“被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源”被阻塞的线程并不消耗cpu（或者说时间片）对吧？占据的资源是IO类的，比如文件描述符或者IP port之类的吗？</div>2021-02-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4a/80/9c038b01.jpg" width="30px"><span>AidenLiang</span> 👍（1） 💬（2）<div>老师，别人常说java和go等是带有运行时的语言，难道c和cpp没有吗？运行时是指垃圾回收这些功能吗？</div>2019-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/44/c1/ebe870bb.jpg" width="30px"><span>李郝</span> 👍（0） 💬（1）<div>很多年前看过智慧老师的那本大型网络技术架构，大致读了两遍，每次都获益匪浅，确实因为个人水平不足，很需要智慧老师这种能帮我将很多杂乱的知识言简意赅的融会贯通起来，让我对于未来遇到的问题可以更自信的去解决。同时，通过这些文章，也让我学会了如何提高自己学习的效率，以及如何去训练自己以达到目标等等，非常感谢！</div>2020-11-13</li><br/><li><img src="" width="30px"><span>志江</span> 👍（0） 💬（1）<div>李老师,
我理解tomcat就是一个jvm进程吧, tomcat启动的时候实际上是启动一个jvm进程(包含)tomcat字节码文件)
这么理解对么</div>2020-09-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg" width="30px"><span>静水流深</span> 👍（0） 💬（1）<div>老师，您好，闭包函数的执行栈帧如何描述？</div>2019-11-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/9f/d7/14240f8d.jpg" width="30px"><span>超群</span> 👍（0） 💬（1）<div>李老师可以写一篇细说并发的文章吗？现在有很多写高并发的书或者文章，但是几乎没有人写过并发是什么。对于并发总感觉一种雾里看花的感觉，有点清楚但是又不是很清楚。希望李老师考虑一下，谢谢</div>2019-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/39/7d/cafbd583.jpg" width="30px"><span>Asura</span> 👍（0） 💬（1）<div>老师赶紧更新，无限期待中😄</div>2019-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/71/1d/8d1d27b2.jpg" width="30px"><span>蔡伟祥</span> 👍（0） 💬（4）<div>李老师，请问对于多个用户请求的线程，可否建立一个共享数据池。线程不直接访问数据库而是从数据池来“拿”数据？如何可以的话，共享数据池本身应该也是一个线程吧，哪请问一个线程怎么从另一个线程里获取数据？ 谢谢</div>2019-11-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg" width="30px"><span>学习学个屁</span> 👍（8） 💬（2）<div># 01 程序运行原理

## 程序是如何运行起来的？

- 1 、程序员被开发出来，文本格式代码，不能直接运行，需要编译器或者虚拟机先编译成机器码（也叫可执行代码），存储在文件系统中（即磁盘）。
- 2 、操作系统将编译好的代码加载到内存中。
- 3、CPU去执行，运行，程序运行起来被称作进程。

运行起来的程序，在运行期使用内存堆空间，栈空间，等数据结构。

![如图](https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;89&#47;98&#47;89c6e3bbc44cdc042e7a8bcddb3b4398.png)



程序运行时需要创建数组等数据结构，这些由操作系统在进程中分配。

进程的堆，栈中分配相应的空间，比如堆，堆的地址又存在栈中。



栈：一种数据结构，遵循先进后出，后进先出的顺序。

比如函数

```
void f(){
int x = g(1); x++; &#47;&#47;g函数返回，当前堆栈顶部为f函数栈帧，在当前栈帧继续执行f函数的代码。
}
int g(int x){ 
return x + 1;
}
```





每次函数调用，操作系统都会在栈中创建一个栈帧，方法程序（函数）通常被压栈进栈，函数中的变量，内存都在当前栈帧中，如下图。



![如图](https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;f0&#47;f7&#47;f08d6fca893da5cac926a23f1f1aa7f7.png)





## 计算机如何同时处理数以百计的任务



通常情况下我们个人的PC 可能会是一核心或两核，现在基本都4核或者更高核cpu了

我们个人通常是用电脑会同时打开很多程序软件，听歌的，看电影的，下载视频等等几十个任务。

而服务器可以同时处理成千上百个任务以及并发请求而且一点儿都不卡顿（这里也存在服务器配置高的因素）

### 为什么电脑可以同时处理这么多的任务呢？

`这里主要依靠的是操作系统的 CPU 分时共享技术`

很多个进程在执行，操作系统会将 CPU 的执行时间分成很多份，进程按照某种策略轮流在 CPU 上运行

&gt; 每个进程都只被执行了很短一个时间，但是在外部看来却好像是所有的进程都在同时执行，每个进程似乎都独占一个 CPU 执行



为什么每个程序不单独使用进程呢？

原因是因为CPU每个进程在CPU上轮训使用，消耗资源以及时间很大！

通常我们在打开自己电脑时候开了很多软件（或者进程）后明显的感觉自己电脑变慢了，卡顿了。

一方面是因为自己电脑内存小，另一方面是因为进程数太多了，cpu切换需要花费时间。



那么如何解决进程多cpu切换代价大的情况呢？

计算机的先辈们引入了线程的概念，比如我们开发中容器tomcat 每次用户请求时候，tomcat分配给用户一个线程，在进程里可以启动很多的线程，线程可以理解为轻量级的进程，在进程内创建，拥有自己的线程栈，在 CPU 上进行线程切换的代价也更小。



线程在运行时，和进程一样，也有三种主要状态

运行：当一个进程在 CPU 上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于 CPU 的数目。

就绪：当一个进程获得了除 CPU 以外的一切所需资源，只要得到 CPU 即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。

阻塞：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待 I&#47;O 完成，等待锁……）而暂时停止运行，这时即使把 CPU 分配给进程也无法运行，故称该进程处于阻塞状态。



## 系统为什么会变慢，为什么会崩溃



主要大致可以分为一下几个步骤原因

- 1、线程锁，引起线程阻塞，多线程情况下可能会存在线程排队等锁，县城无法并行执行导致速度变慢。
- 2、此外I&#47;O阻塞同理，比如数据库连接，并行数量超过数据库连接数量，线程就会出现阻塞
- 3、等待其他县城释放连接才能访问数据库，并发越大等待连接越多，响应时间越长，系统越慢。
- 4、被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源，在系统中一边等待一边消耗资源，如果阻塞的线程数超过了某个系统资源的极限，就会导致系统宕机，应用崩溃。





如何解决

- 1、采用请求限流
- 2 、集群架构
- 3、分布式架构

</div>2019-11-19</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（5） 💬（0）<div>磁盘上的代码就是一堆静态的二进制数据，运行之间和一张图片没有本质区别。当被执行的时候，代码就被加载到内存变成进程，原先的代码被转化成CPU可以操作的指令。一般的指令是从前往后的，也有些指令是根据条件跳转的，循环条件语句都是跳转指令。程序除了消耗CPU外，还要消耗内存。内存又分为栈和堆，栈处理函数运行的局部变量，新的函数调用，会有新的栈帧。堆处理局部变量以外的变量，例如Java new的对象，这些对象又会被栈中的变量引用，堆栈一起协同工作，堆容量大，负责存储。栈记录活动变量，引用堆中存储，后进先出。进程就是把指令集合，堆栈打包并建立边界的一个容器。CPU是全局宝贵资源，可以被多个进程共享，如果有多核的话，也可以同时运行多个进程，Python中的并发就是这么实现的。但是，每个进程都有自己的堆栈和其他活动资源，切换代价高昂。所以，多数编程语言都有线程的概念，线程是CPU调度的单位，同一进程下的线程之间共享堆和其他资源，切换成本大降，但是多个线程共享堆也会引发一系列并发的问题，通常需要锁来解决。另外一种平凡调用IO的情况，线程也不算太合适，因为IO和CPU本身并不竞争，通常IO比CPU慢10倍以上，所以很多语言引入了协程，在单线程的情况下实现并发，让IO和CPU资源得到充分利用，协程切换的成本比线程更低，也没有并行的问题，但也要注意协程只是在单线程下调度IO和CPU资源，对于并行计算并无帮助。
单个进程或者线程消耗太多资源会让系统变慢甚至崩溃，更多的情况是，等待中的进程线程数目太多，无法释放资源而让系统变慢甚至崩溃。这就好比交通系统，一辆坦克车横冲直撞造成问题毕竟少，多数问题还是车多到一定数目，前面的车过不去，后面的车进不来，虽然，每辆车都遵守交通法则，但是还是造成了拥堵。这个时候，正常的交通规则已经不管用了，需要其他治理拥堵的特殊措施来处理。</div>2019-12-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/53/8b/cf442e81.jpg" width="30px"><span>夜里饿煮面</span> 👍（5） 💬（0）<div>操作系统中PV原语是最小的原子，就是不知道硬件上是怎么实现的</div>2019-11-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg" width="30px"><span>程同学</span> 👍（4） 💬（0）<div>太棒了，醍醐灌顶，这操作系统和应用开发融会贯通，太棒了。

老师，遇见你是我的幸运。</div>2021-01-19</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2SjCeylLv0P3Glle5277kA4b8cAuxr1NrC0njPKEqzSpB8IEicHB29GicFFwG1qiaxs4hxRiaBmoibVw/132" width="30px"><span>阳仔</span> 👍（2） 💬（0）<div>扩容，限流，降级。从无损到有损的解决高并发问题的手段</div>2020-01-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg" width="30px"><span>Citizen Z</span> 👍（2） 💬（0）<div>粗略思考：
1. 锁在内存中只有 1 份数据（JVM 用堆区中对象的 header 来实现，所以是每个线程都可见的），有开&#47;关两个状态
2. 不同线程访问锁时一定是有先后顺序的（JMM 的 happens-before 原则有规定，这个可能涉及较多手段来保证，问题难点主要出现在多核 CPU 和 CPU cache 的情况下）
3. 如果线程遇到打开状态的锁，就“获取并关闭“锁（这里的原子性由 CPU 指令保证，就是 cas 机制）

更复杂的锁优化策略都在这个基础上实现</div>2019-11-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/ae/cf/6186d936.jpg" width="30px"><span>辉度</span> 👍（1） 💬（0）<div>1. 程序是一个文件，一个可以被操作系统理解，运行的文件。
2. 程序运行的单位是一个进程，操作系统为进程在内存中分配堆空间、栈空间；分配CPU时间片执行代码指令。
3. 程序变慢主要是锁、IO阻塞等竞争性的资源有限，过多的竞争导致“排队”阻塞。
4. 程序奔溃是变慢的一个无穷大的体现。资源已经完全不足，操作系统、甚至硬件为了自保的壁虎断尾操作。</div>2023-01-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg" width="30px"><span>FelixFly</span> 👍（1） 💬（0）<div>锁如何实现的？
1. 必须要存在共享变量，CAS操作
2. 需要存储阻塞线程的队列，每次唤醒一个
3. 是否可以抢占(公平锁和非公平锁)</div>2022-02-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg" width="30px"><span>渔村蓝</span> 👍（1） 💬（0）<div>CPU 以线程为单位进行分时共享执行，这句不是太理解。操作系统调度进程，Jvm调度线程，所以cpu以线程为单位执行吗？那其他非jvm的进程呢，他一定有线程吗</div>2021-04-19</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（1） 💬（2）<div>请问老师，内存中的堆区域和数据结构中的最大堆最小堆，两者都叫做堆，两者有没有关系？</div>2019-12-04</li><br/><li><img src="" width="30px"><span>Paul Shan</span> 👍（1） 💬（0）<div>思考题
锁要全局共享但只有一处可得，应该有特殊的CPU指令来处理吧。</div>2019-12-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/ab/19/829f321f.jpg" width="30px"><span>迈步</span> 👍（0） 💬（0）<div>读了几遍，收获越来越不一样。</div>2023-12-19</li><br/>
</ul>