你好，我是陈现麟。

通过上节课的学习，我们理解了事务的一致性的定义，并且知道了事务一致性的实现，是通过底层存储的多副本数据强一致性，事务的原子性、隔离性和持久性一起协作，以及数据库层和应用层的约束检测等各方面来保障的，那么本节课，我们就继续来讨论事务中，另一个非常重要的特性：原子性。我们从原子性的定义出发，一起分析在分布式系统中，原子性的实现方法，最后再对原子性的关键问题进行讨论。

当我们对事务的原子性进行讨论和学习后，你就能明白原子性是一个非常完美的抽象，因为它对应用程序，屏蔽了分布式系统中部分失败的问题，这可以大大减少我们在编程时的心智负担。

## 原子性的定义

一般来说，我们在计算机领域第一次接触“原子”这一概念，都来源于操作系统的“原子操作”。在操作系统中，原子操作的定义是指，不可被中断的一个或者一系列操作，它包含了两个层面的意思。

首先，是**整体的不可分割性**。一个原子操作的所有操作，要么全部执行，要么就一个都不执行，即 all-or-nothing 。

其次，是**可串行化的隔离性，即线程安全**。原子操作是在单核 CPU 时代定义的，由于原子操作是不可中断的，那么系统在执行原子操作的过程中，唯一的 CPU 就被占用了，这就确保了原子操作的临界区，不会出现竞争的情况。原子操作自带了线程安全的保证，即最严格的隔离级别的可串行化，所以我们在编程的时候，就不需要对原子操作加锁，来保护它的临界区了。
<div><strong>精选留言（4）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg" width="30px"><span>peter</span> 👍（4） 💬（1）<div>请教老师一个问题：
Q1：seata是2PC还是3PC？ springcloud体系架构中，seata是一个流行框架，那么，seat属于2PC
还是3PC？</div>2022-03-25</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2sqFM20XhgC5xjEfDhbB1lk6rIe7LnqnxEicDdEcRSJ20YCTeBEcYFE84lvHFrJDq9n4WW7P9Zkg/132" width="30px"><span>nothing</span> 👍（2） 💬（0）<div>1. 3PC对于协调者和参与者都设置了超时时间，而2PC只有协调者才拥有超时机制。这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。

2. 通过CanCommit、PreCommit、DoCommit三个阶段的设计，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。

但是3PC依然没有完全解决数据不一致的问题。</div>2022-04-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg" width="30px"><span>Geek_27a248</span> 👍（0） 💬（0）<div>老师，您好，有个不是很明确的问题，就是2pc再阶段2，发起提交的时候，3个节点，2个成功，一个失败。
1、协调者是认为事务是成功的吗
2、此时失败的节点是否会同步2个成功节点的数据恢复到正常状态
3、发起回滚请求时也是如此吗
4、协调者在收到2个成功节点的ack之后，剩余一个失败的ack是怎么处理的呢
谢谢老师</div>2023-04-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/0a/86/2f7dfb98.jpg" width="30px"><span>Next</span> 👍（0） 💬（0）<div>“如果协调者在事务执行过程中崩溃了，那么等到协调者恢复后，在事务日志中如果没有发现未解决的事务，就中止事务；反之，就会继续执行事务。”  这里不理解， 请老师解答</div>2022-05-08</li><br/>
</ul>