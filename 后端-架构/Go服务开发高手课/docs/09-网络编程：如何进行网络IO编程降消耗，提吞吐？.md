你好，我是徐逸。

前面，我们花了不少篇幅一同深入学习了Go服务高性能编码技巧，来全力保障线上服务的性能。不过呢，除了我们写的业务逻辑代码，服务框架本身对于性能也有着举足轻重的影响。而影响框架性能的一个很重要的因素，就是框架所使用的网络IO模型。

今天我们就来聊聊网络IO模型、epoll技术和Golang底层网络IO的原理。掌握网络IO模型、epoll技术和Golang底层网络IO原理，不仅有助于你更好地做框架选型，而且还能提升你使用Go开发更底层网络程序的能力。

## 网络IO模型

在介绍具体的网络IO模型之前，先让我们来想一想，一次网络IO的过程大概是什么样的呢？

就像下面的图一样，以读IO为例，网络数据要被咱们的应用程序接收到，可以划分为下面两个阶段。

1. 数据准备阶段，驱动程序和操作系统内核从网卡读取数据到socket的接收缓冲区。
2. 数据复制阶段，由应用程序将内核空间socket缓冲区的数据复制到用户空间。

![](https://static001.geekbang.org/resource/image/43/45/434d1c7ac5bf2ea7e8c94af9df05c445.jpg?wh=3534x2557 "图1 网络数据传输")

应用程序对这两个阶段的不同处理方式，就形成了不同的网络IO模型。那么应用程序对这两个阶段有哪几种处理方式呢？

### 阻塞IO

我们先来看看数据准备阶段的处理方式。就像下面的图一样，**当我们的应用程序进行网络IO调用时，如果socket缓冲区还没有准备好，我们可以让应用线程阻塞在IO调用方法里，而不直接返回，这就是阻塞IO模型**。
<div><strong>精选留言（2）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/21/d7/4f/5059c43a.jpg" width="30px"><span>CodeFish-Xiao</span> 👍（3） 💬（1）<div>感觉这篇的质量跟之前比下降了，Golang运行时的网络实现和Linux本身的IO复用优化，但是实际上我们用Golang进行网络编程该进行哪些优化没有讲到
</div>2024-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg" width="30px"><span>lJ</span> 👍（1） 💬（2）<div>1. 老师能讲一讲io_uring吗，有哪些知名的应用，大厂的态度，Golang的支持情况等
2. epoll ET模式存在数据丢失的风险，如果接收缓冲区足够大的情况下，还存在丢失吗，后续新的数据到达重新触发通知，应用程序应该可以读取到之前未读完的数据吧
3. golang net是如何解决数据丢失的风险的，在使用epoll ET编程时有哪些开发规范或最佳实践应对这个问题
4. 思考题
golang net设计了 BIO模式的 API，为每个连接都分配一个 goroutine。 这在高并发下，会产生大量的 goroutine，需要频繁的上下文切换，增大Goroutine 调度器的开销。  
a. evio，使用事件驱动模型，采用单线程或多线程事件循环，比协程并发模型更轻量。  
b. netpoll，使用gopool池、高效的内存复用、支持检查连接是否存活，可以及时清理池中失效的连接，降低资源占用。   
c. gnet，也是使用ants池，高效、可重用而且自动伸缩的内存 buffer。   
以上三个库没有看过源码，简单看了官方文档。个人觉得，evio与netpoll，gnet的不同之处是抛开了协程并发模型，完全基于epoll事件循环模型。而后两者还是采用协程模型，主要使用了协程池，内存池优化达到资源复用，减轻了调度器和GC开销。</div>2024-12-27</li><br/>
</ul>