你好，我是徐逸。

通过前面的课程学习，我们已经了解了如何从编码和框架这两个层面来优化服务性能。不过呢，当性能瓶颈点是下游数据库时，这两个层面的优化就无能为力了。

对于数据库性能的优化，除了合理使用索引等使用细节上的优化之外，在高并发场景，我们还需要在架构层面进行优化。

今天我们就来聊聊，在高并发读写场景，如何从架构层面来优化数据库的读写性能。

## 案例准备

为了让你更加身临其境，我会以一个实践中的案例为基础，带你通过一步步演化数据库架构，来实现高并发读写数据库的目标。

作为用户，想必你使用过类似微信“附近的人”这样的产品功能。对于这样的产品功能，它的内部是如何实现的呢？

![](https://static001.geekbang.org/resource/image/0f/79/0f1498eff044bd2776c7f98a8a62a779.jpg?wh=2342x1900 "图1 附近的人")

从服务端的角度出发，为了实现这个产品功能，服务端通常需要提供下面这两个功能接口。

1. 第一个是写入接口。在用户打开页面时，客户端将调用此接口，用以上传用户所处位置的相关信息。
2. 第二个是查询接口。当用户打开页面后，客户端会调用此接口，根据用户当下的位置信息，检索在一定时间内出现在其附近的其他用户。

从服务端内部实现的角度，对于位置数据的存储和检索，我们可以用MongoDB数据库来实现。

假如现在我们构建了一个基于 MongoDB 数据库的 “附近的人” 服务，它采用的是单库单表的数据库架构设计，核心实现逻辑如下。
<div><strong>精选留言（3）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg" width="30px"><span>Realm</span> 👍（1） 💬（1）<div>在网上查了下，理解下大概过程如下:

1. Mysql用索引组织数据,索引是B+树;
2. 非叶子节点和叶子节点，都保存在数据页中；
3. 一个数据页大小是16k,理论上mysql的B+树,最多有1280个树杈；计算过程如下：
   a. 非叶子节点的数据页（每个页的大小是16k）,去掉每页的head和tail信息,有15k的空间，用来存放索引指针信息；
   b. 一个索引指针需要12Byte（主键ID:8Byte、指向下游的页号:4Byte）
   c. 15k&#47;12Byte = 1280,也就是B+树最多有1280个树杈
4. 叶子节点存放的真实数据，假如一行数据的大小按1k，一个数据页，可以存15行数据；
5. 设B+树的层树为x,则叶子节点的数量有: 1280 ** (x - 1) *15   [1280的x-1次方,在乘以15]
6. 假如树只有3层（基于IO效率考虑）,则可以存放:1280 ** 2 * 15 = 2.5千万 行数据

注意: 这有有很多限定条件，如至于3层，一行数据按1k计算。</div>2025-01-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/93/e2/1bde89e8.jpg" width="30px"><span>日月</span> 👍（0） 💬（1）<div>是直接存储用户的经纬度吗，这样在计算附近的人的时候会不会很慢呢，好像有geohash和四叉树的算法会不会好点</div>2025-01-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg" width="30px"><span>lJ</span> 👍（0） 💬（1）<div>1. 如何理解图7中的proxy，需要自行开发还是有开源的实现。
2. “2000万行是大表”是基于经验总结和 MySQL 在不同场景下的性能瓶颈得出的经验值，超过了这个值可能会导致 B + 树层级更高，影响SQL性能。具体还需要结合业务场景和硬件配置。随着硬件性能和数据库优化手段的进步，这一数值可能会有所提高。但当表数据量显著增长时，适时进行表拆分是提升性能和扩展性的关键手段。</div>2025-01-02</li><br/>
</ul>