你好，我是徐逸。

上节课我们学习了如何使用设计模式，来提升我们代码的可维护性。不过除了设计模式之外，Go 语言本身所提供的反射和泛型特性，同样是我们手中的得力工具。借助这些特性，我们能够达成逻辑复用的目标，避免重复编写那些功能相近的函数，让代码更加简洁。

今天，我就以实现一个求最大值的函数为例，在优化这个函数实现的过程中，带你了解反射和泛型知识。

## 案例准备

假设我们已经有了如下的函数，用于求取两个整数间的最大值。

```go
func MaxInt(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

现在，如果我们想要实现一个类似的函数，来求取两个浮点数的最大值，我们可能会像下面这样增加一个新的函数。

```go
func MaxFloat32(a, b float32) float32 {
    if a > b {
        return a
    }
    return b
}
```

不过，一旦我们进一步拓展需求，需要针对int64、float64 等很多其它数值类型获取最大值，这种不断添加新函数的方式，会导致代码中出现大量逻辑极为相似的函数。这不仅会使代码库变得臃肿不堪，还会极大地增加代码维护的成本。

那么是否存在一种方法，能够让我们避免重复编写逻辑相似的函数，而是在一个统一的函数里，就可以实现对所有数值类型求最大值的功能呢？