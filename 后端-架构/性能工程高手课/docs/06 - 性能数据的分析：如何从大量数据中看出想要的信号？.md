你好，我是庄振运。

我们这一讲来谈谈如何分析我们所得到的性能数据。现代的应用程序和互联网服务系统都比较复杂，要关心的性能参数也很多，所以你从各种渠道得到的性能相关的数据量往往很大。那么要如何从大量的数据中找出我们所关心的特征和规律呢？这就需要你对数据做各种分析和对比了。

这一讲要解决的核心问题就是：**如何从大量数据中看出想看的信号？**

当人沉浸在大量数据中时，是很容易迷失的。而“不识庐山真面目”的原因，当然是“只缘身在此山中”了。但这不能作为借口，我们需要练就“慧眼识珠”的本领，做到对各种性能数据一目了然，才能够做出一针见血的分析。

为了帮助你练就这样的本领，今天我们首先讲一下常见的算法复杂度和性能分析的目的，然后针对一个性能指标来分析，再延伸到对多个性能指标进行对比分析，最后谈谈进行数据分析的几个教训和注意点。

## 算法的时间复杂度

先简单地聊一下算法的时间复杂度（Time Complexity）。复杂度一般表示为一个函数，来定性描述该算法的期待运行时间，常用大O符号表述。

考虑程序和算法的时间复杂度时，大家通常关注的是某个解决方案属于哪个时间复杂度。具体来讲，有六种复杂度是比较普遍的，这里按照从快到慢的次序依次介绍：
<div><strong>精选留言（8）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/fb/7f/746a6f5e.jpg" width="30px"><span>Q</span> 👍（12） 💬（3）<div>做运维的免不了要经常和性能数据打交道，往往很多时候，不细致了解数据内在含义，仅靠字面意思，往往很容易走入误区。比如CPU IO Waite，当这个值升高的时候，大多数人，包括我自己，会认为系统IO出现瓶颈问题了。直到我阅读了一篇关于CPU IO Waite的文章之后，我才明白，这个值不一定说明当前系统IO出现问题。简单来说，能导致CPU IO Waite值升高，有两个条件:
1.系统仍有未完成的IO正在处理，这个IO处理时间可能会很长，但不一定说明磁盘IO到了瓶颈
2.进程因为等待IO完成而处于不可中断的睡眠状态，即CPU处于空闲状态中

</div>2019-12-09</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKr0jFhAf5MmL7zBzB7ZsmzEunI82MjULLPhgMd3Tc6d7GBuZHogd15IT1a1YLCMibouV5B2rDvKg/132" width="30px"><span>han</span> 👍（4） 💬（0）<div>定位性能问题需要对知识有全面的认识，说一下自己的理解：
- 理解应用系统各个模块对资源消耗的偏重（有的是磁盘IO、有的是内存、有的是CPU）；
- 理解操作系统各类性能指标的含义，大部分情况应该是Linux（内存、CPU、Disk、网络等）
- 熟知操作系统各类性能参数工具（当然现在很多运维工具采集的也很全面了）
- 了解各类操作的常规开销，比如内外网延迟、应用的CPU、IO使用率、数据库延迟
- 应用系统的外部依赖分析，很多时候问题是由外部依赖出现问题导致的，比如数据库、磁盘、网络、缓存等</div>2019-12-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg" width="30px"><span>A君</span> 👍（3） 💬（0）<div>简单地说，如果是单一数据分析，重点是看它的趋势，如果是多项数据分析，就要看它们的相关性。</div>2020-06-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/7b/59/3716014f.jpg" width="30px"><span>Shupeng Xu</span> 👍（2） 💬（3）<div>“举个简单例子，Linux 系统的空闲内存其实就是一条时间序列，它或许显示快到 0 了，看起来性能问题出在这里。但是稍微了解 Linux 系统内存管理知识的人，就知道这个指标非常不可靠”

老师能否解释一下这里？不是很明白，谢谢。</div>2019-12-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/48/ee/96a7d638.jpg" width="30px"><span>西西弗与卡夫卡</span> 👍（2） 💬（0）<div>印象最深的是一个反向例子。事先估计用户量太大，导致过度设计，到下线都没有达到预计的百分之一，反而增加了开发周期。</div>2019-12-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg" width="30px"><span>许童童</span> 👍（2） 💬（0）<div>有了数据，只是第一步，如何分析，得出性能分析的结果，这一步更为重要，先了解理论，再做实践，希望跟着老师，能一步步探究出性能分析的奥妙。</div>2019-12-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg" width="30px"><span>追风筝的人</span> 👍（1） 💬（0）<div>p(A) * p(B|A) = p(B) *p(A|B)</div>2022-06-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/9f/c2/3d1c2f88.jpg" width="30px"><span>蔡森冉</span> 👍（1） 💬（0）<div>关于时间复杂度，刚刚好这两天遇到过：就是求1到n的累加和若使用常见的for循环来做那时间复杂度就是O(n),假如我们使用y=n(n+1)&#47;2来计算那么时间复杂度就变为O(1)</div>2020-04-23</li><br/>
</ul>