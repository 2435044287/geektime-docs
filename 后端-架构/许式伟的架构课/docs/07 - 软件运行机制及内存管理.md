你好，我是七牛云许式伟。

操作系统的核心职能是软件治理，而软件治理的一个很重要的部分，就是让多个软件可以共同合理使用计算机的资源，不至于出现争抢的局面。

内存作为计算机最基础的硬件资源，有着非常特殊的位置。我们知道，CPU 可以直接访问的存储资源非常少，只有：寄存器、内存（RAM）、主板上的 ROM。

寄存器的访问速度非常非常快，但是数量很少，大部分程序员不直接打交道，而是由编程语言的编译器根据需要自动选择寄存器来优化程序的运行性能。

主板上的 ROM 是非易失的只读的存储。所谓非易失，是计算机重新启动后它里面的数据仍然会存在。这不像内存（RAM），计算机重新启动后它上面的数据就丢失了。ROM 非易失和只读的特点，决定了它非常适合存储计算机的启动程序（BIOS）。

所以你可以看到，内存的地位非常特殊，它是唯一的 CPU 内置支持，且和程序员直接会打交道的基础资源。

内存有什么用？前面我们在 “[02 | 大厦基石：无生有，有生万物](https://time.geekbang.org/column/article/91007)” 一讲中介绍冯·诺依曼结构的时候，画过一个图：

![](https://static001.geekbang.org/resource/image/cf/37/cf77b8fbe8a559cecbb264c390bc7337.png?wh=1920%2A763)

从图中可以看出，存储的作用有两个：一个是作为 “计算” 的操作对象，输入和输出数据存放的所在；另一个是存放 “计算” 本身，也就是程序员写的程序。

这里说的存储，主要指的就是内存。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/15/5b/79/d55044ac.jpg" width="30px"><span>coder</span> 👍（45） 💬（1）<div>我觉得许大大的这个专栏写的挺好的。从计算机底层的角度去思考和总结架构的观点，让人觉得眼前一亮。

btw，看到评论区有人问cache的事情，补充一下自己的看法。
cache一般对programmer和软件来说确实是透明的，但是它也有缺点，比如说占用了大量的芯片面积[50%左右，因为要维护tag RAM和一致性]，它也导致程序的行为难以分析。所以在实时的嵌入式场景和目前流行的AI专用加速器中都不采用Cache，目前大量采用的是scratchpad memory，它是一种对程序员可见的片上存储，需要programmer自己显式地来管理，e.g. GPU的shared memory，TPU的local buffer等</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg" width="30px"><span>黄海峰</span> 👍（29） 💬（5）<div>这个专栏应该叫“计算机导论”而不是叫“架构”。。。</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg" width="30px"><span>川杰</span> 👍（28） 💬（3）<div>老师您好，有两个问题希望解答：1、淘汰的内存页数据保存在哪里？是保存在外置存储设备中吗？2、CPU加载对应程序的代码段到内存中，那么CPU是如何知道这个对应程序的代码段在什么位置的呢？</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a0/27/bdc6307d.jpg" width="30px"><span>晓凉</span> 👍（25） 💬（1）<div>从“缺页中断”看架构设计的开闭原则，CPU是硬件，生产出来就不能修改，本身是封闭的，设计上要考虑的是扩展的开放性，缺页中断解决了开放性问题。软件的设计，因为源代码是对程序员开放的，可随便修改，封闭性不能物理上保证，所以需要同时考虑封闭性和开放性。服务化隔离不同的代码模块，一定程度上实现了类似物理上的封闭性。</div>2019-05-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/43/f7/abb7bfe3.jpg" width="30px"><span>刘冲</span> 👍（16） 💬（2）<div>分离变化点和不变点，把不变点做成回调，预留了变化，这种思路其实就是架构的核心，如何区分和管理变与不变</div>2019-06-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/21/66/f9125286.jpg" width="30px"><span>keshawn</span> 👍（12） 💬（1）<div>表面上是在讲技术，实际上是在分析需求</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/df/6e/267bd6ee.jpg" width="30px"><span>1900</span> 👍（12） 💬（1）<div>这里说的“虚拟内存”是内存还是磁盘啊？感觉应该还是内存。</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg" width="30px"><span>zhangtnty</span> 👍（11） 💬（2）<div>许老师, 您的文章很棒。有一点小小的建意, 能否您亲自录音频, 现在的音频老师录得也很好, 但总觉得少了点计算机、软件、架构的一丝丝底蕴（个人浅见）。有时音频对于读者也是很重要的，辛苦老师考虑一下。</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/ee/16/742956ac.jpg" width="30px"><span>涵</span> 👍（8） 💬（1）<div>请问老师内存管理作为操作系统的一个重要且基本的功能，其本身就是一段程序需要在启动时加载在内存中并且永远不被交换到外置存储对吗?那么这段程序在保护机制下是如果一直停留在物理内存中的呢?是写入特定的内存页，永远不会被交换出去，还是由于内存管理功能总是被所以程序调用，由于访问频繁因此永远不会被换出去?另外，操作系统是如何管理内存和寄存器之间的数据交换呢?有点儿想象不出来这个接口。比命令将内存地址1中存放的数据放入2号寄存器，将寄存器3中存储的数据输出至内存地址4，这是一个怎样的过程呢?谢谢。</div>2019-05-07</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132" width="30px"><span>乘风</span> 👍（7） 💬（2）<div>架构思维上学到了什么？
  CPU虚拟空间设计思想：将外置系统做高度抽象，外置系统实现了虚拟空间的约定，CPU在运行时与虚拟空间进行数据交换，虚拟空间与外置系统进行交互，从而完成CPU的资源调度、管理功能。
  封装了变化点，外置存储结构的不确定性，建立统一规范，双方按照规范完成整个协作流程。</div>2019-05-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/ee/16/742956ac.jpg" width="30px"><span>涵</span> 👍（7） 💬（1）<div>第二个问题是关于内存和寄存器(RAM和CPU)的数据交换。确实是如老师所说，有再学一学操作系统的冲动。学着老师的架构课感觉到本科时的课程设计是很好的，可惜当时见识太浅，每门课只是孤立的在学习，为了完成作业拿个好分数而学习，从未整体的去思考课程设计背后计算机的完整架构，真的是很有意思的事情。</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/33/9f/8dbd9558.jpg" width="30px"><span>逆流的鱼</span> 👍（7） 💬（1）<div>如果都是保护模式，比如Java进程，启动指定了堆或者内存大小为4G，那其实内存实际没有分配吗？linux服务器可用内存没有减少4G？运行实际占不到4G？！</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg" width="30px"><span>胖胖虎</span> 👍（6） 💬（1）<div>老师，我有个问题。内核空间是单进程的，那是否意味着每个用户进程的内核部分都是完全一样的？内核线程的地址空间是怎样管理的。谢谢！</div>2019-10-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg" width="30px"><span>Young</span> 👍（6） 💬（3）<div>Cache都是SRAM，速度快但是集成度低，不适合集成容量特别大。其中1st level 和last level cache对性能影响最大，通过Instruction Read miss（I1mr，ILmr），Data read miss（D1mr，DLmr），L1的miss会有10个cpu cycle的惩罚期，LL的miss会有200个cpu cycle的惩罚。所以，虽说cache不可编程，但是为了降低惩罚，也就是提高命中率，反过来是要求你的代码具有效率，数据结构的合理性。比如基于cache加载内存数据的locality（局部性原理），当你循环遍历一个二维数组时，先行后列的性能远远高于先列后行，原因是前者的命中率远远高于后者。</div>2019-05-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/d3/93/bef5a186.jpg" width="30px"><span>苟范儿</span> 👍（6） 💬（1）<div>从硬件架构到其上的操作系统。但是不得不佩服前人在这些层面给出的架构，BIOS 引导、OS、Shell 等系统级方案，仔细想象，每天都在用，各类软件的开发都在这些架构之上很好的运行。</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/f6/08/ecf5d724.jpg" width="30px"><span>Enthusiasm</span> 👍（6） 💬（2）<div>老师可以多加一些：按照历史发展的时间顺序来讲技术间因果关系，以便于构建完整的知识体系架构，而细节上可以用给出参考链接或书籍的方式来让我们自己去索骥。比如这一章，由于之前了解过汇编语言，我知道8086CPU一开始是不支持保护模式的，后来386之后才开始支持。明显CPU和操作系统是经历了一段磨合，不是一上来就采用了这种保护模式，CPU也不是一上来就支持保护模式，而操作系统厂商也不是一开始就想到要多任务（比如DOS），很想知道当中发展中经历了哪些尝试和妥协。还希望老师把知识体系描述的更完整一些，比如操作系统除了DOS，Windows，同时期的还有Unix，MacOS，关于这一章，很想知道这几条技术线是如何并行发展的，他们一定有相互竞争和借鉴的feature，很想听一听。原则上希望可以通过技术发展的逻辑，理清知识体系和脉络。不然的话，这片知识在我们脑中，依然是一座孤岛，觉着可能没用就当做垃圾给回收了。希望听到更多技术、思想历程，可以多用一些搜索引擎可以搜索到的“概念”减少篇幅，而把详细描述用在那些“搜索引擎难以搜索到的”知识来增加干货。</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/f5/ce/7d8807d5.jpg" width="30px"><span>WadeYu</span> 👍（6） 💬（1）<div>现在的主流操作系统都是运行在保护模式下吧</div>2019-05-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg" width="30px"><span>恬毅</span> 👍（5） 💬（2）<div>1、虚拟内存是内存和磁盘的配合。
2、地址映射表，是保存虚拟内存和物理内存对应关系，将虚拟的内存地址转为物理的内存地址。
3、映射表是放在内存中的，因为cpu需要访问，然而cpu只能访问内存，
4、地址映射表由操作系统维护。
5、执行流程：
1）操作系统告诉cpu要操作那个逻辑内存页；
2）cpu通过映射表去获取逻辑内存页对应的物理内存地址，然后获取执行；
3）如果没有找到逻辑内存对应的物理内存，就会触发中断机制通知操作系统；
4）操作系统会为这个逻辑内存页分配物理内存。然后cpu就可以继续执行。</div>2021-03-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg" width="30px"><span>Daiver</span> 👍（4） 💬（1）<div>实模式和保护模式，这让我想到了内核态和用户态，这两者之间是否有一定的联系呢</div>2019-10-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg" width="30px"><span>码农Kevin亮</span> 👍（4） 💬（1）<div>请问老师，关于CPU访问虚拟内存的机制有一点不明白：对CPU来说，它只知道一个虚拟地址，但它是如何判断这个虚拟地址上的数据是不是它要的数据呢？换个问法就是，缺页是怎么判定出来的呢？</div>2019-10-03</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7cOHiaxJBPvYLhmibkcY3HvonnRCvY3Kma6RIzeaIaLR2ZNf9fn5yicWiaKUUVf2TuhF99icfLw46waA/132" width="30px"><span>nyx.ulric</span> 👍（3） 💬（2）<div>老师你好，关于虚拟内存页有一些没理解，
1，内存地址分页和缺页中断配合，软件刚启动的时候用到了10个页的话，后面再需要内存页是软件发起的吗？如果是这样的话，那每个软件在制作的时候都要考虑缺页中断的“功能”吗？
2，同一个软件打开2个的时候，分配到的内存页是同样的内存页吗？</div>2019-12-22</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132" width="30px"><span>乘风</span> 👍（3） 💬（1）<div>整个内存空间分成了连续的多个内存页是指虚拟空间这样分吗？</div>2019-05-17</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132" width="30px"><span>乘风</span> 👍（3） 💬（1）<div>求许老师帮助
保护模式下非完整读取，意味着运行时动态读取（从磁盘读取），节省了内存空间但出现了运行卡顿的问题，因为内存和磁盘的读取速率相差极大，这个问题如何解决？</div>2019-05-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/82/9e/bb6f7229.jpg" width="30px"><span>Benjamin</span> 👍（3） 💬（1）<div>请问老师怎么保证不同进程通过独立的映射表得到的物理地址相互之间不冲突呢？</div>2019-05-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0a/4a/07ec2ad1.jpg" width="30px"><span>ibing</span> 👍（2） 💬（1）<div>老师您好，下列理解还请帮我指正，谢谢：
实模式内存管理：
每个软件自由申请物理内存资源。（缺点是，软件之间能相互修改内存数据；申请后不论使用否都会占用内存，导致内存不够用）

保护模式内存管理
CPU地址映射表，把虚拟的内存地址转为物理的内存地址。软件不直接操作物理内存，通过虚拟内存的映射表的中转来操作物理内存，这样可以避免软件之间相互修改内存数据的情况。
虚拟内存及其缺页机制，软件申请内存资源后，只为其分配虚拟内存，不占用物理内存，只有在需要使用时才会分配物理内存，这样能提高内存利用率。同时当物理内存不够时也会释放长时间未使用的内存，存储到外置存储上（如：swap文件）</div>2019-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/00/07/8e3ceda8.jpg" width="30px"><span>吴双</span> 👍（2） 💬（1）<div>老师，虚拟内存表存在哪里？发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据，内存页的数据存在哪里？</div>2019-10-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg" width="30px"><span>码农Kevin亮</span> 👍（2） 💬（1）<div>请问老师，假设一段虚拟内存A1映射的物理内存地址是a1。当物理内存不足时，a1被回收用于加载别的程序。那么这时原程序A1-&gt;a1的映射关系是如何断开的呢？是在操作系统层面提供了一个a1-&gt;A1的反向映射表么？</div>2019-10-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" width="30px"><span>Smallfly</span> 👍（2） 💬（1）<div>RAM 为什么不和主板一样，设计成非易失的呢？是出于成本考虑么，还是因为非易失的写入性能太差了？</div>2019-06-28</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJSmAhbvPia1msvk91m5rQLTpicY85f2moFMCcAibictL3OeiaaVREadpHN2O3FwicmylwiclTUJJa1peS1Q/132" width="30px"><span>张sir</span> 👍（2） 💬（1）<div>请问实模式下运行的场景都有什么？能举个例子吗
</div>2019-06-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/d9/b8/2d8900d5.jpg" width="30px"><span>史鹏飞</span> 👍（2） 💬（1）<div>通过共享内存内存进程间可以通信，老师能说说共享的机制吗？</div>2019-05-14</li><br/>
</ul>