你好，我是七牛云许式伟。

在上一讲，我们介绍了进程内执行体之间的协同机制。今天我们接着聊进程与进程之间的协同。

这些协同机制大体可分为：互斥、同步、资源共享以及通讯等原语。对于这些协同机制，我们对比了 Linux、Windows、iOS 这三大操作系统的支持情况，整理内容如下：

![](https://static001.geekbang.org/resource/image/27/e5/276e3874bc64364c10c52371f6b11ce5.png?wh=734%2A826)

在逐一详细分析它们之前，我们先讨论一个问题：从需求角度来讲，进程内协同与进程间协同有何不同？

在早期，操作系统还只有进程这个唯一的执行体。而今天，进程内的执行体（线程与协程）被发明出来并蓬勃发展，事情发生了怎样的变化？

请先思考一下这个问题。我们在这一讲最后总结的时候一起聊聊。

## 启动进程

在讨论进程间的协同前，我们先看下怎么在一个进程中启动另一个进程。这通常有两种方法：

- 创建子进程；
- 让Shell配合执行某个动作。

前面在 “[11 | 多任务：进程、线程与协程](https://time.geekbang.org/column/article/96324)” 一讲中我们已经提到过，创建子进程 UNIX 系的操作系统都用了 fork API，它使用上很简洁，但是从架构角度来说是一个糟糕的设计。Windows 中我们用 CreateProcess，这个函数有很多的参数。

iOS 很有意思，它并不支持创建子进程。在进程启动这件事情上，它做了两个很重要的变化：

- 软件不再创建多个进程实例，永远是单例的；
- 一个进程要调用另一个进程的能力，不是去创建它，而是基于 URL Scheme 去打开它。
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/10/42/62/536aef06.jpg" width="30px"><span>tim</span> 👍（31） 💬（2）<div>信号量（system V) 有一个属性是un-do,如果进程挂掉，这个进程获得的资源会释放。避免死锁饿死的问题</div>2019-06-05</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132" width="30px"><span>ヾ(◍°∇°◍)ﾉﾞ</span> 👍（25） 💬（3）<div>非常同意作者观点啊！另外有个疑惑就是Chrome浏览器是多进程设计的，据说是为了追求性能，许总怎么看？</div>2019-06-19</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eop9WylZJicLQ5wib49kcMPqCTRT1aThh6mMAVl6qseLwbVOLhicVLjZCxCoyQd5CrrHHibs2CVPaoK3g/132" width="30px"><span>ljf10000</span> 👍（18） 💬（1）<div>ios有点docker的意思</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ab/65/a439af12.jpg" width="30px"><span>BillyZhang</span> 👍（7） 💬（1）<div>有一点不太理解，IOS 是手机或是移动操作系统，linux和windows 是pc 或是服务器操作系统，虽然安卓也是基于linux 但是 使用场景还是不太一样的吧， 那么同是苹果操作系统 MacOS 是否也是沙箱设计模式呢？</div>2019-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/97/19/b724ca0a.jpg" width="30px"><span>L-jiehui</span> 👍（6） 💬（1）<div>老师思维高度很高，再一次收获巨大，谢谢老师
有两个问题请教下老师：
1、操作系统如果不知道信号量的值多少才合理，不能统一按照自定义默认的值，例如0来处理吗
2、虚拟内存实现进程隔离具体如何实现的呢，网上看了一遍资料，还是理解得不够清晰</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/ff/8c/a6a2b26b.jpg" width="30px"><span>Cordova</span> 👍（5） 💬（1）<div>我觉得iOS这样设计挺好的，本来就该思考这个系统面对的是什么样的使用场景，也许我们以后只需要一个用户进程呢、只不过这个用户进程功能很强大、当系统变得微小化、各种设备被变得多样化、不需要去协调用户进程、需要什么数据问问另外一个微系统设备就好啦、那这样我们的以后的系统就只需要为这一个进程保留一个套接字就好啦！所以iOS我觉得代表了以后的方向和趋势！反正听完许老师的课我是想法很多～不过可能明天早上爬起来又背着电脑，坐着公交去上班了。</div>2019-05-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/cf/97/fcd8957d.jpg" width="30px"><span>82</span> 👍（5） 💬（1）<div>1，ios进程单实例就没法做到android的应用双开能力吧？
2，在使用url scheme进程通讯时，如果存在多进程实例，是否会让系统疑惑跳转到哪个进程？
3，一台机器就是一个局域网，每个进程实例都是一个端，这种通讯思想似乎拓宽了网络的边界，无处不网络。</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1e/b7/b20ab184.jpg" width="30px"><span>麋鹿在泛舟</span> 👍（4） 💬（3）<div>&quot;为什么？因为进程可能会异常挂掉，这会导致同步和互斥的状态发生...&quot;
请教个问题，线程难道不会因为挂死而异常么? 如果这时候持有锁，其他线程同样的会持续拿不到锁而阻塞了。</div>2019-05-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/12/f9/7e6e3ac6.jpg" width="30px"><span>Geek_04e22a</span> 👍（4） 💬（2）<div>老师，读了这篇文章，感觉收货颇丰，以前所有机制只认为是进程间通讯，没有想过重新划分同步互斥，资源共享，收发消息几类。现在有两个问题，iOS共享资源使用的是剪切板吗？Linux创建子进程目的是什么？</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/c7/d6/32d7bd4e.jpg" width="30px"><span>zhuyc</span> 👍（2） 💬（1）<div>&quot;规格强调的是自然体现需求，所以规格是稳定的，是子系统的契约。&quot;关注规格与契约的讨论，后面有没有机会更详细展开看看。
我能理解接口与实现的分离，老师提到的规格似乎是更高层的概念</div>2019-07-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/fe/16/aac4d7f2.jpg" width="30px"><span>Geek_zclap3</span> 👍（1） 💬（1）<div>这个层次有点高了，第一遍完全不知道在说啥！任重道远啊~</div>2019-06-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/95/ab/7e21a7a6.jpg" width="30px"><span>坤亮</span> 👍（1） 💬（1）<div>界面是不是应该叫接口？</div>2019-06-08</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg" width="30px"><span>Peter Yu</span> 👍（0） 💬（2）<div>老师，PV操作中的P和V英文全称是什么呢，不太好理解</div>2022-03-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/a5/c9/eb389183.jpg" width="30px"><span>Hungry</span> 👍（0） 💬（3）<div>老师，iOS也是有信号量dispatch_semaphone，pthread 锁，条件变量，以及 mmap 的，毕竟iOS也是BSD的一类，用kqueue的</div>2019-07-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg" width="30px"><span>Bachue Zhou</span> 👍（98） 💬（6）<div>iOS 可以大刀阔斧的改革的一个重要原因就是，这个操作系统的使用场景极为单一，全部都是直接面向用户的交互式应用。这点和通用操作系统 UNIX 有巨大的区别，例如它连 UNIX 最基本的命令行都没有，也没有 CS&#47;BS 架构需求，大量 UNIX 进程间通讯都是为这些需求而设计的，需求没有了，自然底层机制也就不需要了。由此其实也可以看出来，通用操作系统应该是作为一个底层操作系统来用，只负责硬件抽象，而每一个系统应该根据自己的使用场景去设计一个上层操作系统，而不是直接拿底层操作系统充当上层操作系统用，或者将二者混为一谈，虽然这么多年来，人们已经习惯了这种设计，但这不是正确的。</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg" width="30px"><span>亢（知行合一的路上）</span> 👍（3） 💬（0）<div>做减法表面上是简化了设计，深层次是对事物的认识提高了一个层次，认知升级了。</div>2020-06-01</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132" width="30px"><span>有铭</span> 👍（3） 💬（1）<div>IOS的核心思路就是进程先天级别的隔离。可以认为它自带docker。但是我认为这个代价太大了。说真的如果不是IOS的自带逼格光环，这种隔绝程度的操作系统流行不起来的。并不是理论上先进的系统就一定好。很多时候还是需要现实的妥协</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/ec/b2/fd9ba311.jpg" width="30px"><span>zygfengyuwuzu</span> 👍（3） 💬（0）<div>第一次认识到操作系统架构设计</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/89/d9/3386fca3.jpg" width="30px"><span>嚆同学</span> 👍（2） 💬（0）<div>从来没想过可以通过分析计算机系统的设计来了解架构知识，老师功力深厚。</div>2019-09-27</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg" width="30px"><span>hua168</span> 👍（2） 💬（2）<div>一个软件只需启动一个进程实例。
如果是多核，单进程不是浪费吗？
我看nginx它是1核一个线程…</div>2019-06-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/f1/70/bca09d2d.jpg" width="30px"><span>觉</span> 👍（2） 💬（1）<div>感恩大佬分享 随喜大佬</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/f6/ba/09ab72d2.jpg" width="30px"><span>幻灰龙</span> 👍（1） 💬（0）<div>赞同，特别是，我也一直认为进程间通讯只要socket就够了，而不应该有那么多为了优化而分离出来的概念。事实上，在我视角里，我一直不把进程看成是在同一台机器上，我认为进程就是一个独立的机器，进程间，就是机器间关系，这样看的好处是，扩展到网络上就是自然而然的。当然实现上人们会认为这有着巨大的性能差异，毕竟一旦引入网络，联通性和时延带来的问题就不可避免。</div>2020-02-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/62/81/ad80f427.jpg" width="30px"><span>Lane</span> 👍（1） 💬（0）<div>很好的思考，我认为进程既然是资源隔离的，是没有必要共享内存，这里可以借助go的思想，要靠通信来共享。老师很自然的类比到了子系统的边界，本来UserService是个很单纯的用户信息的代码，有时和用户沾边的需求也放在这里，久而久之导致庞大而不纯粹。</div>2019-06-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg" width="30px"><span>Aaron Cheung</span> 👍（1） 💬（0）<div>打卡13 深入操作系统进程架构</div>2019-05-28</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg" width="30px"><span>布拉姆</span> 👍（0） 💬（0）<div>这几掌都好精彩 读技术书读出了融会贯通的爽感</div>2024-11-23</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/93/38/71615300.jpg" width="30px"><span>DayDayUp</span> 👍（0） 💬（0）<div>pickup: 子系统之间是合约约束的，是以需求为导向的，是稳定的。具体实现的接口框架是变动的，是不稳定的，在设计中要考虑对变化扩展。</div>2023-10-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（0）<div>规格是稳定的，是子系统的契约。而实现框架是技巧，是不稳定的，也许下次重构的时候实现框架就改变了。
--记下来</div>2023-08-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（0）<div>学习打卡</div>2023-08-14</li><br/><li><img src="" width="30px"><span>Geek_88604f</span> 👍（0） 💬（0）<div>进程间互斥、同步以及通讯机制有锁、信号量、事件（windows）共享内存、文件系统、剪切板等。从整体发展上看是五花八门，比较混乱，大概是由于进程的所处的层级比较高、粒度比较粗，面向的是用户，导致进程间的通讯措施粒度偏粗、偏用户（如果其通讯措施很底层，看起来就很不协调），遇到实际需求怎么方便怎么来，再加上各种安全问题，就很难控制了（文件内容、剪切板，这些对象大家都可以操作，属于人机交互）。因此优化的目标是由乱入治，大刀阔斧得做减法，由人机交互到机机交互，标准、通用、简洁（机器容易理解，人理解起来也还行），虽然牺牲了一部分效率。这让我想起了贝索斯说过的“所有的团队今后必须通过服务接口来开放自己的数据和服务功能......任何人不遵守以上协议，就滚蛋吧”</div>2022-12-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/8d/ba/30f502ed.jpg" width="30px"><span>刘杰</span> 👍（0） 💬（0）<div>iOS相当于留了一个URL的api句柄接入和socket，剪贴板很不安全肯定很少用来通信，这个设计思路还是很有用的，666，简单才是硬道理，外部接口统一是很好的思路，往往就是简单困难，堆材料谁不会</div>2022-10-23</li><br/>
</ul>