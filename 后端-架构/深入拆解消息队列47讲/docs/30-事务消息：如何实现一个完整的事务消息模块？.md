你好，我是文强。

上节课我们讲完了延时消息，这节课我们来看看消息队列中的事务消息。作为一个研发人员，我们对于事务的概念可以说是如雷贯耳了，最熟悉的应该就是MySQL或Redis的事务。

事务有一个特点，它的概念很明确，也很常见，但是它在不同的存储引擎的作用以及实现都是不一样的。所以如果我们想使用某个引擎中的事务功能，就必须先理解一下引擎中实现的事务的功能是什么，能达到什么效果，再去理解和使用它，不能想当然地把经典的 MySQL 的事务的功能套入到新的引擎去使用。

下面我们就从最基础的开始，先来看一下消息队列中的事务消息是什么，以及用户在什么情况下会用到事务消息。

## 消息队列中的事务是什么

从原始概念来看，事务是并发控制的单位，是用户定义的一个操作序列。简单解释，事务是一批操作的集合。它有ACID四个特性，分别是：**原子性**、**一致性**、**隔离性**、**持久性**。

1. 原子性指这批操作要么全部成功，要么全部失败。
2. 一致性指事务中的所有操作的结果符合预期，都能达到想要的结果。
3. 隔离性指不同事务间是完全隔离的，不相互干扰。
4. 持久性指事务一旦被提交，那么它的执行结果则是永久的。

总结一句话就是，一批操作执行后，具备ACID四个特性，那么这批操作就是事务操作。
<div><strong>精选留言（1）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/14/28/43/5062a59b.jpg" width="30px"><span>shan</span> 👍（6） 💬（2）<div>RocketMQ事务的实现

1. 生产者发送事务消息
生产者在发送事务消息的时候，会在消息属性中设置PROPERTY_TRANSACTION_PREPARED属性，然后向Broker发送消息，Broker收到消息后，会判断消息是否含有该属性，如果没有该属性，表示是普通消息，按照普通消息处理即可，如果有该属性
表示事务消息，不能直接投递到实际的消息队列中，否则一旦加入就会被消费者消费，所以需要先对消息暂存，RocketMQ设置了一个RMQ_SYS_TRANS_HALF_TOPIC主题先将消息存入这个主题中，此时消息对消费者不可见，不能被消费者消费，称为half消息。

2. half消息发送成功之后，开始执行本地事务（执行executeLocalTransaction方法）。

3. 结束事务，会根据本地事务的执行结果来决定回滚还是提交事务，然后向Broker发送结束事务的请求，请求中携带本地事务的执行结果，Broker收到请求后根据执行结果进行处理：
（1）COMMIT_MESSAGE：表示提交事务，请求信息中携带了消息的偏移量，会根据偏移量先查找消息是否存在，如果存在与请求头中携带的消息信息进行对比校验是否一致，校验通过才可以提交事务，然后恢复消息原本的主题和队列，将消息投递到对应的队列中，之后将对应的half消息标记删除；
（2）TRANSACTION_ROLLBACK_TYPE：表示回滚事务，同样会先根据请求中的消息偏移量进行查找并校验，通过之后，将对应的half消息进行删除；

由于RocketMQ追加写的性能并不会直接从RMQ_SYS_TRANS_HALF_TOPIC队列中删除消息，而是使用了另外一个主题RMQ_SYS_TRANS_OP_HALF_TOPIC（以下简称OP主题&#47;队列）将已提交或者回滚的事务放入到OP主题的队列中，在补偿机制对half消息进行检查的时候会从此队列中判断是消息是否被删除。

补偿机制（事务状态检查）
在事务处理任一阶段出现异常都有可能导致事务未能成功的进行提交&#47;回滚，所以需要增加一种补偿机制，定时对RMQ_SYS_TRANS_HALF_TOPIC主题中的half消息进行检查。
在处理half消息时，可以通过OP队列来判断消息是否被删除，被删除的消息不需要处理，未被删除的消息，满足回查条件时，可以进行状态回查（执行checkLocalTransaction方法），之后再根据回查结果决定是否需要提交&#47;回滚。</div>2023-09-19</li><br/>
</ul>