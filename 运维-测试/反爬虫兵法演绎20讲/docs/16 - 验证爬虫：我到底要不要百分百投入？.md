你好，我是DS Hunter，反爬虫专家，又见面了。

前面，我们讲了反爬虫的前置操作，例如快速下线的保命技巧，key生成的相关知识。那么这一讲，我们就谈谈反爬虫最终的核心诉求：验证爬虫。

实际上，在上一讲的规则引擎里面，我们已经对爬虫做了一些验证操作。但是，那里的验证只是简单的规则校验，还属于比较初级的校验。高级校验就要考虑得更多一些。

两者之间有什么不同呢？我们可以试试用不同的英文单词来区分两者。上一讲的验证，更多是validate，而这一讲，则更多是test or confirm。也就是说，这一讲的验证，并非单纯的校验客观上是否符合某种规定，更多的是检测、确认主观上是否是我们想要的。

那我们直接从规则组合的部分开始吧。

## 规则组合

相信现在的你已经知道了，规则引擎是由多个规则构成的。而这些规则较为通用，并不是针对指定场景的。因此，针对不同的场景，我们可以对规则进行组合使用。这里，我们要讨论的就是组合过程中需要注意的地方。

例如，价格页面可能会存在对商品ID的判定，但是通用促销页面则可能是判定用户属性，他们使用的规则会有所不同。价格页面用A和B的组合，促销页面用B和C的组合。这就像游戏中，每个装备都有自己的属性以及作用。而不同的玩家根据自己的需要，会对装备进行组合，寻找更匹配自己的“套装”。
<div><strong>精选留言（1）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（0） 💬（1）<div>产品经理如果提了个需求：在某 GPS 点，拉黑半径五公里的用户。这个需求是画圆，需要进行计算了，不能无脑判定经纬度了。如何让性能提升呢？
找近似解：
1、一个大圆，可以近似为多个平行的矩形，两级判断效率没问题，内存浪费也不多
2、根据位置，枚举基站，根据基站，限制IP。当然，如果条件允许，也可以根据历史数据，直接枚举IP。
3、再懒一些呢，只做乘法加法计算，不做开方运算，数据量小也能凑合

当然，其实优先要问的是，产品为啥要定义这种规则，究竟要解决的根本问题是啥，产品给出的技术方案很多时候有较大的优化空间。</div>2022-03-17</li><br/>
</ul>