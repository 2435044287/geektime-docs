你好，我是张磊。今天我和你分享的主题是：容器存储实践之CSI插件编写指南。

在上一篇文章中，我已经为你详细讲解了CSI插件机制的设计原理。今天我将继续和你一起实践一个CSI插件的编写过程。

为了能够覆盖到CSI插件的所有功能，我这一次选择了DigitalOcean的块存储（Block Storage）服务，来作为实践对象。

DigitalOcean是业界知名的“最简”公有云服务，即：它只提供虚拟机、存储、网络等为数不多的几个基础功能，其他功能一概不管。而这，恰恰就使得DigitalOcean成了我们在公有云上实践Kubernetes的最佳选择。

我们这次编写的CSI插件的功能，就是：让我们运行在DigitalOcean上的Kubernetes集群能够使用它的块存储服务，作为容器的持久化存储。

> 备注：在DigitalOcean上部署一个Kubernetes集群的过程，也很简单。你只需要先在DigitalOcean上创建几个虚拟机，然后按照我们在第11篇文章[《从0到1：搭建一个完整的Kubernetes集群》](https://time.geekbang.org/column/article/39724)中从0到1的步骤直接部署即可。

而有了CSI插件之后，持久化存储的用法就非常简单了，你只需要创建一个如下所示的StorageClass对象即可：
<div><strong>精选留言（30）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/13/2d/24/28acca15.jpg" width="30px"><span>DJH</span> 👍（9） 💬（5）<div>大师，请教一个问题：&quot;将Staging目录，绑定挂载到Volume对应的宿主机目录上&quot;这个绑定挂载是指mount -bind吗？ 为什么要挂载到一个临时目录，再绑定挂载Volume对应的宿主机目录上，而不是一步挂载到目标目录上？另外Staging目录具体是哪个目录？
谢谢！</div>2018-11-02</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJutT9JkFAcOk1JxOBdPuLgROpvcuxD9ROP9ACILAHITjcaYGNrZ5lHMZORYM6ibCuScDibYlgRvAIw/132" width="30px"><span>车小勺的男神</span> 👍（4） 💬（1）<div>请教一下 能用对象存储来作为持久化存储么</div>2018-11-13</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" width="30px"><span>虎虎❤️</span> 👍（3） 💬（2）<div>请问在上一节里提到 “ CSI 的 api 不会直接使用 Kubernetes 定义的 PV 类型， 而是会自己定义一个单独的 volume 类型。 这个在digitalocean csi 里具体体现是什么？是一个cdr吗，我好像没找到。</div>2018-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" width="30px"><span>虎虎❤️</span> 👍（3） 💬（3）<div>DJH 竟然和我的问题一模一样，握手！
为什么不直接把设备挂载到 volume宿主机目录？在pv&#47;pvc到底讲什么那么一节里就是这么讲的。
在这里有什么特殊的考虑吗？
</div>2018-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/bd/28/df2b8cee.jpg" width="30px"><span>JZY</span> 👍（0） 💬（1）<div>请问哪里有完整的示例呢，我看文中有部分是...省略的</div>2019-01-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/2e/72/145c10db.jpg" width="30px"><span>每日都想上班</span> 👍（0） 💬（1）<div>有个问题：service后挂载多个pod，service的调度是轮询的还是怎么样的呢</div>2018-11-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1a/05/fc/bceb3f2b.jpg" width="30px"><span>开心哥</span> 👍（39） 💬（8）<div>果然是云原生技术，听的云里雾里。</div>2020-07-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg" width="30px"><span>djfhchdh</span> 👍（33） 💬（0）<div>flexVolume插件只负责attach和mount，使用简单。而CSI插件包括了一部分原来kubernetes中存储管理的功能，实现、部署起来比较复杂。所以，如果场景简单，不需要Dynamic Provisioning，则可以使用flexVolume；如果场景复杂，需要支持Dynamic Provisioning，则用CSI插件。</div>2019-11-15</li><br/><li><img src="" width="30px"><span>ch_ort</span> 👍（14） 💬（0）<div>CSI的工作原理： 步骤分为存储插件注册、创建磁盘、挂载磁盘到虚拟机、挂载磁盘到Volume。其中

插件注册： Driver Register调用CSI的CSI Identify来完成注册，将插件注册到kubelet里面（这可以类比，将可执行文件放在插件目录下）。
存储创建：External Provisioner调用CSI的CSI Controller来创建PV和(远程)存储Volume，PV和PVC绑定之后，需要经过Attach和Mount这两阶段之后才能变成宿主机可用的Volume。所以，PV和PVC绑定之后，在Pod所在的宿主机上，执行Attach和Mount，即：

挂载磁盘到虚拟机： External Attacher调用CSI Controller来将新创建的存储卷挂载到虚拟机上（Attach）
格式化并挂载到Volume：k8s的Node节点调用CSI Node 将虚拟机上的存储卷格式化并挂载到容器的Volume上（Mount）

例：

当用户创建了一个PVC之后，External Provisioner会监听到这个PVC的诞生，然后调用同一个Pod里的CSI插件的CSI Controller服务的CreateVolume方法，为你创建出对应的PV。这时候，运行在Kubernetes Master节点上的Volume Controller就会通过PersistentVolumeController控制循环，发现这对新创建出来的PV和PVC，并且看到它们声明的是同一个StorageClass。所以，它会把这一对PV和PVC绑定，使PVC进入Bound状态。然后，用户创建一个声明使用上述PVC的Pod，并且这个Pod被调度到了宿主机A上，这时，Volume Controller的AttachDetachController控制循环就会发现，上述PVC对应的Volume，需要被Attach到宿主机A上。所以，AttachDetachController就会创建一个VolumeAttachment对象，这个对象携带了宿主机A和待处理的Volume名字。External  Attacher监听到VolumeAttachment对象的诞生。于是，它就会使用这个对象里的宿主机和Volume名字，调用同一个Pod里的CSI插件的CSI Controller服务的ControllerPublishVolume，完成Attach阶段。上述过程完成后，运行在宿主机A的kubelet，就会通过VolumeManagerReconciler控制循环，发现当前宿主机上有一个Volume对应的存储设备（比如磁盘）已经被Attach到了某个设备目录下。于是kubelet就会调用同一宿主机上的CSI插件的CSI Node服务的NodeStageVolume和NodePublishVolume完成这个Volume的“Mount阶段”。至此，一个完成的持久化Volume的创建和挂载就结束了。
</div>2020-10-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg" width="30px"><span>拉欧</span> 👍（14） 💬（0）<div>老师对k8s的理解真心让人敬佩</div>2019-11-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/69/11/831cec7d.jpg" width="30px"><span>小寞子。(≥3≤)</span> 👍（0） 💬（0）<div>不知道2021年这一套是否还这样。 我手上有个openshift的cluster 里面的实现好像并不太一样  </div>2021-01-06</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIvc0wApgEPKZu9SqlyGcrj2l42bJezgicKficl7kaBA8MJx6Cbcl92YqVJ1BTTdibR9gcbrtqjpKskA/132" width="30px"><span>Geek_da8747</span> 👍（0） 💬（0）<div>请教一个问题，当我创建完StorageClass、PVC、Pod之后，我的CSI插件没有调用ControllerServer的CreateVolume。
identityserver的GetPluginCapabilities中使用了 PluginCapability_Service_CONTROLLER_SERVICE
并且也在适当的位置声明了ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME
边车也没有出现问题
还有什么原因能产生这个问题？</div>2020-09-02</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/11/ba/2175bc50.jpg" width="30px"><span>Mr.Brooks</span> 👍（0） 💬（2）<div>external provisioner是以sidecar的方式部署在worker node上的pod吧？ 那么当有一个PVC出现的时候，是谁决定用哪一个node上的provisioner呢？</div>2020-06-30</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJfTWEjEXibe7pTcicDtibSWia5xiaqmibmb1qB1UcFO2QBFtMibP1fF8E8REA4n6NPctU13APPkdnV8JHvw/132" width="30px"><span>胖达</span> 👍（0） 💬（0）<div>老师，请教下NodePublishVolume可以从请求参数中获取namespaces等信息么</div>2020-03-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/bc/15/23ce17f9.jpg" width="30px"><span>数字记忆</span> 👍（0） 💬（0）<div>写的太好了</div>2019-07-19</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJutT9JkFAcOk1JxOBdPuLgROpvcuxD9ROP9ACILAHITjcaYGNrZ5lHMZORYM6ibCuScDibYlgRvAIw/132" width="30px"><span>车小勺的男神</span> 👍（0） 💬（0）<div>s3的存储插件大多是通过s3fs这类的工具实现的，请问s3可以直接用做持久化存储嘛</div>2018-11-14</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/b0/57/a84d633e.jpg" width="30px"><span>圣诞使者</span> 👍（0） 💬（1）<div>看了别人的评论，我也不是很懂这个 NodeStageVolume，NodePublishVolume 这个两阶段处理，我下载了 digitalocean 的源码，看到这个句话 driver&#47;node.go (200)： #Perform a bind mount to the full path to allow duplicate mounts of the same PD，感觉NodePublishVolume主要就是这个作用，PD没理解什么意思，猜测是physical driver。还请老师解惑。</div>2018-11-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/e9/91/4219d305.jpg" width="30px"><span>初学者</span> 👍（13） 💬（0）<div>一般来说一个块存储在被宿主机使用之前，需要先将该块存储load 到宿主机的&#47;dev 下成为linux 的设备文件，然后format还设备文件，然后挂载到一个目录下就可以使用了，我觉得nodestagevolume这步挂载操作更像是为了同一台宿主机上的pod 可以共享一块盘</div>2018-11-07</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIh7iatqAeGsJuDNxsDlmCQx64ktJl7ATAkBtDO6iczIqsLFPXkF6GPGJpMBCxbl4DJ5obHwAK0bSAQ/132" width="30px"><span>朱东辉</span> 👍（5） 💬（0）<div>张大佬真的天花板一样的存储，二刷依然收获满满，多谢大佬提供的这么好的学习资料</div>2021-03-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" width="30px"><span>xfan</span> 👍（4） 💬（0）<div>找到了，文中有出现。是在 https:&#47;&#47;raw.githubusercontent.com&#47;digitalocean&#47;csi-digitalocean
</div>2019-01-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/1b/b4/a6db1c1e.jpg" width="30px"><span>silver</span> 👍（4） 💬（0）<div>块处理设备从挂载到staging，到挂载到宿主机目录具体做了哪些预处理呢？我和前面几位一样，对需要分两部挂载不是很理解</div>2018-11-05</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/30/f3/03/24a0e652.jpg" width="30px"><span>🍊 🐱</span> 👍（2） 💬（0）<div>有的同学跟我有一样的疑惑，就是 staging 这一步为什么需要再格式化后挂载到一个临时目录，而不是直接留给 publish 阶段挂在到 pod 中，根据作者给其他小伙伴的回复和我阅读 sample 代码的理解如下：kubelet 的 VolumeManagerReconciler 分两步 mount 的原因是假如直接一步 format 的过程非常久，可能会导致 reconciler 阻塞，而分开两步可以解决这个问题，另外在第一步 staging 后挂载到临时目录（由 req 获取）的目的是方便 reconciler 判断 volum（通过传给第一步 req 的临时目录） 是否 format 完毕，可以进入第二步挂载到 pod 中。如果理解错了还希望作者指出。</div>2022-10-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/5a/65/b80035a6.jpg" width="30px"><span>ryan</span> 👍（2） 💬（0）<div>好像看懂了，又好像没看懂</div>2022-03-22</li><br/><li><img src="" width="30px"><span>Geek_f1b96b</span> 👍（1） 💬（0）<div>老师，你好：  ControllerPublishVolume 这个方法是如何将 块设备map到node上的？ 它应该是external-attacher （deployment 或daemonset）中的方法，它和node中的哪个进程通信nodeplugin or kubelet？tks</div>2020-03-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1b/7b/2b/97e4d599.jpg" width="30px"><span>Podman</span> 👍（1） 💬（0）<div>请教一下，glusterfs+heketi+k8s实现的自动绑定PV的模式 我是否可以理解为与ceph+rook+k8s模式一致？CSI实现的自定义存储插件与rook的角色有何不同？glusterfs+heketi+k8s的架构是不是也可以通过CSI来实现？</div>2020-01-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg" width="30px"><span>Alery</span> 👍（1） 💬（0）<div>对于文件系统类型的存储服务，例如: NFS，它并没有对一个的磁盘设备存在与宿主机上，有些nfs类型的csi driver上并没有实现ControllerPublishVolume这个操作，是不是可以理解这里nfs存储卷的attach阶段只是创建了VolumeAttachment对象，并不需要通过ControllerPublishVolume完成nfs volume挂载到虚拟机上？</div>2018-12-07</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/20/6f/f0/27890c6a.jpg" width="30px"><span>Geek_00b6c5</span> 👍（0） 💬（0）<div>一直没搞懂为何要staging下，这一步我怎么看都是多余的，这里面做了预处理吗？比如格式化磁盘啥的，为后续的正真挂载做准备？</div>2024-04-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/21/0c/7b/8176c0dd.jpg" width="30px"><span>Jing Li</span> 👍（0） 💬（0）<div>最后总结中的部分，将pv与pvc的生命周期以及实现原理讲解的非常清楚！学习了～</div>2023-10-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/fe/9a/791d0f5e.jpg" width="30px"><span>阿凯啊</span> 👍（0） 💬（0）<div>最近我们公司遇到个问题，由于我也不是运维人员，所以这边得到的信息有限。看看能否得到大家帮助。我们公司用的openshift + nas存储，每次nas抖动，都会导致consul集群的raft文件损坏，导致consul集群不能正常恢复。据运维说发生故障的时候，nas节点发生了ip漂移，但是pod和nas的长连接没能正常漂移过去，所以导致的文件损坏。</div>2023-05-12</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/22/72/1f/9ddfeff7.jpg" width="30px"><span>文进</span> 👍（0） 💬（0）<div>1，CSI一开始部署（每个节点部署）只是向Driver Registrar通过CSI Identify注册了身份，以及部署CSI NODE服务
2，第二次部署，集群唯一，部署了CSI Controller服务。
3，用户创建PVC时，并且声明StorageClass使用指定身份的CSI插件时，External Provisioner组件调用CSI Controller的createV来创建一个PV，可能是通过远程API创建。此时只是创建，还未进行attach和mount。
4，PersistentVolumeController循环会自动将PV和PVC已经绑定在一起。
5，当用户的创建需要使用这个PVC的pod时，在kubelet进行调度时，会把此pod和宿主机先绑定。然后AttachDetachController会识别到有个pod未设置attach，然后就会创建VolumeAttachment对象，携带宿主机和pvc的信息。
6，集群中的External Attacher会监听到VolumeAttachment创建，然后调用CSI的attach逻辑。
7，运行在宿主机 A 上的 kubelet，就会通过 VolumeManagerReconciler 控制循环，发现当前宿主机上有一个 Volume 对应的存储设备（比如磁盘）已经被 Attach 到了某个设备目录下。于是 kubelet 就会调用同一台宿主机上的 CSI 插件的 CSI Node 服务的 NodeStageVolume 和 NodePublishVolume 方法，完成这个 Volume 的“Mount 阶段”</div>2023-03-03</li><br/>
</ul>