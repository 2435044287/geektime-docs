从今天开始，咱们专栏进入 “程序之术” 中关于写代码的一个你可能非常熟悉，却也常苦恼的小主题：Bug。

写程序的路上，会有一个长期伴随你的 “同伴”：Bug，它就像程序里的寄生虫。不过，Bug 最早真的是一只虫子。

1947年，哈佛大学的计算机哈佛二代（Harvard Mark II）突然停止了运行，程序员在电路板编号为 70 的中继器触点旁发现了一只飞蛾。然后把飞蛾贴在了计算机维护日志上，并写下了首个发现 Bug 的实际案例。程序错误从此被称作 Bug。

这只飞蛾也就成了人类历史上的第一个程序 Bug。

回想下，在编程路上你遇到得最多的 Bug 是哪类？我的个人感受是，经常被测试或产品经理要求修改和返工的 Bug。这类 Bug 都来自于对需求理解的误差，其实属于沟通理解问题，我并不将其归类为真正的技术性 Bug。

技术性 Bug 可以从很多维度分类，而我则习惯于从 Bug 出现的 “时空” 特征角度来分类。可划为如下两类：

- 空间：环境过敏
- 时间：周期规律

我们就先看看 Bug 的**空间维度**特征。

## 环境过敏

环境，即程序运行时的空间与依赖。

程序运行的依赖环境是很复杂的，而且一般没那么可靠，总是可能出现这样或那样的问题。曾经我经历过一次因为运行环境导致的故障案例：一开始系统异常表现出来的现象是，有个功能出现时不时的不可用；不久之后，系统开始报警，不停地接到系统的报警短信。
<div><strong>精选留言（9）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg" width="30px"><span>亚林</span> 👍（28） 💬（1）<div>上联：为系统而生，为框架而死，为debug奋斗一辈子
下联：吃符号的亏，上大小写的当，最后死在需求上！</div>2018-08-30</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" width="30px"><span>钱</span> 👍（5） 💬（1）<div>Bug，会想一下，遇到比较多的基本也是测试测出来的，不过大部分是无害的。最严重还是产品翻译业务需求有误这种危害最大，轻则返工，重则重来。
另外，就是那些没覆盖到的，上线后才发现，电商系统又是核心模块，影响可就大了，分分钟几十万。
空间和时间的划分非常妙，人是三维生物，这两个维度几乎可以划分N多的领域也都贴切。
空间上交互也是容易产生差异和不和谐，与人交互，系统间交互都类似，且交越多越容易产生差异和问题。比如：与数据库交互、与缓存交互、系统间调用、系统间发消息等等。但是不交互是不现实的。</div>2018-08-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/64/04/18875529.jpg" width="30px"><span>艾尔欧唯伊</span> 👍（3） 💬（1）<div>不是，是采集硬件设备运行指标的组件。。。客户有大有小，小客户嘛，一台服务器跑一整套软件平台，几十个应用。。我们只是其中一小部分</div>2018-09-01</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/a4/5a/e708e423.jpg" width="30px"><span>third</span> 👍（3） 💬（1）<div>火车上，一个洞接一个洞，网速有点爆炸。
简略心得

1.我记得曾经看过，bug是被一个非常厉害的女程序员发现的，有兴趣的同学可以搜搜一下

2.我个人对bug的理解和感受是，创造过程中，难免会出现的瑕疵

3.技术性bug

4.技术性bug分为两类
空间：环境过敏
时间：周期规律

5.“程序过敏反应” ：“程序将存在问题的环境当作正常处理，从而产生的异常。”

6.应对空间纬度上bug，是理解环境，同时保持检测</div>2018-08-29</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/e8/0a/16a3609e.jpg" width="30px"><span>逝光无痕</span> 👍（2） 💬（1）<div>其实好多的bug是沟通不明确，翻译出来的问题！</div>2018-12-06</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/64/04/18875529.jpg" width="30px"><span>艾尔欧唯伊</span> 👍（2） 💬（1）<div>现在的项目，对内存限制特别大，出现的问题根本不知道，到底是基本配置不满足还是程序优化不够。。。
暴露问题大多有时间属性，还经常没有关键日志。。。定位分析真的想吐血。</div>2018-08-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/4e/8b/964b3b80.jpg" width="30px"><span>热勇</span> 👍（1） 💬（1）<div>确实，学习了！毕业一年！系统偏向业务！我是不是可以理解成写的大多都是(业务代码)呢？我发现自己的理解能力确实存在较大问题！所以存在很多问题！老师，该如何提升自身沟通理解能力呢？还在摸索学习中…</div>2018-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/7a/d2/4ba67c0c.jpg" width="30px"><span>Sch0ng</span> 👍（2） 💬（0）<div>Java工作中JVM之上，JVM工作在OS之上，OS工作在硬件之上，硬件工作在物理化学原理之上。
从Java到硬件，都是属于人造的东西，人造的一个特点就是不可靠。
物理化学原理，属于神造的东西，是可靠的。
人造的不可靠不是非黑即白的，而是一个概率事件。
人造的东西不能在设计的时候完全避免bug，只能通过事后测试把问题找出来再解决掉，一般认为所有的测试都通过，就算达标。
经过多年测试验证，产生了一个结果--越是下层越是经历了时间的考验可靠性越高越稳定。
由此可以推出离自己创造的最近一层出问题的概率是最高的。
这与作者“至少必须关心与程序运行直接相关联的那一层环境”是不谋而合的。

软件是一个人造系统，要清醒的认识bug到不能根除的.开发者所做的所有努力都是为了避免bug的发生，努力到成本和收益达到某种均衡为止。

越简单的东西越稳定，所以前面篇章中所说的炫技，对于一个软件来讲无疑是最毒的毒药。</div>2021-02-25</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/c0/15/02fe27bf.jpg" width="30px"><span>戴益波</span> 👍（0） 💬（0）<div>好干，快看不下去了</div>2019-11-19</li><br/>
</ul>