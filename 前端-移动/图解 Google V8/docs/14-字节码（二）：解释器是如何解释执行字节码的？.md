你好，我是李兵。

在上节我们介绍了V8为什么要引入字节码，这节课我们来聊聊解释器是如何解释执行字节码的。学习字节码如何被执行，可以让我们理解解释器的工作机制，同时还能帮助我们搞懂JavaScript运行时的内存结构，特别是闭包的结构和非闭包数据的区别。

字节码的解释执行在编译流水线中的位置你可以参看下图：

![](https://static001.geekbang.org/resource/image/e4/01/e4735f5bb848120b5fd931acae5eb101.jpg?wh=2284%2A1285)

## 如何生成字节码？

我们知道当V8执行一段JavaScript代码时，会先对JavaScript代码进行解析(Parser)，并生成为AST和作用域信息，之后AST和作用域信息被输入到一个称为Ignition 的解释器中，并将其转化为字节码，之后字节码再由Ignition解释器来解释执行。

接下来，我们就结合一段代码来看看执行解释器是怎么解释执行字节码的。你可以参看下面这段代码：

```
function add(x, y) {
  var z = x+y
  return z
}
console.log(add(1, 2))
```

在控制台执行这段代码，会返回数字3，V8是如何得到这个结果的呢？

刚刚我们提到了，V8首先会将函数的源码解析为AST，这一步由解析器(Parser)完成，你可以在d8中通过–print-ast 命令来查看V8内部生成的AST。

```
[generating bytecode for function: add]
--- AST ---
FUNC at 12
. KIND 0
. LITERAL ID 1
. SUSPEND COUNT 0
. NAME "add"
. PARAMS
. . VAR (0x7fa7bf8048e8) (mode = VAR, assigned = false) "x"
. . VAR (0x7fa7bf804990) (mode = VAR, assigned = false) "y"
. DECLS
. . VARIABLE (0x7fa7bf8048e8) (mode = VAR, assigned = false) "x"
. . VARIABLE (0x7fa7bf804990) (mode = VAR, assigned = false) "y"
. . VARIABLE (0x7fa7bf804a38) (mode = VAR, assigned = false) "z"
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 31
. . . INIT at 31
. . . . VAR PROXY local[0] (0x7fa7bf804a38) (mode = VAR, assigned = false) "z"
. . . . ADD at 32
. . . . . VAR PROXY parameter[0] (0x7fa7bf8048e8) (mode = VAR, assigned = false) "x"
. . . . . VAR PROXY parameter[1] (0x7fa7bf804990) (mode = VAR, assigned = false) "y"
. RETURN at 37
. . VAR PROXY local[0] (0x7fa7bf804a38) (mode = VAR, assigned = false) "z"
```

同样，我们将其图形化：

![](https://static001.geekbang.org/resource/image/94/aa/94b31db22a69f95b2d211ccedbbfa6aa.jpg?wh=2284%2A1285)

从图中可以看出，函数的字面量被解析为AST树的形态，这个函数主要拆分成四部分。
<div><strong>精选留言（21）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg" width="30px"><span>Shine</span> 👍（10） 💬（4）<div>老师我有一个疑问：&#39;Ldar a1表示将寄存器中的值加载到累加器中&#39;    a1的值不是在栈里面吗？不是直接从栈中加载到累加器吗？</div>2020-04-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/1c/13/676f87ca.jpg" width="30px"><span>木山</span> 👍（5） 💬（1）<div>老师下午好, 我来这里催加餐了(笑),</div>2020-04-17</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdzXiawss5gGiax48CJGAJpha4pJksPia7J7HsiatYwjBA9w1bkrDicXfQz1SthaG3w1KJ2ibOxpia5wfbQ/132" width="30px"><span>chris</span> 👍（4） 💬（2）<div>另外请问老师对jvm的字节码熟悉吗，能否推荐一些jvm字节码与v8字节码的比较的资料。目前看到的差异是1）基于栈和基于寄存器，2）v8字节码带了feedback vector。不知还有什么其他的差异。两者之间能否相互表示。openjdk里面自带的nashorn就是一个用java实现的js引擎，它是把js翻译成java字节码吗？</div>2020-04-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/88/2e/db17801a.jpg" width="30px"><span>灰的更高</span> 👍（1） 💬（1）<div>老师，我在这次的课件中看到了，小整型smi。我之前在看书的时候看到了v8的数据表示，书上说smi直接使用前32位进行数值表示，后32位为句柄且最后一位标记位是1，除了smi其他的类型都是存放的指针句柄最后一位是0，但是我不清楚这个其他类型存档指针是什么格式，然后又怎么样和咱们课程里面的内容联系在一起呢，麻烦您能简单介绍一下吗</div>2020-05-13</li><br/><li><img src="" width="30px"><span>Geek_bcfa56</span> 👍（5） 💬（0）<div>&#47;**
[generated bytecode for function: foo (0x32e4082d26c5 &lt;SharedFunctionInfo foo&gt;)]

&#47;&#47; Creates a new context with number of |slots| for the function closure
CreateFunctionContext [0], [1] &#47;&#47; 创建函数上下文环境

&#47;&#47; Saves the current context in &lt;context&gt;, and pushes the accumulator as the
&#47;&#47; new current context.
PushContext r0                 &#47;&#47; 保存旧的上下文到r0中，然后把累加器中的内容作为新的上下文

LdaSmi [20]                   &#47;&#47; 加载20到累加器中
StaCurrentContextSlot [2]     &#47;&#47; 把累加器中的值存储到上下文中的slot 2中
CreateClosure [1], [0], #2    &#47;&#47; 创建闭包，并存储在累加器中
Return                        &#47;&#47; 返回累加器中的值 

[generated bytecode for function: inner (0x32e4082d28e9 &lt;SharedFunctionInfo inner&gt;)]
Ldar a1                       &#47;&#47; 把a1加载到累加器中
Add a0, [0]                   &#47;&#47; 把累加器中的值和a0相加，即a0+a1
Star r1                       &#47;&#47; 把累加器中的值存储到r1

&#47;&#47; Load the object in |slot_index| of the current context into the accumulator.
&#47;&#47; 把当前上下文中的slot 2加载到累加器中，即把20(变量d)加载到累加器中
LdaImmutableCurrentContextSlot [2] 
Add r1, [1]     &#47;&#47; 把r1跟累加器中的值相加
Star r0         &#47;&#47; 把累加器中的值存储到r0
Return          &#47;&#47; 返回累加器中的值 

*&#47;</div>2020-11-26</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f7/56/b82eeac7.jpg" width="30px"><span>champ可口可乐了</span> 👍（5） 💬（1）<div>[generated bytecode for function: add (0x02160824fe59 &lt;SharedFunctionInfo add&gt;)]
Parameter count 3
Register count 1
Frame size 8
         0x21608250026 @    0 : 25 02             Ldar a1
         0x21608250028 @    2 : 34 03 00          Add a0, [0]
         0x2160825002b @    5 : 26 fb             Star r0
         0x2160825002d @    7 : aa                Return 
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 0)

这是我的Mac平台输出的字节码，好像那2条无用代码被优化掉了。
但是，函数开头没有出现 StackCheck，不知道为什么</div>2020-04-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/e2/8e/b4ccfa02.jpg" width="30px"><span>Imart</span> 👍（4） 💬（0）<div>解释器执行字节码 ‘Ldar a1’时，最底层还是会转换为机器码再由 cpu 来吗？这些字节码指令的执行实际需要再调用cpu执行吗？</div>2020-08-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（3） 💬（0）<div>在生成 作用域 那个图里面， 参数 x ，y 在堆中进行声明吗？ 这个不应该也是在栈中的？</div>2020-04-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/15/2c/07/636a47cd.jpg" width="30px"><span>慢慢来的比较快</span> 👍（1） 💬（1）<div>字节码是所有的代码编译出来的，用于缓存的状态，那么这时还有12节说的延迟解析吗？</div>2021-03-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/e2/8e/b4ccfa02.jpg" width="30px"><span>Imart</span> 👍（1） 💬（1）<div>老师 您好，解释器解释执行字节码，为什么之后还需要编译为二进制码给cpu执行？比如 Ldar a1 这句字节码 最终是不是也编译为对应的机器码，再给cpu 执行？</div>2020-08-24</li><br/><li><img src="" width="30px"><span>doujiao</span> 👍（1） 💬（1）<div>我有个问题，参数是什么时候放到栈里的？生成作用域吗？</div>2020-07-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" width="30px"><span>奕</span> 👍（1） 💬（1）<div>解释器 执行字节码 ，是在解释器内部执行吗？ 底层还需要把指令在放到 CPU执行 吗？ 这里的 寄存器 是解释器内部的？ 还是指CPU的寄存器？</div>2020-04-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> 👍（0） 💬（0）<div>学习打卡</div>2024-06-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/17/05/93/3c3f2a6d.jpg" width="30px"><span>安石</span> 👍（0） 💬（0）<div>```
 Ldar a1
         0x21e1000dafc8 @    2 : 38 03 00          Add a0, [0]
         0x21e1000dafcb @    5 : c3                Star1
         0x21e1000dafcc @    6 : 17 02             LdaImmutableCurrentContextSlot [2]
         0x21e1000dafce @    8 : 38 f9 01          Add r1, [1]
         0x21e1000dafd1 @   11 : c4                Star0
         0x21e1000dafd2 @   12 : a9                Return
```
将a1加载到 累加寄存器
从a0寄存器取值和累加寄存器的值相加，并保存
读取保存在堆（闭包）上下文变量
累加寄存器加上从闭包山下读取的变量
将累加寄存器的保存
返回结果
</div>2023-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg" width="30px"><span>Jerry银银</span> 👍（0） 💬（0）<div>老师，我有两个疑问：
1、文中提到的寄存器就是计算机真实的寄存器硬件吧。如果是真实的寄存器硬件的话，那不同的机器上（x86，arm) 的解释器设计的时候肯定就要和硬件相关了吧？

2. 在不考虑JIT的前提下，字节码是被解释器解释执行的，最终需要解释器转化为机器码然后才执行吗？还是说，不会转化为机器码，而是由解释器直接得出最终的结果？

静候老师解答~谢谢</div>2021-11-08</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/wxibiarLBnjaMtQvr6Y1sTic1lnqX1mPfrg3CW6YhxVrjx3ibsPEhFyg7icctAfZVI9bW2sruXYdQPGy2iaSjnCBSFkQ/132" width="30px"><span>Geek_6c653d</span> 👍（0） 💬（0）<div>a0和a1是参数，同时也是寄存器吗？图中看到的时候a0和a1是保存到栈中的，但是文中也提到了a0 a1时寄存器？</div>2021-10-09</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/yNiaZS0TNFIMcOOSicBs1RczrmV9JhlN8j8cOwqYYKvK8I2Oceq1cdKKuf51GvpricMjAUiciag2opCcTeRibwd6NPFg/132" width="30px"><span>loadfailed</span> 👍（0） 💬（0）<div>老师，请问下StaGlobal这个指令是干啥的？我猜测是读取常量池中2下标的内容，并提供给反馈向量做优化用的，不知道对不对</div>2021-08-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg" width="30px"><span>neohope</span> 👍（0） 💬（0）<div>估计是被编辑器强转了，应该是：
--print-ast
--print-scope
--print-bytecode</div>2020-07-24</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/0f/c1/10/28d5a686.jpg" width="30px"><span>Longerian</span> 👍（0） 💬（3）<div>v8生成的字节码，为什么先把第二个参数load到累加器里，v8 处理参数的顺序是倒序的吗？</div>2020-04-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/4f/94/05044c31.jpg" width="30px"><span>踢车牛</span> 👍（0） 💬（0）<div>Frame size 8
   13 E&gt; 0x3506cbf1f8c6 @    0 : a5                StackCheck
   32 S&gt; 0x3506cbf1f8c7 @    1 : 25 02             Ldar a1
   33 E&gt; 0x3506cbf1f8c9 @    3 : 34 03 00          Add a0, [0]
         0x3506cbf1f8cc @    6 : 26 fb             Star r0
   46 S&gt; 0x3506cbf1f8ce @    8 : a9                Return

字节码生成 5行，和老师的显示略有差异</div>2020-04-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg" width="30px"><span>qinsi</span> 👍（0） 💬（1）<div>基于栈的虚拟机实现简单，可移植性好；基于寄存器的虚拟机指令表达能力强，性能高，生成的字节码更短</div>2020-04-16</li><br/>
</ul>